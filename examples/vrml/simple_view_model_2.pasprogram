{
  Copyright 2003-2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ This is the next version of simple_view_model.pasprogram:
  simple 3D model viewer using Kambi VRML engine.
  See simple_view_model.pasprogram for initial comments.

  This version adds:

  1. Collision detection
  - constructing octrees, by "Scene.Spatial := ..."
  - doing collision detection using OctreeCollisions, see MoveAllowed
    and GetCameraHeight methods

  2. Rendering with frustum culling
  (- This is the default actually:
    scene is loaded with Optimization roSeparateShapes.)
  (- This is already done by Scene.GLProjection:
    updating Glw.Navigator.ProjectionMatrix.)
  - using Glw.Navigator.Frustum and OctreeRendering
    (ssRendering in Scene.Spatial) to render the scene,
    see line "Scene.RenderFrustum"

  3. This also shows how you can force created navigator to be of 'WALK'
     type. This causes the result of Scene.CreateNavigator to always
     have the TWalkNavigator class.
     This turns gravity on and makes camera behave FPS-like.

     Also, just for demo, we set the initial position / direction explicitly
     by code (instead of relying on Viewpoint node in VRML/X3D).

     Note that even more involved scenarios of creating Navigator are
     possible, you could create some TNavigator descendant yourself
     (without Scene.CreateNavigator help) or even do not use navigator at all.

  4. Makes FPS timings right after starting the program correct:
  - uses Glw.OnBeforeDraw and Scene.PrepareRender(false)

  5. Allows the scene to use it's own lights:
  - see Scene.Attributes.UseLights line
}

program simple_view_model_2;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  ProgressUnit, ProgressConsole, KambiFilesUtils, VRMLTriangleOctree,
  VRMLErrors, VRMLTriangle;

var
  Glw: TGLUIWindow;
  Scene: TVRMLGLScene;

procedure BeforeDraw(Glwin: TGLWindow);
begin
  Scene.PrepareRender([tgAll], [prBoundingBox]);
end;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);
  Scene.RenderFrustum(Glw.Navigator.Frustum, tgAll);
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.GLContextClose;
end;

procedure Resize(Glwin: TGLWindow);
begin
  { This sets OpenGL projection, also updating Glw.Navigator.ProjectionMatrix,
    which is important for having correct Glw.Navigator.Frustum. }
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox,
    Glwin.Width, Glwin.Height);
end;

type
  THelperObj = class
    class function MoveAllowed(Navigator: TWalkNavigator;
      const ProposedNewPos: TVector3Single; out NewPos: TVector3Single;
      const BecauseOfGravity: boolean): boolean;

    class procedure GetCameraHeight(Navigator: TWalkNavigator;
      out IsAboveTheGround: boolean; out SqrHeightAboveTheGround: Single);
  end;

class function THelperObj.MoveAllowed(Navigator: TWalkNavigator;
  const ProposedNewPos: TVector3Single; out NewPos: TVector3Single;
  const BecauseOfGravity: boolean): boolean;
begin
  Result := Scene.OctreeCollisions.MoveAllowed(
    Navigator.CameraPos, ProposedNewPos, NewPos, Navigator.CameraRadius,
    BecauseOfGravity, Scene.BoundingBox, Navigator.GravityUp);
end;

class procedure THelperObj.GetCameraHeight(Navigator: TWalkNavigator;
  out IsAboveTheGround: boolean; out SqrHeightAboveTheGround: Single);
var
  GroundItem: PVRMLTriangle;
begin
  Scene.OctreeCollisions.GetCameraHeight(
    Navigator.CameraPos,
    Navigator.GravityUp,
    IsAboveTheGround, SqrHeightAboveTheGround, GroundItem,
    nil, nil);
end;

var
  Nav: TWalkNavigator;
begin
  Glw := TGLUIWindow.Create(Application);

  Parameters.CheckHigh(1);

  VRMLWarning := @VRMLWarning_Write;
  Scene := TVRMLGLScene.Create(nil);
  try
    Scene.Load(Parameters[1]);

    Writeln(Scene.Info(true, true, false));

    { build octrees }
    Progress.UserInterface := ProgressConsoleInterface;
    Scene.TriangleOctreeProgressTitle := 'Building triangle octree';
    Scene.ShapeOctreeProgressTitle := 'Building Shape octree';
    Scene.Spatial := [ssRendering, ssDynamicCollisions];

    { init navigator }
    Nav := Scene.CreateNavigator(Glw, 'WALK') as TWalkNavigator;
    Nav.SetInitialCameraLookDir(
      Box3dMiddle(scene.BoundingBox),
      VectorAdjustToLength(Vector3Single(1, 0, 0),
        Box3dAvgSize(Scene.BoundingBox) * 0.01*0.4),
      Vector3Single(0, 1, 0), false);
    Nav.Home;
    Nav.OnMoveAllowed     := @THelperObj(nil).MoveAllowed;
    Nav.OnGetCameraHeight := @THelperObj(nil).GetCameraHeight;
    Glw.Navigator := Nav;

    { allow the scene to use it's own lights }
    Scene.Attributes.UseLights := true;
    Scene.Attributes.FirstGLFreeLight := 1;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnBeforeDraw := @BeforeDraw;
    Glw.InitAndRun(ProgramName, @Draw);
  finally Scene.Free end;
end.
