{
  Copyright 2009-2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Display, walk over the terrain.

  Terrain data may be obtained from various sources:

  1. There's terrain data reader from a very simple SRTM-3 *.hgt file
     (pass $1 a filename of .hgt file).

     See http://www2.jpl.nasa.gov/srtm/, see (linked there)
     http://dds.cr.usgs.gov/srtm/ for sample data for whole Earth.
     In you speak Polish, nice overview is also on
     http://netgis.geo.uw.edu.pl/srtm/.
     Sample files for Poland are on http://netgis.geo.uw.edu.pl/srtm/Poland/,
     for Europe http://netgis.geo.uw.edu.pl/srtm/Europe/.

     You can run the program with command-line parameter to pass filename
     of such .hgt file to load on start.

  2. You can also define terrain as an explicit function using KambiScript
     expression syntax, [http://vrmlengine.sourceforge.net/kambi_script.php].
     Try e.g. function like
     - sin(x*10) + sin(y*10)
     - (sin(x*10) + sin(x*20) / 2 + sin(x*40) / 4)  *
       (sin(y*10) + sin(y*20) / 2 + sin(y*40) / 4)
       (sum sinusoides of various frequencies and amplitudes).

  3. You can also (and this was actually the primary reason for this program
     in the 1st place) generate random terrain.

  TODO:
  - DrawGrid is temp broken now (not visible,
    and probably walk camera doesn't follow it correctly).
    For now, ignore it (it messes too much otherwise clean TElevation*
    using code).

  - switch view terrain:
    1. current view - "Examine the [0..1, 0..1] range of the terrain"
    2. new new - "Walk over the infinite terrain":
       Walk mode,
       optionally keeping avatar over the ground,
       optionally with fog (since terrain is infinite in this case),
       and using the algorithm that renders infinite terrain with LOD.
       Optionally with sky displayed, just for effect.
  Multitexture elevation, set texture mixture based on height,
  from GLSL shader.

  TODO: sliders:
  - controls for shifting noise (and calculated kam script) terrain.
    Hm, not so much needed, since increasing the freq allows you to see more,
    and in  walk mode you can explore it all.
}
program terrain;

uses SysUtils, Classes, Boxes3D,
  KambiUtils, GLWindow, GL, KambiGLUtils,
  Cameras, VectorMath, KambiFilesUtils, Elevations, GLWinMessages,
  KambiStringUtils, GLMenu, UIControls, Images, RenderElevations;

var
  Glw: TGLUIWindow;
  Camera: TCamera;
  ExamineCamera: TExamineCamera;
  WalkCamera: TWalkCamera;
  Elevation: TElevation;
  Wireframe: boolean;
  NoiseInterpolation: TNoiseInterpolation = niCosine;
  NoiseBlur: boolean = false;
  Subdivision: Cardinal = 6;

type
  TControlsNoise = class(TGLMenu)
  public
    OctavesSlider: TGLMenuFloatSlider;
    AmplitudeSlider: TGLMenuFloatSlider;
    FrequencySlider: TGLMenuFloatSlider;
    SmoothnessSlider: TGLMenuFloatSlider;
    HeterogeneousSlider: TGLMenuFloatSlider;
    SeedSlider: TGLMenuIntegerSlider;

    constructor Create(AOwner: TComponent); override;
    procedure CurrentItemAccessoryValueChanged; override;
  end;

  { For any TElevationImage except
    TElevationNoise (that has it's own TControlsNoise)
    and TElevationGrid (that has quite different rendering rules;
    for now, TElevationGrid is not TElevationImage anyway). }
  TControlsImage = class(TGLMenu)
  public
    constructor Create(AOwner: TComponent); override;
    procedure CurrentItemAccessoryValueChanged; override;
  end;

var
  { ui controls }
  ControlsNoise: TControlsNoise;
  ControlsImage: TControlsImage;
  SubdivisionSlider: TGLMenuIntegerSlider;
  ImageHeightScaleSlider: TGLMenuFloatSlider;

procedure SetElevation(Value: TElevation);
begin
  if Elevation <> Value then
  begin
    FreeAndNil(Elevation);
    Elevation := Value;

    if Elevation is TElevationNoise then
      Glw.Controls.MakeSingle(TGLMenu, ControlsNoise, true { before camera }) else
      Glw.Controls.Remove(ControlsNoise);

    if (Elevation is TElevationImage) and
       not ( (Elevation is TElevationNoise) or
             (Elevation is TElevationGrid) ) then
      Glw.Controls.MakeSingle(TGLMenu, ControlsImage, true { before camera }) else
      Glw.Controls.Remove(ControlsImage);
  end;
end;

procedure Draw(Glwin: TGLWindow);

  procedure WalkCameraAboveGround;
  var
    P: TVector3Single;
  begin
    P := WalkCamera.Position;
    { shift by -0.5, like when rendering
      TODO: this shift is Ok only for non-grid drawing }
    P[2] := Elevation.Height(P[0], P[1]);
    WalkCamera.Position := P;
  end;

begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  if Camera = WalkCamera then
    WalkCameraAboveGround;

  glLoadMatrix(Camera.Matrix);

  if Wireframe then
  begin
    glPushAttrib(GL_POLYGON_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  end else
  begin
    glPushAttrib(GL_ENABLE_BIT);
    glEnable(GL_DEPTH_TEST);
  end;

    if Elevation is TElevationGrid then
    begin
      { DrawGrid cannot make normals for now, so no LIGHTING or other stuff }
      DrawGrid(TElevationGrid(Elevation));
    end else
    begin
      glPushAttrib(GL_ENABLE_BIT);
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
        glEnable(GL_COLOR_MATERIAL);
        glEnable(GL_NORMALIZE);
        DrawElevation(Elevation, Subdivision);
      glPopAttrib;
    end;

  glPopAttrib;
end;

procedure Resize(Glwin: TGLWindow);
begin
  glViewport(0, 0, Glwin.Width, Glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height, 0.1, 100);
end;

constructor TControlsNoise.Create(AOwner: TComponent);
begin
  inherited;

  OctavesSlider := TGLMenuFloatSlider.Create(0.0, 20.0, 4.0);
  AmplitudeSlider := TGLMenuFloatSlider.Create(0.1, 10.0, 1.0);
  FrequencySlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  SmoothnessSlider := TGLMenuFloatSlider.Create(1.0, 10.0, 2.0);
  HeterogeneousSlider := TGLMenuFloatSlider.Create(0.0, 2.0, 0.0);
  SeedSlider := TGLMenuIntegerSlider.Create(0, 99, 0);

  Items.AddObject('Octaves', OctavesSlider);
  Items.AddObject('Amplitude (scales height)', AmplitudeSlider);
  Items.AddObject('Frequency (scales size)', FrequencySlider);
  Items.AddObject('Smoothness', SmoothnessSlider);
  Items.AddObject('Heterogeneous', HeterogeneousSlider);
  Items.AddObject('Seed', SeedSlider);
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  Items.AddObject('Image height scale', ImageHeightScaleSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TControlsNoise.CurrentItemAccessoryValueChanged;
begin
  if not (Elevation is TElevationNoise) then Exit;
  case CurrentItem of
    0: (Elevation as TElevationNoise).Octaves := OctavesSlider.Value;
    1: (Elevation as TElevationNoise).Amplitude := AmplitudeSlider.Value;
    2: (Elevation as TElevationNoise).Frequency := FrequencySlider.Value;
    3: (Elevation as TElevationNoise).Smoothness := SmoothnessSlider.Value;
    4: (Elevation as TElevationNoise).Heterogeneous := HeterogeneousSlider.Value;
    5: (Elevation as TElevationNoise).Seed := SeedSlider.Value;
    6: Subdivision := SubdivisionSlider.Value;
    7: (Elevation as TElevationNoise).ImageHeightScale := ImageHeightScaleSlider.Value;
  end;
  inherited;
end;

constructor TControlsImage.Create(AOwner: TComponent);
begin
  inherited;
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  Items.AddObject('Image height scale', ImageHeightScaleSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TControlsImage.CurrentItemAccessoryValueChanged;
begin
  case CurrentItem of
    0: Subdivision := SubdivisionSlider.Value;
    1: (Elevation as TElevationImage).ImageHeightScale := ImageHeightScaleSlider.Value;
  end;
  inherited;
end;

procedure Init(Glwin: TGLWindow);
begin
  RenderElevationsInitGL;

  { sliders used by both Controls* }
  SubdivisionSlider := TGLMenuIntegerSlider.Create(4, 10, Subdivision);
  SubdivisionSlider.OwnedByParent := false;
  ImageHeightScaleSlider := TGLMenuFloatSlider.Create(0.0, 2.0, 0.25);
  ImageHeightScaleSlider.OwnedByParent := false;

  ControlsNoise := TControlsNoise.Create(nil);
  ControlsImage := TControlsImage.Create(nil);

  if Elevation = nil then
  begin
    if Parameters.High = 1 then
      SetElevation(TElevationSRTM.CreateFromFile(Parameters[1])) else
    begin
      { some default elevation }
      SetElevation(TElevationNoise.Create);
      (Elevation as TElevationImage).ImageHeightScale := ImageHeightScaleSlider.Value;
    end;
  end;

end;

procedure Close(Glwin: TGLWindow);
begin
  FreeAndNil(ControlsNoise);
  FreeAndNil(ControlsImage);
  FreeAndNil(SubdivisionSlider);
  FreeAndNil(ImageHeightScaleSlider);
  GLMenuCloseGL;

  RenderElevationsCloseGL;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
var
  FileName: string;
  Expression: string;
  NewElevation: TElevation;
begin
  case Item.IntData of
    10: Wireframe := not Wireframe;
    50: begin
          FileName := '';
          if Glwin.FileDialog('Open SRTM (.hgt) terrain file', FileName, true,
            'All Files|*|' +
            '*SRTM (*.hgt) terrain|*.hgt') then
          begin
            try
              NewElevation := TElevationSRTM.CreateFromFile(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading file "%s" as terrain: %s',
                  [FileName, E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    60: begin
          Expression := '';
          if MessageInputQuery(Glwin, 'Pass KambiScript function expression, using X and Y variables, and calculating height of the terrain at given point.' + nl + nl +
            '(For example, try "sin(x*10) + sin(x*20)").', Expression, taLeft) then
          begin
            try
              NewElevation := TElevationKamScript.Create(Expression);
              (Elevation as TElevationImage).ImageHeightScale := ImageHeightScaleSlider.Value;
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when interpreting expression: %s',
                  [E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    70: begin
          SetElevation(TElevationNoise.Create);
          (Elevation as TElevationNoise).Octaves := ControlsNoise.OctavesSlider.Value;
          (Elevation as TElevationNoise).Amplitude := ControlsNoise.AmplitudeSlider.Value;
          (Elevation as TElevationNoise).Frequency := ControlsNoise.FrequencySlider.Value;
          (Elevation as TElevationNoise).Smoothness := ControlsNoise.SmoothnessSlider.Value;
          (Elevation as TElevationNoise).Heterogeneous := ControlsNoise.HeterogeneousSlider.Value;
          (Elevation as TElevationNoise).Seed := ControlsNoise.SeedSlider.Value;
          (Elevation as TElevationNoise).Interpolation := NoiseInterpolation;
          (Elevation as TElevationNoise).Blur := NoiseBlur;
          (Elevation as TElevationNoise).ImageHeightScale := ImageHeightScaleSlider.Value;
        end;
    80: begin
          SetElevation(TElevationImage.Create);
          (Elevation as TElevationImage).ImageHeightScale := ImageHeightScaleSlider.Value;
        end;
    100: Glwin.Close;
    110:
      begin
        NoiseBlur := not NoiseBlur;
        if Elevation is TElevationNoise then
          (Elevation as TElevationNoise).Blur := NoiseBlur;
      end;
    120:
      begin
        if Camera = ExamineCamera then
          Camera := WalkCamera else
          Camera := ExamineCamera;
        Glw.Controls.MakeSingle(TCamera, Camera, false);
      end;
    150:
      begin
        if Elevation is TElevationImage then
        begin
          FileName := TElevationImage(Elevation).ImageFileName;
          if Glwin.FileDialog('Open image file', FileName, true,
            LoadImage_FileFilters) then
          begin
            try
              TElevationImage(Elevation).LoadImage(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading image "%s": %s',
                  [FileName, E.Message]));
              end;
            end;
          end;
        end else
          MessageOk(Glwin, 'Not an image elevation');
      end;
    160:
      begin
        if Elevation is TElevationImage then
          TElevationImage(Elevation).ClearImage else
          MessageOk(Glwin, 'Not an image elevation');
      end;
    200..299:
      begin
        NoiseInterpolation := TNoiseInterpolation(Item.IntData - 200);
        if Elevation is TElevationNoise then
          (Elevation as TElevationNoise).Interpolation := NoiseInterpolation;
      end;

  end;
  Glwin.PostRedisplay;
end;

function CreateMainMenu: TMenu;
const
  NoiseInterpolationNames: array [TNoiseInterpolation] of string =
  ('None', 'Linear', 'Cosine');
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load terrain from SRTM (.hgt) file ...', 50, CtrlO));
    M.Append(TMenuItem.Create('Define terrain by KambiScript expression ...', 60));
    M.Append(TMenuItem.Create('Generate random terrain', 70));
    M.Append(TMenuItem.Create('Pure image terrain', 80));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Wireframe', 10, 'w', Wireframe, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('Walk camera', 120, 'c', Camera = WalkCamera, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 100));
    Result.Append(M);
  M := TMenu.Create('_Noise');
    M.AppendRadioGroup(NoiseInterpolationNames, 200, Ord(NoiseInterpolation), true);
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Blur', 110, NoiseBlur, true));
    Result.Append(M);
  M := TMenu.Create('_Image');
    M.Append(TMenuItem.Create('_Load image', 150));
    M.Append(TMenuItem.Create('_Clear image', 160));
    Result.Append(M);
end;

begin
  Glw := TGLUIWindow.Create(Application);

  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHighAtMost(1);

  try
    ExamineCamera := TExamineCamera.Create(Glw);
    ExamineCamera.Init(Box3D(
      Vector3Single(-1, -1, -1),
      Vector3Single( 1,  1,  1)));

    WalkCamera := TWalkCamera.Create(Glw);
    WalkCamera.Init(Vector3Single(
      0,
      0,
      0),
      Vector3Single(0, 1, 0) { dir },
      Vector3Single(0, 0, 1) { up },
      Vector3Single(0, 0, 1), 0.0, 0.0 { unused, we don't use Gravity here });

    Camera := ExamineCamera;
    Glw.Controls.Add(Camera);

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnDrawStyle := ds3D;
    Glw.InitAndRun(ProgramName, @Draw);
  finally FreeAndNil(Elevation) end;
end.
