{
  Copyright 2009-2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Display, walk over the terrain.

  Terrain data may be obtained from various sources:

  1. There's terrain data reader from a very simple SRTM-3 *.hgt file
     (pass $1 a filename of .hgt file).

     See http://www2.jpl.nasa.gov/srtm/, see (linked there)
     http://dds.cr.usgs.gov/srtm/ for sample data for whole Earth.
     In you speak Polish, nice overview is also on
     http://netgis.geo.uw.edu.pl/srtm/.
     Sample files for Poland are on http://netgis.geo.uw.edu.pl/srtm/Poland/,
     for Europe http://netgis.geo.uw.edu.pl/srtm/Europe/.

     You can run the program with command-line parameter to pass filename
     of such .hgt file to load on start.

  2. You can also define terrain as an explicit function using KambiScript
     expression syntax, [http://vrmlengine.sourceforge.net/kambi_script.php].
     Try e.g. function like
     - sin(x*10) + sin(y*10)
     - (sin(x*10) + sin(x*20) / 2 + sin(x*40) / 4)  *
       (sin(y*10) + sin(y*20) / 2 + sin(y*40) / 4)
       (sum sinusoides of various frequencies and amplitudes).

  3. You can also (and this was actually the primary reason for this program
     in the 1st place) generate random terrain.

  TODO:
  - switch view terrain:
    1. current view - "Examine the [0..1, 0..1] range of the terrain"
    2. new new - "Walk over the infinite terrain":
       Walk mode,
       optionally keeping avatar over the ground,
       optionally with fog (since terrain is infinite in this case),
       and using the algorithm that renders infinite terrain with LOD.
       Optionally with sky displayed, just for effect.
  Multitexture elevation, set texture mixture based on height,
  from GLSL shader.

  TODO: sliders:
  - controls for shifting noise (and calculated kam script) terrain.
    Hm, not so much needed, since increasing the freq allows you to see more,
    and in  walk mode you can explore it all.
}
program terrain;

uses SysUtils, Classes, Boxes3D,
  KambiUtils, GLWindow, GL, KambiGLUtils,
  Cameras, VectorMath, KambiFilesUtils, Elevations, GLWinMessages,
  KambiStringUtils, GLMenu, UIControls;

var
  Glw: TGLUIWindow;
  Camera: TCamera;
  ExamineCamera: TExamineCamera;
  WalkCamera: TWalkCamera;
  Elevation: TElevation;
  Wireframe: boolean;
  Subdivision: Cardinal = 6;
  NoiseInterpolation: TNoiseInterpolation = niCosine;
  NoiseBlur: boolean = false;

type
  TControlsNoise = class(TGLMenu)
  public
    OctavesSlider: TGLMenuFloatSlider;
    AmplitudeSlider: TGLMenuFloatSlider;
    FrequencySlider: TGLMenuFloatSlider;
    SmoothnessSlider: TGLMenuFloatSlider;
    SeedSlider: TGLMenuIntegerSlider;

    constructor Create(AOwner: TComponent); override;
    procedure CurrentItemAccessoryValueChanged; override;
  end;

  TControlsScript = class(TGLMenu)
  public
    constructor Create(AOwner: TComponent); override;
    procedure CurrentItemAccessoryValueChanged; override;
  end;

var
  { ui controls }
  ControlsNoise: TControlsNoise;
  ControlsScript: TControlsScript;
  SubdivisionSlider: TGLMenuIntegerSlider;

procedure ColorFromHeight(const H: Single);
begin
  { Colors strategy from http://www.ii.uni.wroc.pl/~anl/dyd/PGK/pracownia.html }
  if      (H < 0  )  then glColor3f(0,       0,         1) { blue }
  else if (H < 500)  then glColor3f(0,       H/500,     0) { green }
  else if (H < 1000) then glColor3f(H/500-1, 1,         0) { yellow }
  else if (H < 1500) then glColor3f(1,       H/500-2.0, 0) { red }
  else glColor3f(1, 1, 1);                                 { white }
end;

var
  { Helper array for calculating all elevation points *once* before passing
    them to OpenGL. This way we avoid calculating most heights twice
    (which would be needed for simple implementation rendering with quad strips),
    also we'll have all the data to calculate normal vectors. }
  Points: TDynVector3SingleArray;

{ Generic drawing of any TElevation, uses Height method }
procedure DrawElevation(Elevation: TElevation);
var
  CountSteps1: Cardinal;

  procedure Vertex(const I, J: Cardinal);
  var
    P, PX, PY: PVector3Single;
    HForColor: Single;
  begin
    P  := Points.Pointers[ I      * CountSteps1 + J];
    PX := Points.Pointers[(I + 1) * CountSteps1 + J];
    PY := Points.Pointers[ I      * CountSteps1 + J + 1];
    glNormalv((PX^ - P^) >< (PY^ - P^));

    HForColor := P^[2];
    { scale height down by Amplitude, to keep nice colors regardless of Amplitude }
    if Elevation is TElevationNoise then
      HForColor /= TElevationNoise(Elevation).Amplitude;
    { some hacks to hit interesting colors }
    HForColor := -1550 + 2.1 * (HForColor  * 1000 + 500); { TODO: simplify }
    ColorFromHeight(HForColor);

    glVertexv(P^);
  end;

var
  CountSteps: Cardinal;
  I, J: Cardinal;
  P: PVector3Single;
begin
  CountSteps := 1 shl Subdivision;
  CountSteps1 := CountSteps + 1;

  { We will render CountSteps^2 points, but we want to calculate
    (CountSteps + 1)^2 points : to be able to calculate normal vectors. }
  Points.Length := Max(Points.Length, Sqr(CountSteps1));
  P := PVector3Single(Points.ItemsArray);

  for I := 0 to CountSteps do
    for J := 0 to CountSteps do
    begin
      { calculate P^, which is Points.Items[I * CountSteps1 + J] }

      { set XY to cover (-1, -1) ... (1, 1) rectangle with our elevation }
      P^[0] := 2 * I / CountSteps - 1;
      P^[1] := 2 * J / CountSteps - 1;

      P^[2] := Elevation.Height(P^[0], P^[1]);

      Inc(P);
    end;

  for I := 1 to CountSteps - 1 do
  begin
    glBegin(GL_QUAD_STRIP);
      for J := 0 to CountSteps - 1 do
      begin
        Vertex(I - 1, J);
        Vertex(I    , J);
      end;
    glEnd();
  end;
end;

{ Specialized drawing for TElevationGrid, that displays only the
  precise grid points. }
procedure DrawGrid(Grid: TElevationGrid);
const
  { to scale coords to nicely fit in similar box like DrawElevation }
  ScaleSize = 100.0;
  ScaleHeight = 0.01;

  procedure Vertex(I, J: Cardinal);
  var
    HForColor: Single;
  begin
    HForColor := Grid.GridHeight(I, J);
    ColorFromHeight(HForColor);
    glVertexv(Vector3Single(
      ScaleSize * (I / Grid.GridSizeX),
      ScaleSize * (J / Grid.GridSizeY),
      HForColor * ScaleHeight));
  end;

const
  Step = 10;
var
  I, J: Cardinal;
begin
  I := Step;
  while I < Grid.GridSizeX do
  begin
    glBegin(GL_QUAD_STRIP);
      J := 0;
      while J < Grid.GridSizeY do
      begin
        Vertex(I - Step, J);
        Vertex(I       , J);
        Inc(J, Step);
      end;
    glEnd();
    Inc(I, Step);
  end;
end;

procedure SetElevation(Value: TElevation);
begin
  if Elevation <> Value then
  begin
    FreeAndNil(Elevation);
    Elevation := Value;

    if Elevation is TElevationNoise then
      Glw.Controls.MakeSingle(TGLMenu, ControlsNoise, true { before camera }) else
      Glw.Controls.Remove(ControlsNoise);

    if Elevation is TElevationKamScript then
      Glw.Controls.MakeSingle(TGLMenu, ControlsScript, true { before camera }) else
      Glw.Controls.Remove(ControlsScript);
  end;
end;

procedure Draw(Glwin: TGLWindow);

  procedure WalkCameraAboveGround;
  var
    P: TVector3Single;
  begin
    P := WalkCamera.Position;
    { shift by -0.5, like when rendering
      TODO: this shift is Ok only for non-grid drawing }
    P[2] := Elevation.Height(P[0], P[1]);
    WalkCamera.Position := P;
  end;

begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  if Camera = WalkCamera then
    WalkCameraAboveGround;

  glLoadMatrix(Camera.Matrix);

  if Wireframe then
  begin
    glPushAttrib(GL_POLYGON_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  end else
  begin
    glPushAttrib(GL_ENABLE_BIT);
    glEnable(GL_DEPTH_TEST);
  end;

    if Elevation is TElevationGrid then
    begin
      { DrawGrid cannot make normals for now, so no LIGHTING or other stuff }
      DrawGrid(TElevationGrid(Elevation));
    end else
    begin
      glPushAttrib(GL_ENABLE_BIT);
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
        glEnable(GL_COLOR_MATERIAL);
        glEnable(GL_NORMALIZE);
        DrawElevation(Elevation);
      glPopAttrib;
    end;

  glPopAttrib;
end;

procedure Resize(Glwin: TGLWindow);
begin
  glViewport(0, 0, Glwin.Width, Glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height, 0.1, 100);
end;

constructor TControlsNoise.Create(AOwner: TComponent);
begin
  inherited;

  OctavesSlider := TGLMenuFloatSlider.Create(0.0, 20.0, 4.0);
  AmplitudeSlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  FrequencySlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  SmoothnessSlider := TGLMenuFloatSlider.Create(1.0, 10.0, 2.0);
  SeedSlider := TGLMenuIntegerSlider.Create(0, 99, 0);

  Items.AddObject('Octaves', OctavesSlider);
  Items.AddObject('Amplitude (scales height)', AmplitudeSlider);
  Items.AddObject('Frequency (scales size)', FrequencySlider);
  Items.AddObject('Smoothness', SmoothnessSlider);
  Items.AddObject('Seed', SeedSlider);
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TControlsNoise.CurrentItemAccessoryValueChanged;
begin
  if not (Elevation is TElevationNoise) then Exit;
  case CurrentItem of
    0: (Elevation as TElevationNoise).Octaves := OctavesSlider.Value;
    1: (Elevation as TElevationNoise).Amplitude := AmplitudeSlider.Value;
    2: (Elevation as TElevationNoise).Frequency := FrequencySlider.Value;
    3: (Elevation as TElevationNoise).Smoothness := SmoothnessSlider.Value;
    4: (Elevation as TElevationNoise).Seed := SeedSlider.Value;
    5: Subdivision := SubdivisionSlider.Value;
  end;
  inherited;
end;

constructor TControlsScript.Create(AOwner: TComponent);
begin
  inherited;
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TControlsScript.CurrentItemAccessoryValueChanged;
begin
  if not (Elevation is TElevationKamScript) then Exit;
  case CurrentItem of
    0: Subdivision := SubdivisionSlider.Value;
  end;
  inherited;
end;

procedure Init(Glwin: TGLWindow);
begin
  { slider used by both Controls* }
  SubdivisionSlider := TGLMenuIntegerSlider.Create(4, 10, Subdivision);
  SubdivisionSlider.OwnedByParent := false;

  ControlsNoise := TControlsNoise.Create(nil);
  ControlsScript := TControlsScript.Create(nil);

  if Elevation = nil then
  begin
    if Parameters.High = 1 then
      SetElevation(TElevationSRTM.CreateFromFile(Parameters[1])) else
      { some default elevation }
      SetElevation(TElevationNoise.Create);
  //    SetElevation(TElevationKamScript.Create('sin(x*10) * sin(y*10)'));
  end;
end;

procedure Close(Glwin: TGLWindow);
begin
  FreeAndNil(ControlsNoise);
  FreeAndNil(ControlsScript);
  FreeAndNil(SubdivisionSlider);
  GLMenuCloseGL;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
var
  FileName: string;
  Expression: string;
  NewElevation: TElevation;
begin
  case Item.IntData of
    10: Wireframe := not Wireframe;
    50: begin
          FileName := '';
          if Glwin.FileDialog('Open SRTM (.hgt) terrain file', FileName, true,
            'All Files|*|' +
            '*SRTM (*.hgt) terrain|*.hgt') then
          begin
            try
              NewElevation := TElevationSRTM.CreateFromFile(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading file "%s" as terrain: %s',
                  [FileName, E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    60: begin
          Expression := '';
          if MessageInputQuery(Glwin, 'Pass KambiScript function expression, using X and Y variables, and calculating height of the terrain at given point.' + nl + nl +
            '(For example, try "sin(x*10) + sin(x*20)").', Expression, taLeft) then
          begin
            try
              NewElevation := TElevationKamScript.Create(Expression);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when interpreting expression: %s',
                  [E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    70: begin
          SetElevation(TElevationNoise.Create);
          (Elevation as TElevationNoise).Octaves := ControlsNoise.OctavesSlider.Value;
          (Elevation as TElevationNoise).Amplitude := ControlsNoise.AmplitudeSlider.Value;
          (Elevation as TElevationNoise).Frequency := ControlsNoise.FrequencySlider.Value;
          (Elevation as TElevationNoise).Smoothness := ControlsNoise.SmoothnessSlider.Value;
          (Elevation as TElevationNoise).Seed := ControlsNoise.SeedSlider.Value;
          (Elevation as TElevationNoise).Interpolation := NoiseInterpolation;
          (Elevation as TElevationNoise).Blur := NoiseBlur;
        end;
    100: Glwin.Close;
    110:
      begin
        NoiseBlur := not NoiseBlur;
        if Elevation is TElevationNoise then
          (Elevation as TElevationNoise).Blur := NoiseBlur;
      end;
    120:
      begin
        if Camera = ExamineCamera then
          Camera := WalkCamera else
          Camera := ExamineCamera;
        Glw.Controls.MakeSingle(TCamera, Camera, false);
      end;
    200..299:
      begin
        NoiseInterpolation := TNoiseInterpolation(Item.IntData - 200);
        if Elevation is TElevationNoise then
          (Elevation as TElevationNoise).Interpolation := NoiseInterpolation;
      end;

  end;
  Glwin.PostRedisplay;
end;

function CreateMainMenu: TMenu;
const
  NoiseInterpolationNames: array [TNoiseInterpolation] of string =
  ('None', 'Linear', 'Cosine');
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load terrain from SRTM (.hgt) file ...', 50, CtrlO));
    M.Append(TMenuItem.Create('Define terrain by KambiScript expression ...', 60));
    M.Append(TMenuItem.Create('Generate random terrain', 70));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Wireframe', 10, 'w', Wireframe, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('Walk camera', 120, 'c', Camera = WalkCamera, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 100));
    Result.Append(M);
  M := TMenu.Create('_Noise');
    M.AppendRadioGroup(NoiseInterpolationNames, 200, Ord(NoiseInterpolation), true);
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Blur', 110, NoiseBlur, true));
    Result.Append(M);
end;

begin
  Glw := TGLUIWindow.Create(Application);

  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHighAtMost(1);

  Points := TDynVector3SingleArray.Create;

  try
    ExamineCamera := TExamineCamera.Create(Glw);
    ExamineCamera.Init(Box3D(
      Vector3Single(-1, -1, -1),
      Vector3Single( 1,  1,  1)));

    WalkCamera := TWalkCamera.Create(Glw);
    WalkCamera.Init(Vector3Single(
      0,
      0,
      0),
      Vector3Single(0, 1, 0) { dir },
      Vector3Single(0, 0, 1) { up },
      Vector3Single(0, 0, 1), 0.0, 0.0 { unused, we don't use Gravity here });

    Camera := ExamineCamera;
    Glw.Controls.Add(Camera);

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnDrawStyle := ds3D;
    Glw.InitAndRun(ProgramName, @Draw);
  finally
    FreeAndNil(Elevation);
    FreeAndNil(Points);
  end;
end.
