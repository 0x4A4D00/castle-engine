{
  Copyright 2009-2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Display, walk over the terrain.

  Terrain data may be obtained from various sources:

  1. There's terrain data reader from a very simple SRTM-3 *.hgt file
     (pass $1 a filename of .hgt file).

     See http://www2.jpl.nasa.gov/srtm/, see (linked there)
     http://dds.cr.usgs.gov/srtm/ for sample data for whole Earth.
     In you speak Polish, nice overview is also on
     http://netgis.geo.uw.edu.pl/srtm/.
     Sample files for Poland are on http://netgis.geo.uw.edu.pl/srtm/Poland/,
     for Europe http://netgis.geo.uw.edu.pl/srtm/Europe/.

     You can run the program with command-line parameter to pass filename
     of such .hgt file to load on start.

  2. You can also define terrain as an explicit function using KambiScript
     expression syntax, [http://vrmlengine.sourceforge.net/kambi_script.php].
     Try e.g. function like
     - sin(x) + sin(y)
     - (sin(x) + sin(x*2) / 2 + sin(x*4) / 4)  *
       (sin(y) + sin(y*2) / 2 + sin(y*4) / 4)
       (sum sinusoides of various frequencies and amplitudes).

  3. You can also (and this was actually the primary reason for this program
     in the 1st place) generate random terrain.

  Terrain is rendered with GLSL shader, with nice colors, multitextures etc.
  To support large data, we render with ultra-simplified geo clipmaps
  (look in wireframe mode to see what it does). View is centered around
  current Walk position (move in Walk mode to also change the portion
  visible in Examine mode).

  TODO:
  - DrawGrid is temp broken now (not visible,
    and probably walk camera doesn't follow it correctly).
    For now, ignore it (it messes too much otherwise clean TElevation*
    using code).
  - add sky, just for the effect?
}
program terrain;

uses SysUtils, Classes, Boxes3D,
  KambiUtils, GLWindow, GL, GLExt, KambiGLUtils,
  Cameras, VectorMath, KambiFilesUtils, Elevations, GLWinMessages,
  KambiStringUtils, GLMenu, UIControls, Images, RenderElevations,
  GLShaders, GLImages;

var
  { global stuff }
  Glw: TGLUIWindow;
  Camera: TCamera;
  ExamineCamera: TExamineCamera;
  WalkCamera: TWalkCamera;
  Elevation: TElevation;

  { gl helpers }
  GLSLProgram: TGLSLProgram;
  GLTexSand, GLTexBread, GLTexRock: TGLuint;

  { settings }
  Wireframe: boolean = false;
  NoiseInterpolation: TNoiseInterpolation = niCosine;
  NoiseBlur: boolean = false;
  Subdivision: Cardinal = 6;
  Shader: boolean = true;
  Lighting: boolean = true;
  KeepCameraAboveGround: boolean = true;
  BaseSize: Single = 1.0;
  LayersCount: Cardinal = 3;
  ControlsVisible: boolean = true;
  Fog: boolean = false;

type
  TControlsNoise = class(TGLMenu)
  public
    OctavesSlider: TGLMenuFloatSlider;
    AmplitudeSlider: TGLMenuFloatSlider;
    FrequencySlider: TGLMenuFloatSlider;
    SmoothnessSlider: TGLMenuFloatSlider;
    HeterogeneousSlider: TGLMenuFloatSlider;
    SeedSlider: TGLMenuIntegerSlider;

    constructor Create(AOwner: TComponent); override;
    procedure CurrentItemAccessoryValueChanged; override;
  end;

  { For any TElevationImage except
    TElevationNoise (that has it's own TControlsNoise)
    and TElevationGrid (that has quite different rendering rules;
    for now, TElevationGrid is not TElevationImage anyway). }
  TControlsImage = class(TGLMenu)
  public
    constructor Create(AOwner: TComponent); override;
    procedure CurrentItemAccessoryValueChanged; override;
  end;

var
  { ui controls }
  ControlsNoise: TControlsNoise;
  ControlsImage: TControlsImage;
  SubdivisionSlider: TGLMenuIntegerSlider;
  LayersCountSlider: TGLMenuIntegerSlider;
  ImageHeightScaleSlider: TGLMenuFloatSlider;

{ Current TGLMenu, or none, based on Elevation class and ControlsVisible. }
function CurrentControls: TGLMenu;
begin
  if not ControlsVisible then Exit(nil);

  if Elevation is TElevationNoise then
    Result := ControlsNoise else
  if (Elevation is TElevationImage) and not (Elevation is TElevationGrid) then
    Result := ControlsImage else
    Result := nil;
end;

procedure SetElevation(Value: TElevation);
begin
  if Elevation <> Value then
  begin
    FreeAndNil(Elevation);
    Elevation := Value;

    Glw.Controls.MakeSingle(TGLMenu, CurrentControls, true { before camera });

    if Elevation is TElevationImage then
      TElevationImage(Elevation).ImageHeightScale := ImageHeightScaleSlider.Value;

    if Elevation is TElevationNoise then
    begin
      TElevationNoise(Elevation).Octaves := ControlsNoise.OctavesSlider.Value;
      TElevationNoise(Elevation).Smoothness := ControlsNoise.SmoothnessSlider.Value;
      TElevationNoise(Elevation).Heterogeneous := ControlsNoise.HeterogeneousSlider.Value;
      TElevationNoise(Elevation).Amplitude := ControlsNoise.AmplitudeSlider.Value;
      TElevationNoise(Elevation).Frequency := ControlsNoise.FrequencySlider.Value;
      TElevationNoise(Elevation).Seed := ControlsNoise.SeedSlider.Value;
      TElevationNoise(Elevation).Interpolation := NoiseInterpolation;
      TElevationNoise(Elevation).Blur := NoiseBlur;
    end;
  end;
end;

procedure Draw(Glwin: TGLWindow);

  procedure WalkCameraAboveGround;
  var
    P: TVector3Single;
  begin
    P := WalkCamera.Position;
    P[2] := Elevation.Height(P[0], P[1]) + 0.1;
    WalkCamera.Position := P;
  end;

var
  VisibilityEnd: Single;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  if (Camera = WalkCamera) and KeepCameraAboveGround then
    WalkCameraAboveGround;

  glLoadMatrix(Camera.Matrix);

  if Wireframe then
  begin
    glPushAttrib(GL_POLYGON_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  end else
  begin
    glPushAttrib(GL_ENABLE_BIT);
    glEnable(GL_DEPTH_TEST);
  end;

    if Elevation is TElevationGrid then
    begin
      { DrawGrid cannot make normals for now, so no LIGHTING or other stuff }
      DrawGrid(TElevationGrid(Elevation));
    end else
    begin
      glPushAttrib(GL_ENABLE_BIT);
        if Lighting then
        begin
          glEnable(GL_LIGHTING);
          glEnable(GL_LIGHT0);
          glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
          glEnable(GL_COLOR_MATERIAL);
          glEnable(GL_NORMALIZE);
        end;

        if Shader then
        begin
          GLSLProgram.Enable;

          glActiveTextureARB(GL_TEXTURE0);
          glBindTexture(GL_TEXTURE_2D, GLTexSand);
          GLSLProgram.SetUniform('tex_sand', 0);

          glActiveTextureARB(GL_TEXTURE1);
          glBindTexture(GL_TEXTURE_2D, GLTexBread);
          GLSLProgram.SetUniform('tex_bread', 1);

          glActiveTextureARB(GL_TEXTURE2);
          glBindTexture(GL_TEXTURE_2D, GLTexRock);
          GLSLProgram.SetUniform('tex_rock', 2);

          GLSLProgram.SetUniform('z0', 0.8);
          GLSLProgram.SetUniform('z1', 1.0);
          GLSLProgram.SetUniform('z2', 1.2);
          GLSLProgram.SetUniform('z3', 1.5);
          GLSLProgram.SetUniform('color_scale', 0.2);
          GLSLProgram.SetUniform('tex_scale', 0.8);
          if Fog then
          begin
            { This is the exact visibility end.
              In practice, we may want to make it a litlle smaller
              (to hide RoundGridCell hack in renderelevations.pas),
              or ignore problems and make it a little larger
              (otherwise, we needlessly render corners of terrain squares). }
            VisibilityEnd := BaseSize * (1 shl (LayersCount-1));
            GLSLProgram.SetUniform('fog_start', VisibilityEnd * 0.7);
            GLSLProgram.SetUniform('fog_end', VisibilityEnd);
          end;
        end;

        DrawElevation(Elevation, Subdivision,
          WalkCamera.Position[0], WalkCamera.Position[1], BaseSize, LayersCount);

        if Shader then
          GLSLProgram.Disable;
      glPopAttrib;
    end;

  glPopAttrib;
end;

procedure Resize(Glwin: TGLWindow);
var
  ProjectionNear: Single;
begin
  glViewport(0, 0, Glwin.Width, Glwin.Height);
  if Camera = WalkCamera then
    ProjectionNear := 0.01 else
    ProjectionNear := 0.1;
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height, ProjectionNear, 100);
end;

constructor TControlsNoise.Create(AOwner: TComponent);
begin
  inherited;

  OctavesSlider := TGLMenuFloatSlider.Create(0.0, 20.0, 4.0);
  SmoothnessSlider := TGLMenuFloatSlider.Create(1.0, 10.0, 2.0);
  HeterogeneousSlider := TGLMenuFloatSlider.Create(0.0, 2.0, 0.0);
  AmplitudeSlider := TGLMenuFloatSlider.Create(0.1, 10.0, 1.0);
  FrequencySlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  SeedSlider := TGLMenuIntegerSlider.Create(0, 99, 0);

  Items.AddObject('Octaves', OctavesSlider);
  Items.AddObject('Smoothness', SmoothnessSlider);
  Items.AddObject('Heterogeneous', HeterogeneousSlider);
  Items.AddObject('Amplitude (scales height)', AmplitudeSlider);
  Items.AddObject('Frequency (scales size)', FrequencySlider);
  Items.AddObject('Seed', SeedSlider);
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  Items.AddObject('Layers Count (render farther)', LayersCountSlider);
  Items.AddObject('Image height scale', ImageHeightScaleSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TControlsNoise.CurrentItemAccessoryValueChanged;
begin
  if not (Elevation is TElevationNoise) then Exit;
  case CurrentItem of
    0: (Elevation as TElevationNoise).Octaves := OctavesSlider.Value;
    1: (Elevation as TElevationNoise).Smoothness := SmoothnessSlider.Value;
    2: (Elevation as TElevationNoise).Heterogeneous := HeterogeneousSlider.Value;
    3: (Elevation as TElevationNoise).Amplitude := AmplitudeSlider.Value;
    4: (Elevation as TElevationNoise).Frequency := FrequencySlider.Value;
    5: (Elevation as TElevationNoise).Seed := SeedSlider.Value;
    6: Subdivision := SubdivisionSlider.Value;
    7: LayersCount := LayersCountSlider.Value;
    8: (Elevation as TElevationNoise).ImageHeightScale := ImageHeightScaleSlider.Value;
  end;
  inherited;
end;

constructor TControlsImage.Create(AOwner: TComponent);
begin
  inherited;
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  Items.AddObject('Layers Count (render farther)', LayersCountSlider);
  Items.AddObject('Image height scale', ImageHeightScaleSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TControlsImage.CurrentItemAccessoryValueChanged;
begin
  case CurrentItem of
    0: Subdivision := SubdivisionSlider.Value;
    1: LayersCount := LayersCountSlider.Value;
    2: (Elevation as TElevationImage).ImageHeightScale := ImageHeightScaleSlider.Value;
  end;
  inherited;
end;

{ Load GLSL program from files, add #define if Fog, relink. }
procedure GLSLProgramRegenerate;
var
  Prefix: string;
begin
  GLSLProgram.DetachAllShaders;
  if Fog then
    Prefix := '#define FOG' + NL else
    Prefix := '';
  GLSLProgram.AttachVertexShader(Prefix + FileToString('elevation.vs'));
  GLSLProgram.AttachFragmentShader(Prefix + FileToString('elevation.fs'));
  { For this test program, we eventually allow shader to run in software.
    We display debug info, so user should know what's going on. }
  GLSLProgram.Link(false);
  { Only warn on non-used uniforms. This is more comfortable for shader
    development, you can easily comment shader parts. }
  GLSLProgram.UniformNotFoundAction := uaWarning;
  Writeln('----------------------------- Shader debug info:');
  Writeln(GLSLProgram.DebugInfo);
end;

procedure Init(Glwin: TGLWindow);

  function LoadTexture(const FileName: string): TGLuint;
  begin
    Result := LoadGLTexture('textures' + PathDelim + FileName,
      GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, Texture2DRepeat);
  end;

begin
  RenderElevationsInitGL;

  { sliders used by both Controls* }
  SubdivisionSlider := TGLMenuIntegerSlider.Create(1, 10, Subdivision);
  SubdivisionSlider.OwnedByParent := false;
  LayersCountSlider := TGLMenuIntegerSlider.Create(1, 10, LayersCount);
  LayersCountSlider.OwnedByParent := false;
  ImageHeightScaleSlider := TGLMenuFloatSlider.Create(0.0, 2.0, 0.25);
  ImageHeightScaleSlider.OwnedByParent := false;

  ControlsNoise := TControlsNoise.Create(nil);
  ControlsImage := TControlsImage.Create(nil);

  if Elevation = nil then
  begin
    if Parameters.High = 1 then
      SetElevation(TElevationSRTM.CreateFromFile(Parameters[1])) else
      { some default elevation }
      SetElevation(TElevationNoise.Create);
  end;

  { load textures }
  GLTexSand := LoadTexture('sand.png');
  GLTexBread := LoadTexture('bread.png');
  GLTexRock := LoadTexture('rock_d01.png');

  { initialize GLSL program }
  GLSLProgram := TGLSLProgram.Create;
  GLSLProgramRegenerate;
end;

procedure Close(Glwin: TGLWindow);
begin
  FreeAndNil(GLSLProgram);

  FreeAndNil(ControlsNoise);
  FreeAndNil(ControlsImage);
  FreeAndNil(SubdivisionSlider);
  FreeAndNil(LayersCountSlider);
  FreeAndNil(ImageHeightScaleSlider);
  GLMenuCloseGL;

  RenderElevationsCloseGL;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
var
  FileName: string;
  Expression: string;
  NewElevation: TElevation;
begin
  case Item.IntData of
    10: Wireframe := not Wireframe;
    50: begin
          FileName := '';
          if Glwin.FileDialog('Open SRTM (.hgt) terrain file', FileName, true,
            'All Files|*|' +
            '*SRTM (*.hgt) terrain|*.hgt') then
          begin
            try
              NewElevation := TElevationSRTM.CreateFromFile(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading file "%s" as terrain: %s',
                  [FileName, E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    60: begin
          Expression := '';
          if MessageInputQuery(Glwin, 'Pass KambiScript function expression, using X and Y variables, and calculating height of the terrain at given point.' + nl + nl +
            '(For example, try "sin(x*2) * sin(y*2)").', Expression, taLeft) then
          begin
            try
              NewElevation := TElevationKamScript.Create(Expression);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when interpreting expression: %s',
                  [E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    70: SetElevation(TElevationNoise.Create);
    80: SetElevation(TElevationImage.Create);
    100: Glwin.Close;
    110:
      begin
        NoiseBlur := not NoiseBlur;
        if Elevation is TElevationNoise then
          (Elevation as TElevationNoise).Blur := NoiseBlur;
      end;
    120:
      begin
        if Camera = ExamineCamera then
          Camera := WalkCamera else
          Camera := ExamineCamera;
        Glw.Controls.MakeSingle(TCamera, Camera, false);
        Glw.EventResize; { to update ProjectionNear }
      end;
    125: KeepCameraAboveGround := not KeepCameraAboveGround;
    130: Lighting := not Lighting;
    140: Shader := not Shader;
    142:
      begin
        Fog := not Fog;
        GLSLProgramRegenerate;
      end;
    145:
      begin
        ControlsVisible := not ControlsVisible;
        Glw.Controls.MakeSingle(TGLMenu, CurrentControls, true { before camera });
      end;
    150:
      begin
        if Elevation is TElevationImage then
        begin
          FileName := TElevationImage(Elevation).ImageFileName;
          if Glwin.FileDialog('Open image file', FileName, true,
            LoadImage_FileFilters) then
          begin
            try
              TElevationImage(Elevation).LoadImage(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading image "%s": %s',
                  [FileName, E.Message]));
              end;
            end;
          end;
        end else
          MessageOk(Glwin, 'Not an image elevation');
      end;
    160:
      begin
        if Elevation is TElevationImage then
          TElevationImage(Elevation).ClearImage else
          MessageOk(Glwin, 'Not an image elevation');
      end;
    200..299:
      begin
        NoiseInterpolation := TNoiseInterpolation(Item.IntData - 200);
        if Elevation is TElevationNoise then
          (Elevation as TElevationNoise).Interpolation := NoiseInterpolation;
      end;

  end;
  Glwin.PostRedisplay;
end;

function CreateMainMenu: TMenu;
const
  NoiseInterpolationNames: array [TNoiseInterpolation] of string =
  ('None', 'Linear', 'Cosine', 'Spline');
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Generate random terrain', 70));
    M.Append(TMenuItem.Create('Define terrain by KambiScript expression ...', 60));
    M.Append(TMenuItem.Create('Pure image terrain', 80));
    M.Append(TMenuItem.Create('Load terrain from SRTM (.hgt) file ...', 50, CtrlO));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('Walk', 120, 'c', Camera = WalkCamera, true));
    M.Append(TMenuItemChecked.Create('Keep Above the Ground (in Walk)', 125, KeepCameraAboveGround, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 100));
    Result.Append(M);
  M := TMenu.Create('_View');
    M.Append(TMenuItemChecked.Create('_Wireframe', 10, 'w', Wireframe, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('Shader', 140, 's', Shader, true));
    M.Append(TMenuItemChecked.Create('Fog (when Shader)', 142, 'f', Fog, true));
    M.Append(TMenuItemChecked.Create('Lighting (when no Shader)', 130, 'l', Lighting, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('Sliders Visible', 145, K_F1, ControlsVisible, true));
    Result.Append(M);
  M := TMenu.Create('_Noise');
    M.AppendRadioGroup(NoiseInterpolationNames, 200, Ord(NoiseInterpolation), true);
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Blur', 110, NoiseBlur, true));
    Result.Append(M);
  M := TMenu.Create('_Image');
    M.Append(TMenuItem.Create('_Load image', 150));
    M.Append(TMenuItem.Create('_Clear image', 160));
    Result.Append(M);
end;

begin
  Glw := TGLUIWindow.Create(Application);

  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHighAtMost(1);

  try
    ExamineCamera := TExamineCamera.Create(Glw);
    ExamineCamera.Init(Box3D(
      Vector3Single(-1, -1, -1),
      Vector3Single( 1,  1,  1)));

    WalkCamera := TWalkCamera.Create(Glw);
    WalkCamera.Init(Vector3Single(
      0,
      0,
      0),
      Vector3Single(0, 1, 0) { dir },
      Vector3Single(0, 0, 1) { up },
      Vector3Single(0, 0, 1), 0.0, 0.0 { unused, we don't use Gravity here });
    WalkCamera.MoveHorizontalSpeed := 0.01;
    WalkCamera.MoveVerticalSpeed := 0.01;

    Camera := ExamineCamera;
    Glw.Controls.Add(Camera);

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnDrawStyle := ds3D;
    { SwapFullScreen funtionality (Close+Init) is for now broken here
      (we should readd appropriate Controls* and camera to Glw.Controls,
      sliders should be recreated but with default values coming from
      last values, elevation should be updated with sliders values;
      This isn't difficult, but would complicate source code for little gain.) }
    Glw.SwapFullScreen_Key := K_None;
    Glw.InitAndRun(ProgramName, @Draw);
  finally FreeAndNil(Elevation) end;
end.
