{
  Copyright 2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Demo of using custom viewports (TKamViewport) to view the same 3D world
  (scene manager in TKamSceneManager). }

uses GL, GLWindow, VRMLNodes, VRMLScene, VRMLGLScene, KambiSceneManager,
  UIControls, Cameras, Quaternions, VectorMath, Math, GLControls,
  KambiUtils, KambiGLUtils;

var
  Window: TGLUIWindow;
  SceneManager: TKamSceneManager;
  Scene: TVRMLGLScene;
  Viewports: array [0..3] of TKamViewport;
  OpenButton, QuitButton: TKamGLButton;

{ TBackground ---------------------------------------------------------------- }

type
  TBackground = class(TUIControl)
  public
    function DrawStyle: TUIControlDrawStyle; override;
    procedure Draw; override;
  end;

function TBackground.DrawStyle: TUIControlDrawStyle;
begin
  { 3D, because we want to be drawn before other 3D objects }
  Result := ds3D;
end;

procedure TBackground.Draw;
begin
  glPushAttrib(GL_COLOR_BUFFER_BIT);
    glClearColor(0.5, 0.5, 1, 1); // saved by GL_COLOR_BUFFER_BIT
    glClear(GL_COLOR_BUFFER_BIT);
  glPopAttrib;
end;

{ TMyViewport ---------------------------------------------------------------- }

type
  { Derive our own TKamViewport descendants, just to demo that we can. }
  TMyViewport = class(TKamViewport)
    procedure Draw; override;
    procedure SetFocused(const Value: boolean); override;
  end;

procedure ViewportDraw2D(ViewportPtr: Pointer);
var
  Viewport: TMyViewport absolute ViewportPtr;
begin
  glLoadIdentity;
  if Viewport.Focused then
  begin
    glColor3f(1, 1, 1);
    glLineWidth(3.0); { saved by GL_LINE_BIT }
    DrawGLRectBorder(0, 0, 1, 1);
  end;
end;

procedure TMyViewport.Draw;
begin
  inherited;

  glPushAttrib(GL_ENABLE_BIT or GL_LINE_BIT);
    glDisable(GL_LIGHTING);
    glDisable(GL_DEPTH_TEST);
    glProjectionPushPopOrtho2D(@ViewportDraw2D, Self, 0, 1, 0, 1);
  glPopAttrib;
end;

procedure TMyViewport.SetFocused(const Value: boolean);
begin
  if Value <> Focused then
  begin
    { We base our Draw on Focused value. }
    VisibleChange;
  end;

  inherited;
end;

{ ---------------------------------------------------------------------------- }

procedure Resize(Glwin: TGLWindow);
const
  Margin = 5;
var
  W, H, ButtonHeight: Integer;
begin
  ButtonHeight := OpenButton.Height + 2*Margin;
  W := Glwin.Width div 2;
  H := (Glwin.Height - ButtonHeight) div 2;

  Viewports[0].Left   :=       Margin;
  Viewports[0].Bottom :=       Margin;
  Viewports[0].Width  := W - 2*Margin;
  Viewports[0].Height := H - 2*Margin;

  Viewports[1].Left   := W +   Margin;
  Viewports[1].Bottom :=       Margin;
  Viewports[1].Width  := W - 2*Margin;
  Viewports[1].Height := H - 2*Margin;

  Viewports[2].Left   :=       Margin;
  Viewports[2].Bottom := H +   Margin;
  Viewports[2].Width  := W - 2*Margin;
  Viewports[2].Height := H - 2*Margin;

  Viewports[3].Left   := W +   Margin;
  Viewports[3].Bottom := H +   Margin;
  Viewports[3].Width  := W - 2*Margin;
  Viewports[3].Height := H - 2*Margin;

  OpenButton.Left := Margin;
  OpenButton.Bottom := Glwin.Height - ButtonHeight + Margin;

  QuitButton.Left := Glwin.Width - Margin - QuitButton.Width;
  QuitButton.Bottom := OpenButton.Bottom;
end;

procedure CameraReinitialize;
var
  I: Integer;
begin
  for I := 0 to High(Viewports) do
  begin
    { set different camera views for all viewports, to make it interesting }
    Viewports[I].Camera.Free;
    Viewports[I].Camera := SceneManager.CreateDefaultCamera(SceneManager);
    if (I < 3) and (Viewports[I].Camera is TExamineCamera) then
      TExamineCamera(Viewports[I].Camera).Rotations :=
        QuatFromAxisAngle(UnitVector3Single[I], Pi/2);
  end;

  { scene manager needs assigned camera to make a headlight }
  { TODO: this resets Camera events and Container.
    Right now, one camera cannot be simultaneously on scnee manager
    and viewports. So assign here new camera... }
  SceneManager.Camera.Free;
  SceneManager.Camera := SceneManager.CreateDefaultCamera(SceneManager);
end;

var
  FileName: string = 'models/teapot.x3dv';
  //  '../../../kambi_vrml_test_suite/x3d/kambi_extensions/shadows_dynamic.x3dv'

type
  TDummy = class
    procedure OpenButtonClick(Sender: TObject);
    procedure QuitButtonClick(Sender: TObject);
  end;

procedure TDummy.OpenButtonClick(Sender: TObject);
begin
  if Window.FileDialog('Open 3D file', FileName, true) then
  begin
    Scene.Load(FileName);
    CameraReinitialize;
  end;
end;

procedure TDummy.QuitButtonClick(Sender: TObject);
begin
  Application.Quit;
end;

var
  I: Integer;
begin
  if Parameters.High = 1 then
    FileName := Parameters[1];

  Scene := TVRMLGLScene.Create(Application);
  Scene.Load(FileName);
  Scene.Spatial := [ssRendering, ssDynamicCollisions];
  Scene.ProcessEvents := true;

  Window := TGLUIWindow.Create(Application);

  SceneManager := TKamSceneManager.Create(Application);
  SceneManager.Items.Add(Scene);
  SceneManager.MainScene := Scene;
  SceneManager.DefaultViewport := false;
  Window.Controls.Add(SceneManager);

  for I := 0 to High(Viewports) do
  begin
    Viewports[I] := TMyViewport.Create(Application);
    Viewports[I].SceneManager := SceneManager;
    Viewports[I].FullSize := false;
    { test shadows: }
    Viewports[I].ShadowVolumesPossible := true;
    Viewports[I].ShadowVolumes := true;
    { The initial Resize event will position viewports correctly }
    Window.Controls.Add(Viewports[I]);
  end;
  Assert(SceneManager.Viewports.Count = High(Viewports) + 1);

  CameraReinitialize;

  OpenButton := TKamGLButton.Create(Application);
  OpenButton.Caption := 'Open 3D file';
  OpenButton.OnClick := @TDummy(nil).OpenButtonClick;
  Window.Controls.Add(OpenButton);

  QuitButton := TKamGLButton.Create(Application);
  QuitButton.Caption := 'Quit';
  QuitButton.OnClick := @TDummy(nil).QuitButtonClick;
  Window.Controls.Add(QuitButton);

  { add a background, since our viewpoints (deliberately, for demo)
    do not cover whole window. }
  Window.Controls.Add(TBackground.Create(Application));

  Window.OnResize := @Resize;
  Window.InitAndRun;
end.
