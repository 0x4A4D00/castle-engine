{
  Copyright 2003-2012 Michalis Kamburelis.

  This file is part of "lets_take_a_walk".

  "lets_take_a_walk" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "lets_take_a_walk" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "lets_take_a_walk"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Walk around the 3D world with 3D sound attached to objects.

  Historically (2003-11):
  This demo was a first test of using OpenAL with our game engine,
  attaching sounds to various moving 3D objects. It was modified
  many times since then, to simplify and take advantage of T3D
  and scene manager and many other features.
  It was also the first (and the last, for now) program where I used lightmaps
  generated by our own genLightMap --- the point was to bake shadows
  on the ground texture base_shadowed.png.

  If you'd like to improve it, here are some ideas (TODOs):
  - add collisions between rat and tnts and BaseScene
  - more interesting rat movement track. Maybe use AI from castle.
  - more elaborate level (initially, some house and more lamps were planned)
  - better rat sound
}

program lets_take_a_walk;

uses GL, CastleWindow, CastleScene, X3DNodes, SysUtils,
  CastleUtils, CastleGLUtils, Boxes3D, VectorMath,
  ProgressUnit, ProgressConsole, ALUtils, CastleStringUtils,
  CastleParameters, Images, Thunder,
  CastleMessages, CastleFilesUtils, GLImages, CastleSceneCore,
  CastleSceneManager, Base3D, ALSoundEngine, ALSoundAllocator, Frustum,
  RenderingCameraUnit, Classes, CastleControls, CastleLevel;

{ global variables ----------------------------------------------------------- }

var
  Window: TCastleWindowCustom;

  BaseScene: TCastleScene;
  TntScene: TCastleScene;
  Rat: T3DTransform;
  RatAngle: Single;

  RatSoundBuffer, RatSqueakBuffer, NightSoundBuffer, KaboomBuffer: TALBuffer;
  RatSound: TALSound;

  MuteImage: TCastleImageControl;

{ scene manager -------------------------------------------------------------- }

type
  TMySceneManager = class(TCastleSceneManager)
    procedure InitializeLights(const Lights: TLightInstancesList); override;
  end;

var
  SceneManager: TMySceneManager;

procedure TMySceneManager.InitializeLights(const Lights: TLightInstancesList);
begin
  inherited;
  ThunderAddLight(Lights);
end;

{ TNT ------------------------------------------------------------------------ }

type
  TTnt = class(T3DTransform)
  private
    ToRemove: boolean;
  protected
    function GetChild: T3D; override;
  public
    function PointingDeviceActivate(const Active: boolean;
      const Distance: Single): boolean; override;
    procedure Idle(const CompSpeed: Single; var RemoveMe: TRemoveType); override;
  end;

const
  { Max number of TNT items. Be careful with increasing this,
    too large values may cause FPS to suffer. }
  MaxTntsCount = 40;
var
  TntsCount: Integer = 0;

function TTnt.GetChild: T3D;
begin
  Result := TntScene;
end;

function TTnt.PointingDeviceActivate(const Active: boolean;
  const Distance: Single): boolean;
begin
  Result := Active and not ToRemove;
  if not Result then Exit;

  SoundEngine.PlaySound(KaboomBuffer, true, false, 0, 1, 0, 1, Translation);
  if PointsDistanceSqr(Translation, Rat.Translation) < 1.0 then
    SoundEngine.PlaySound(RatSqueakBuffer, true, false, 1, 1.0,
      0, 1, Rat.Translation);

  ToRemove := true;
  Dec(TntsCount);
end;

procedure TTnt.Idle(const CompSpeed: Single; var RemoveMe: TRemoveType);
var
  T: TVector3Single;
begin
  inherited;

  { make gravity }
  T := Translation;
  if T[2] > 0 then
  begin
    T[2] -= 5 * CompSpeed;
    MaxTo1st(T[2], 0);
    Translation := T;
  end;

  if ToRemove then
    RemoveMe := rtRemoveAndFree;
end;

procedure NewTnt(Z: Single);
var
  TntSize: Single;
  Tnt: TTnt;
begin
  TntSize := TntScene.BoundingBox.MaxSize;
  Tnt := TTnt.Create(SceneManager);
  Tnt.Translation := Vector3Single(
    RandomFloatRange(BaseScene.BoundingBox.Data[0, 0], BaseScene.BoundingBox.Data[1, 0]-TntSize),
    RandomFloatRange(BaseScene.BoundingBox.Data[0, 1], BaseScene.BoundingBox.Data[1, 1]-TntSize),
    Z);
  SceneManager.Items.Add(Tnt);
  Inc(TntsCount);
end;

{ some functions ------------------------------------------------------------- }

{ update Rat.Translation based on RatAngle }
procedure UpdateRatPosition;
const
  RatCircleMiddle: TVector3Single = (0, 0, 0);
  RatCircleRadius = 3;
var
  T: TVector3Single;
begin
  T := RatCircleMiddle;
  T[0] += Cos(RatAngle) * RatCircleRadius;
  T[1] += Sin(RatAngle) * RatCircleRadius;
  Rat.Translation := T;
end;

{ Update stuff based on whether camera position is inside mute area. }
procedure UpdateMute;

  function PointInsideCylinder(const P: TVector3Single;
    const MiddleX, MiddleY, Radius, MinZ, MaxZ: Single): boolean;
  begin
    Result :=
      (Sqr(P[0]-MiddleX) + Sqr(P[1]-MiddleY) <= Sqr(Radius)) and
      (MinZ <= P[2]) and (P[2] <= MaxZ);
  end;

var
  InMuteArea: boolean;
begin
  InMuteArea := PointInsideCylinder(SceneManager.Camera.GetPosition, 2, 0, 0.38, 0, 1.045640);

  MuteImage.Exists := InMuteArea;

  if InMuteArea then
    SoundEngine.Volume := 0 else
    SoundEngine.Volume := 1;
end;

function LoadScene(const Name: string; AOwner: TComponent): TCastleScene;
begin
  Result := TCastleScene.Create(AOwner);
  Result.Load(ProgramDataPath + 'data' + PathDelim + '3d' + PathDelim + Name);
end;

type
  TDummy = class
    class procedure CameraChanged(Camera: TObject);
  end;

class procedure TDummy.CameraChanged(Camera: TObject);
begin
  UpdateMute;
end;

{ help message ------------------------------------------------------------ }

const
  Version = '1.2.4';
  DisplayProgramName = 'lets_take_a_walk';

procedure ShowHelpMessage;
const
  HelpMessage = {$I help_message.inc};
begin
  MessageOK(Window, HelpMessage + nl +
    SCastleEngineProgramHelpSuffix(DisplayProgramName, Version, false), taLeft);
end;

{ window callbacks ----------------------------------------------------------- }

procedure Resize(Window: TCastleWindowBase);
const
  Margin = 20;
begin
  MuteImage.Left := Window.Width - MuteImage.Width - Margin;
  MuteImage.Bottom := Window.Height - MuteImage.Height - Margin;
end;

procedure Close(Window: TCastleWindowBase);
begin
  { in case no TNT actually exists in scene at closing time (you managed
    to explode them all), be sure to clean the OpenGL resources inside TntScene. }
  TntScene.GLContextClose;
end;

procedure Idle(Window: TCastleWindowBase);
begin
  { update rat }
  RatAngle += 0.5 * Window.Fps.IdleSpeed;
  UpdateRatPosition;
  if RatSound <> nil then
    RatSound.Position := Rat.Translation;
end;

procedure Timer(Window: TCastleWindowBase);
begin
  while TntsCount < MaxTntsCount do NewTnt(3.0);
  ThunderIdleSec;
end;

procedure KeyDown(Window: TCastleWindowBase; Key: TKey; c: char);
begin
  case key of
    { K_T: ThunderNow; // just for testing }
    K_F1: ShowHelpMessage;
    K_F5: Window.SaveScreen(FileNameAutoInc('lets_take_a_walk_screen_%d.png'));
  end;
end;

{ parsing parameters --------------------------------------------------------- }

const
  Options: array[0..1]of TOption =
  ((Short:'h'; Long: 'help'; Argument: oaNone),
   (Short:'v'; Long: 'version'; Argument: oaNone)
  );

procedure OptionProc(OptionNum: Integer; HasArgument: boolean;
  const Argument: string; const SeparateArgs: TSeparateArgs; Data: Pointer);
begin
  case OptionNum of
    0:begin
        InfoWrite(
          'lets_take_a_walk: a toy, demonstrating the use of VRML/X3D and OpenGL rendering' +nl+
          '  and OpenAL environmental audio combined in one simple program.' +nl+
          '  You can walk in a 3D world (with collision-checking) using DOOM-like' +nl+
          '  keys (Up/Down, Right/Left, PageUp/PageDown, Insert/Delete, Home, +/-),' +nl+
          '  you can fire up some TNTs etc. Nothing special - but I hope that' +nl+
          '  such combination of 3d graphic and sound will make a nice effect.' +nl+
          nl+
          'Options:' +nl+
          HelpOptionHelp +nl+
          VersionOptionHelp +nl+
          SoundEngine.ParseParametersHelp +nl+
          nl+
          TCastleWindowBase.ParseParametersHelp(StandardParseOptions, true) +nl+
          nl+
          SCastleEngineProgramHelpSuffix(DisplayProgramName, Version, true));
        ProgramBreak;
      end;
    1:begin
        Writeln(Version);
        ProgramBreak;
      end;
  end;
end;

{ main -------------------------------------------------------------------- }

begin
  Window := TCastleWindowCustom.Create(Application);

  { parse parameters }
  Window.FullScreen := true; { by default we open in fullscreen }
  Window.ParseParameters(StandardParseOptions);
  SoundEngine.ParseParameters;
  Parameters.Parse(Options, @OptionProc, nil);

  { init SceneManager }
  SceneManager := TMySceneManager.Create(Window);
  Window.Controls.Add(SceneManager);
  SceneManager.OnCameraChanged := @TDummy(nil).CameraChanged;
  SceneManager.UseGlobalLights := true;

  { init level }
//  LevelsAvailable.LoadFromFiles(ProgramDataPath + 'data' +  PathDelim + 'levels');

  { init BaseScene }
  BaseScene := TCastleScene.Create(SceneManager);
  BaseScene.Load(ProgramDataPath + 'data' +  PathDelim + 'levels' + PathDelim + 'base' + PathDelim + 'base.wrl');
  Progress.UserInterface := ProgressConsoleInterface;
  BaseScene.TriangleOctreeProgressTitle := 'Building triangle octree';
  BaseScene.ShapeOctreeProgressTitle := 'Building Shape octree';
  BaseScene.Spatial := [ssRendering, ssDynamicCollisions];
  SceneManager.MainScene := BaseScene;
  SceneManager.Items.Add(BaseScene);

  { init Rat }
  Rat := T3DTransform.Create(SceneManager);
  Rat.Add(LoadScene('rat.x3d', SceneManager));
  SceneManager.Items.Add(Rat);

  { init Tnt }
  TntScene := LoadScene('tnt.wrl', SceneManager);
  while TntsCount < MaxTntsCount do NewTnt(0.0);

  { init camera }
  SceneManager.Camera := SceneManager.CreateDefaultCamera(Window);
  { Force Camera.Position inside BaseScene.BoundingBox, eventually
    high above this box (maximum Z = 1000). This makes moving sensible
    for player. }
  SceneManager.CameraBox := Box3D(
    BaseScene.BoundingBox.Data[0],
    Vector3Single(BaseScene.BoundingBox.Data[1][0], BaseScene.BoundingBox.Data[1][1], 1000));

  { init MuteImage }
  MuteImage := TCastleImageControl.Create(Application);
  MuteImage.Blending := true;
  MuteImage.FileName := ProgramDataPath + 'data' + PathDelim + 'textures' + PathDelim +'mute_sign.png';
  Window.Controls.Insert(0, MuteImage);

  { init 3D sound }
  SoundEngine.ALContextOpen;
  Writeln(SoundEngine.SoundInitializationReport);
  if SoundEngine.ALActive then
  begin
    SoundEngine.DistanceModel := dmInverseDistanceClamped; //< OpenAL default

    KaboomBuffer := CreateWAVBuffer('cannon');

    RatSoundBuffer := CreateWAVBuffer('duck');

    UpdateRatPosition;
    RatSound := SoundEngine.PlaySound(RatSoundBuffer, true, true,
      1, 1.0, 0, 1, Rat.Translation);
    if RatSound = nil then
      raise Exception.Create('Cannot allocate rat sound');

    RatSqueakBuffer := CreateWAVBuffer('catyell');

    { setup night sound souce }
    NightSoundBuffer := CreateWAVBuffer('cricketnight');
    SoundEngine.PlaySound(NightSoundBuffer, true, true, 1, 1, 0.01, 0.05,
      Vector3Single(2.6148309707641602, -1.9643138647079468, 1));

    ThunderALOpen;

    CheckAL('init OpenAL');
  end;

  UpdateMute;

  { init messages }
  MessagesTheme.RectColor[3] := 0.8;

  { init window }
  Window.OnClose := @close;
  Window.OnResize := @resize;
  Window.OnIdle := @Idle;
  Window.OnTimer := @Timer;
  Window.OnKeyDown := @KeyDown;
  Window.AutoRedisplay := true;
  Window.Caption := 'Let''s take a walk';
  Window.SetDemoOptions(K_F11, CharEscape, true);

  Window.OpenAndRun;
end.
