{
  Copyright 2001-2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Convert an image file to a Pascal source code, thus allowing
  you easily embed image files in program executables.

  Command-line option specifies image filename.

  Outputs (on stdout) Pascal unit that defines single TImage class
  instance (created / freed in unit's initialization / finalization)
  that contains the size and contents of given image.

  Unless you specified --no-show-progress, it will display
  progress of operation on stderr (this is useful in case of very large
  image files).

  For an example output of this program see e.g. view3dscene sources,
  the stuff in view3dscene/images/ subdirectory is converted into
  image*.pas units.
}

{$apptype CONSOLE}

program image_to_pas;

uses SysUtils, Images, KambiUtils, ProgressUnit, ProgressConsole,
  KambiTimeUtils;

var 
  Image: TImage;
  ImageFileName: string;
  NameUnit, NameWidth, NameHeight, NamePixels, NameImage: string;
  i: Cardinal;
  pb: PByte;
  ShowProgress: boolean = true;
begin
  {parse params}
  i := 0;
  while i <= Cardinal(Parameters.High) do
   if Parameters[i] = '--no-show-progress' then
    begin ShowProgress := false; Parameters.Delete(i, 1) end else
    Inc(i);

  Parameters.CheckHigh(1);
  ImageFilename := Parameters[1];

  { Init other Image* variables }
  NameImage := ExtractOnlyFileName(ImageFileName);
  NameImage[1] := UpCase(NameImage[1]);
  Image := LoadImage(ImageFileName, [], []);

  try

    { Init progres }
    Progress.UserInterface := ProgressConsoleInterface;

    { Calculate Name* variables }
    NameUnit := 'Image' +NameImage;
    NameWidth := NameImage +'Width';
    NameHeight := NameImage +'Height';
    NamePixels := NameImage +'Pixels';

    { Write everything }
    Write(
      '{ -*- buffer-read-only: t -*- }' +nl+
      nl+
      'unit '+NameUnit+';' +nl+
      nl+
      '{ Unit automatically generated by image_to_pas' +nl+
      '  from file ' +ImageFileName +' }' +nl+
      nl+
      'interface' +nl+
      nl+
      'uses Images;' +nl+
      nl+
      'var' +nl+
      '  ' +NameImage+ ': ' +Image.ClassName+ ';' +nl+
      nl+
      'implementation' +nl+
      nl+
      'uses SysUtils;' +nl+
      nl+
      'const' +nl+
      '  ' +NameWidth+ ' = ' +IntToStr(Image.Width)+ ';' +nl+
      '  ' +NameHeight+ ' = ' +IntToStr(Image.Height)+ ';' +nl+
      '  ' +NamePixels+ ': array[0 .. ' +NameWidth+ ' * '
        +NameHeight+ ' * ' +IntToStr(Image.PixelSize) + ' - 1] of Byte = (' +nl+
      '    ');

    if ShowProgress then
      Progress.Init((Image.Width * Image.Height * Image.PixelSize - 1) div 12,
        'Generating image ' +NameImage);

    pb := PByte(Image.RawPixels);
    for i := 1 to Image.Width * Image.Height * Image.PixelSize - 1 do
    begin
      Write(pb^:4, ',');
      if (i mod 12) = 0 then
      begin
        Write(nl+'    ');
        if ShowProgress then Progress.Step
      end else
        Write(' ');
      Inc(pb);
    end;
    Writeln(pb^:4, ');');

    if ShowProgress then Progress.Fini;

    Writeln(
      nl+
      'initialization' +nl+
      '  ' +NameImage+ ' := ' +Image.ClassName+ '.Create(' +NameWidth+', ' +NameHeight+ ');' +nl+
      '  Move(' +NamePixels+ ', ' +NameImage+ '.RawPixels^, SizeOf(' +NamePixels+ '));' +nl+
      'finalization' +nl+
      '  FreeAndNil(' +NameImage+ ');' +nl+
      'end.');

  finally FreeAndNil(Image) end;
end.
