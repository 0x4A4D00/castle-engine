{
  Copyright 2001-2005 Michalis Kamburelis.

  This file is part of "Kambi's OpenGL Pascal units".

  "Kambi's OpenGL Pascal units" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi's OpenGL Pascal units" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi's OpenGL Pascal units"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

{ @abstract(TGLOutlineFont class for outline (3d) fonts for OpenGL.)

  This class initializes itself based on information in TTrueTypeFont type,
  from TTFontsTypes. Typically such information is automatically
  generated by my font2pascal program.

  So when you have some font named "Xxx" and want to use it in your OpenGL
  program as 3d text:
  1. convert it to Pascal unit using font2pascal, to get unit like ttf_xxxunit.pas
  2. add to your uses clause TTF_XxxUnit and this module, OpenGLTTFonts
  3. and now you can create object like
       Font := TGLOutlineFont.Create(@@TTF_Xxx)
     and use it like
       Font.Print('foo');
}

unit OpenGLTTFonts;

{
  TODO: make sure docs look good in pasdoc
  TODO: translate docs to English
}

{$I kambiconf.inc}
{$I openglmac.inc}

interface

uses OpenGLFonts, OpenGLh, TTFontsTypes, SysUtils, KambiGLUtils;

type
  { }
  TGLOutlineFont = class(TGLOutlineFont_Abstract)
  private
    base : TGLuint;
    TTFont : PTrueTypeFont;
    procedure CharPrint(c: char);
    procedure CharPrintAndMove(c: char);
  public
    { konstruktor dostaje wskaznik na TTrueTypeFont. Aby zmniejszyc zuzycie czasu
      i pamieci zawartosc wskazywana NIE JEST kopiowana, zachowywany jest tylko
      ten wskaznik. Dlatego jesli zmienisz cos we wskazywanej strukturze mozesz
      zmienic ten font juz po utworzeniu tego obiektu, ale nie rob tego !
      Ponizszy interfejs nie gwarantuje ci niczego w tym wzgledzie ! Struktury
      TTrueTypeFont ktorych wskazniki przekazesz do konstruktora tego obiektu MUSISZ
      odtad traktowac jako read-only ! }
    { depth to grubosc fontu - jesli depth > 0 to powstale litery beda brylami 3D.
      (Jesli depth = 0 to beda plaskie). Depth > 0 dosc znacznie komplikuje polygon
      i moze spowodowac jakis spadek szybkosci rysowania. }
    { jesli onlyLines to font bedzie samym "szkielecikiem" }
    constructor Create(TrueTypeFont: PTrueTypeFont; depth: TGLfloat = 0.0;
      onlyLines: boolean = false); overload;
    destructor Destroy; override;

    procedure Print(const s: string); override;
    procedure PrintAndMove(const s: string); override;
    function TextWidth(const s: string): single; override;
    function TextHeight(const s: string): single; override;

    {Wypisz tekst generujac wspolrzedne tekstury : texOriginX, texOriginY
       beda sie mapowac na texCoord=(0, 0), potem tex coord bedzie sie przesuwac
       o 1 gdy wspolrzedna przesunie sie o RowHeight.
     Wymaga 1 miejsca na stosie attrib.
     Wersja bez AndMove wymaga dodatkowo 1 miejsca na stosie matrix modelview.}
    procedure PrintTexturedAndMove(const s: string; texOriginX, texOriginY: TGLfloat);
    procedure PrintTextured(const s: string; texOriginX, texOriginY: TGLfloat);
  end;

implementation

uses KambiUtils;

const
  {w tej chwili zawsze 255 ale byc moze kiedys cos tu zmienie}
  TTTableCount = Ord(High(char)) - Ord(Low(char)) +1;

type
  TVerticesTable = record
    { Sample font that requires length of p > 1000 is "Christmas Card".
      So length of p is now 10 000. }
    p: array[1..10000] of TVector3d;
    count: integer;
  end;
  PVerticesTable = ^TVerticesTable;

  procedure AddVertex(var table: TVerticesTable; const v: TVector3d);
  begin
   if table.count >= High(table.p) then
    raise EInternalError.Create('OpenGLTTFonts: too small size of '+
      'TVerticesTable.p - tesselator can''t work') else
    begin
     Inc(table.count);
     table.p[table.count] := v;
    end;
  end;

  function LastAdded(const table: TVerticesTable): PVector3d;
  begin result := @table.p[table.count] end;

procedure TessCombineCallback(Coords: PVector3d; vertex_data: PVector4p;
  Weight: PVector4f; dataOut: PPointer; tablep: PVerticesTable ); OPENGL_CALLBACK_CALL
begin
 AddVertex(tablep^, Coords^);
 dataOut^ := LastAdded(tablep^);
end;

constructor TGLOutlineFont.Create(TrueTypeFont: PTrueTypeFont; depth: TGLfloat; onlyLines: boolean);
var i, poz,
    linesCount, pointsCount :Cardinal;
    Znak: PTTFChar;
    tobj: PGLUTesselator;

    { tablica przechowujaca vertexy na ktore tesselator bedzie dostawal wskazniki. }
    vertices : PVerticesTable;

  procedure TesselatedPolygon(polZ: TGLfloat);
  var PolygonNum, LineNum, PointNum: Integer;
      PointsKind: TPolygonKind;
  begin
   vertices.count := 0;

   gluTessBeginPolygon(tobj, vertices);
   poz := 0;
   for PolygonNum := 1 to Znak.Info.PolygonsCount do
   begin
    { read pkNewPolygon starter }
    Assert(Znak.items[poz].Kind = pkNewPolygon);
    linesCount := Znak.items[poz].Count;
    Inc(poz);

    gluTessBeginContour(tobj);
    for LineNum := 1 to linesCount do
    begin
     { read pkLines/Bezier starter }
     Assert(Znak.items[poz].Kind in [pkLines, pkBezier]);
     PointsKind := Znak.items[poz].Kind;
     PointsCount := Znak.items[poz].Count;
     Inc(poz);

     case PointsKind of
      pkLines,
      pkBezier:
        begin
         for PointNum := 1 to PointsCount-1 do
         begin
          with Znak.items[poz] do
          begin
           { vertexy dla tesselatora musza byc podawane w postaci 3 x GLdouble
             (a my mamy 2 x GLfloat). Nie mozna ich tworzyc tymczasowo (za pomoca
             funkcji Vector3d, na przyklad) bo przekazujemy WSKAZNIK i glu nie kopiuje
             sobie jego zawartosci ale pozniej przekazuje do glVertex3dv zapamietany
             wskaznik. Wiec te strukturki 3 x GLdouble musza byc troche bardziej trwale
             (wskazniki musza byc poprawne az do konca tesselowania tego znaku).
             Dlatego uzywamy tablicy vertices (zwroc uwage ze tablica o dynamicznym
             rozmiarze nie jest tu dobrym rozwiazaniem bo przy kazdej alokacji
             cala tablica dynamiczna moze zostac przesunieta w inne miejsce
             pamieci. Wiec wskazniki na elementy tablicy dynamicznej nie maja
             zadnej trwalosci ! }
           AddVertex(vertices^, Vector3d(x, y,polZ) );
           gluTessVertex(tobj,
             {$ifdef USE_GL_GLU_UNITS} T3dArray ( {$endif}
             LastAdded(vertices^)
             {$ifdef USE_GL_GLU_UNITS} ^) {$endif}
             , LastAdded(vertices^) );
          end;
          Inc(poz);
         end;
         Inc(poz); { ostatniego punktu linii nie czytamy - to jest pierwszy
                     punkt nastepnej linii lub pierwszy punkt polygonu }
        end;
        {sorry - zrobic opcje ktora pozwoli na robienie tu krzywych beziera,
         jesli kiedys bedziesz potrzebowal BARDZO dokladnie wyrenderowac
         jakas literke (np. w duzym powiekszeniu) }
     end;
    end;
    gluTessEndContour(tobj);
   end;
   gluTessEndPolygon(tobj);
  end;

var PolygonNum, LineNum, PointNum: Integer;
    PointsKind: TPolygonKind;
begin
 inherited Create;
 New(vertices);
 try
  base := glGenLists(TTTableCount);
  Self.TTFont := TrueTypeFont;

  { notka : ciekawostke stanowi fakt ze moj OpenGL pod Linuxem dziala zle
    gdy nie ma edgeFlag'a. Uruchom view3dmodel ConeTest.wrl i zobacz
    na srodkowy dysk od dolu - bedzie zle oswietlony.
    Takze TextTest przy wlaczonym oswietleniu bedzie zly. }
  tobj := gluNewTess;  { inicjuj tesselator }
  gluTessCallback(tobj, GLU_TESS_VERTEX, @glVertex3dv);
  gluTessCallback(tobj, GLU_TESS_BEGIN, @glBegin);
  gluTessCallback(tobj, GLU_TESS_END, @glEnd);
  gluTessCallback(tobj, GLU_TESS_EDGE_FLAG, @glEdgeFlag);
  gluTessCallback(tobj, GLU_TESS_ERROR, @ReportGLError);
  gluTessCallback(tobj, GLU_TESS_COMBINE_DATA, @TessCombineCallback);

  if onlyLines then gluTessProperty(tobj, GLU_TESS_BOUNDARY_ONLY, GL_TRUE);

  {line below speeds up the tesselation and makes sure that all letters
   have consistent winding (conterclockwise with respect to normal 0, 0,-1)}
  gluTessNormal(tobj, 0, 0,-1);

  for i := 0 to 255 do
  begin
   Znak := TTFont[Chr(i)];
   glNewList(i+base, GL_COMPILE);

   TesselatedPolygon(0);

   if depth <> 0 then
   begin
    TesselatedPolygon(depth); {narysuj na glebokosci depth kopie poligonu}

    poz := 0;
    for PolygonNum := 1 to Znak.Info.PolygonsCount do
    begin
     Assert(Znak.items[poz].Kind = pkNewPolygon);
     linesCount := Znak.items[poz].Count;
     Inc(poz);

     if onlyLines then glBegin(GL_LINES) else glBegin(GL_QUAD_STRIP);
     for LineNum := 1 to LinesCount do
     begin
      Assert(Znak.items[poz].Kind in [pkLines, pkBezier]);
      PointsKind := Znak.items[poz].Kind;
      PointsCount := Znak.items[poz].Count;
      Inc(poz);

      case PointsKind of
       pkLines,
       pkBezier:
         begin
          for PointNum := 1 to PointsCount-1 do
          begin
           with Znak.items[poz] do begin
            glVertex2f(x, y);
            glVertex3f(x, y,depth);
           end;
           Inc(poz);
          end;
          Inc(poz); { ostatniego punktu linii nie czytamy - to jest pierwszy
                      punkt nastepnej linii lub pierwszy punkt polygonu }
         end;
         {sorry - robic tu krzywe beziera jezeli kiedys bede potrzebowal
          takiej dokladnosci?}
      end;
     end;

     {na koncu - laczymy ostatnia pare z pierwsza}
     if not onlyLines then
     with Znak.items[poz-1] do
     begin
      glVertex2f(x, y);
      glVertex3f(x, y,depth);
     end;

     glEnd;
    end;
   end;

   glEndList;

  end;

  gluDeleteTess(tobj);

 finally Dispose(vertices) end;

 fRowHeight := TTFontSimpleRowHeight(TTFont);
end;

destructor TGLOutlineFont.Destroy;
begin
 glDeleteLists(base, TTTableCount);
 inherited;
end;

procedure TGLOutlineFont.CharPrint(c: char);
begin
 glCallList(Ord(c)+base);
end;

procedure TGLOutlineFont.CharPrintAndMove(c: char);
begin
 CharPrint(c);
 glTranslatef(TTFont[c].Info.MoveX, TTFont[c].Info.MoveY, 0);
end;

procedure TGLOutlineFont.Print(const s: string);
begin
 glPushMatrix;
 PrintAndMove(s);
 glPopMatrix;
end;

procedure TGLOutlineFont.PrintAndMove(const s: string);
var i: integer;
begin
 for i := 1 to Length(s) do CharPrintAndMove(s[i]);
end;

function TGLOutlineFont.TextWidth(const s: string): single;
begin result := TTFontTextWidth(TTfont, s) end;

function TGLOutlineFont.TextHeight(const s: string): single;
begin result := TTFontTextHeight(TTfont, s) end;

procedure TGLOutlineFont.PrintTexturedAndMove(const s: string; texOriginX, texOriginY: TGLfloat);
var i: integer;
    xshift: TGLfloat;
begin
 glPushAttrib(GL_TEXTURE_BIT);

 glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
 glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
 {texT = (objectY - texOriginY)/RowHeight =
         objectY/RowHeight - texOriginY/RowHeight}
 glTexGenv(GL_T, GL_OBJECT_PLANE, Vector4f(0, 1/RowHeight, 0, -texOriginY));
 glEnable(GL_TEXTURE_GEN_S);
 glEnable(GL_TEXTURE_GEN_T);

 xshift := 0;
 for i := 1 to Length(s) do
 begin
  {texS = (objectX+xshift - texOriginX)/RowHeight =
          objectX/RowHeight + (xshift-texOriginX)/RowHeight
   xshift sie zmienia, to jest powod dla ktorego musimy przed narysowaniem
   kazdego charactera ustawic glTexGenv(GL_S,...) od nowa}
  glTexGenv(GL_S, GL_OBJECT_PLANE, Vector4f(1/RowHeight, 0,0,(xshift-texOriginX)/RowHeight));
  CharPrintAndMove(s[i]);
  xshift := xshift+TTFont[s[i]].Info.MoveX;
 end;

 glPopAttrib;
end;

procedure TGLOutlineFont.PrintTextured(const s: string; texOriginX, texOriginY: TGLfloat);
begin
 glPushMatrix;
 PrintTexturedAndMove(s, texOriginX, texOriginY);
 glPopMatrix;
end;

end.
