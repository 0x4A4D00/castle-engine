{
  Copyright 2001-2006 Michalis Kamburelis.

  This file is part of "Kambi's OpenGL Pascal units".

  "Kambi's OpenGL Pascal units" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi's OpenGL Pascal units" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi's OpenGL Pascal units"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

{ TGLOutlineFont class. }

unit OpenGLTTFonts;

{$I kambiconf.inc}
{$I openglmac.inc}

interface

uses OpenGLFonts, OpenGLh, TTFontsTypes, SysUtils, KambiGLUtils;

type
  { Outline 3D font for OpenGL.

    This allows you to create outline font (that implements
    TGLOutlineFont_Abstract interface) based on information
    expressed as TTFontsTypes.TTrueTypeFont type.

    You can use font2pascal program to convert fonts' files
    to Pascal units with TTrueTypeFont constant. See various
    TTF_Xxx units, e.g. @code(../fonts/ttf_bitstreamverasans_unit.pas).

    So the basic road to use some font in your OpenGL program as 3d text is:
    @orderedList(
      @itemSpacing Compact
      @item(convert font to Pascal unit using font2pascal,
        to get unit like ttf_xxxunit.pas)
      @item(add to your uses clause TTF_Xxx_Unit and this unit, OpenGLTTFonts)
      @item(and now you can create object like
        @longCode# Font := TGLOutlineFont.Create(@@TTF_Xxx) #
       and use it like
        @longCode# Font.Print('foo'); #
      )
    ) }
  TGLOutlineFont = class(TGLOutlineFont_Abstract)
  private
    base : TGLuint;
    TTFont : PTrueTypeFont;
    procedure CharPrint(c: char);
    procedure CharPrintAndMove(c: char);
  public
    { Create instance from TrueTypeFont.

      @param(TrueTypeFont
        This is the pointer to your font, TTrueTypeFont.

        Note that to conserve the use of time and memory this constructor
        @italic(copies only this pointer (not the memory pointed to))
        so you must make sure that this pointer is valid for the lifetime
        of this object. Also you shouldn't modify the pointed font data
        after creating this instace (otherwise some things (like
        precalculated OpenGL display lists and stored font sizes)
        could get desynchronized).

        The usual simple way to keep all the assumptions above is to
        make TrueTypeFont a pointer to a constant defined in unit
        generated by font2pascal program.)

      @param(Depth
        This is the thickness of the font shape.
        When Depth > 0 then the resulting letters will be true 3D objects.
        Otherwise, when Depth = 0, the resulting letters will be flat.
        Note that Depth > 0 (i.e. 3D objects) increases triangle count
        of resulting letters, so the font with Depth > 0 will be rendered
        slower than the same font with Depth = 0.)

      @param(OnlyLines
        If @true then the font will be only a "skeleton" (only lines,
        no polygons).) }
    constructor Create(TrueTypeFont: PTrueTypeFont; depth: TGLfloat = 0.0;
      onlyLines: boolean = false); overload;
    destructor Destroy; override;

    procedure Print(const s: string); override;
    procedure PrintAndMove(const s: string); override;
    function TextWidth(const s: string): single; override;
    function TextHeight(const s: string): single; override;

    { This renders the text additionally generating texture coordinates.

      texOriginX and texOriginY will map to texture coord = (0, 0),
      then texture coord will increase by 1 when the distance will
      increase by RowHeight.

      This requires one place on attrib stack of OpenGL.
      Version without the "AndMove" requires also one place
      on matrix modelview stack of OpenGL.

      @groupBegin }
    procedure PrintTexturedAndMove(const s: string;
      const texOriginX, texOriginY: TGLfloat);

    procedure PrintTextured(const s: string;
      const texOriginX, texOriginY: TGLfloat);
    { @groupEnd }
  end;

implementation

uses KambiUtils;

const
  {w tej chwili zawsze 256 ale byc moze kiedys cos tu zmienie}
  TTTableCount = Ord(High(char)) - Ord(Low(char)) +1;

type
  TVerticesTable = record
    { Sample font that requires length of p > 1000 is "Christmas Card".
      So length of p is now 10 000. }
    p: array[1..10000] of TVector3d;
    count: integer;
  end;
  PVerticesTable = ^TVerticesTable;

  procedure AddVertex(var table: TVerticesTable; const v: TVector3d);
  begin
   if table.count >= High(table.p) then
    raise EInternalError.Create('OpenGLTTFonts: too small size of '+
      'TVerticesTable.p - tesselator can''t work') else
    begin
     Inc(table.count);
     table.p[table.count] := v;
    end;
  end;

  function LastAdded(const table: TVerticesTable): PVector3d;
  begin result := @table.p[table.count] end;

procedure TessCombineCallback(Coords: PVector3d; vertex_data: PVector4p;
  Weight: PVector4f; dataOut: PPointer; tablep: PVerticesTable ); OPENGL_CALLBACK_CALL
begin
 AddVertex(tablep^, Coords^);
 dataOut^ := LastAdded(tablep^);
end;

constructor TGLOutlineFont.Create(TrueTypeFont: PTrueTypeFont;
  depth: TGLfloat; onlyLines: boolean);
var i, poz,
    linesCount, pointsCount :Cardinal;
    Znak: PTTFChar;
    tobj: PGLUTesselator;

    { tablica przechowujaca vertexy na ktore tesselator bedzie dostawal wskazniki. }
    vertices : PVerticesTable;

  procedure TesselatedPolygon(polZ: TGLfloat);
  var PolygonNum, LineNum, PointNum: Integer;
      PointsKind: TPolygonKind;
  begin
   vertices^.count := 0;

   gluTessBeginPolygon(tobj, vertices);
   poz := 0;
   for PolygonNum := 1 to Znak^.Info.PolygonsCount do
   begin
    { read pkNewPolygon starter }
    Assert(Znak^.items[poz].Kind = pkNewPolygon);
    linesCount := Znak^.items[poz].Count;
    Inc(poz);

    gluTessBeginContour(tobj);
    for LineNum := 1 to linesCount do
    begin
     { read pkLines/Bezier starter }
     Assert(Znak^.items[poz].Kind in [pkLines, pkBezier]);
     PointsKind := Znak^.items[poz].Kind;
     PointsCount := Znak^.items[poz].Count;
     Inc(poz);

     case PointsKind of
      pkLines,
      pkBezier:
        begin
         for PointNum := 1 to PointsCount-1 do
         begin
          with Znak^.items[poz] do
          begin
           { vertexy dla tesselatora musza byc podawane w postaci 3 x GLdouble
             (a my mamy 2 x GLfloat). Nie mozna ich tworzyc tymczasowo (za pomoca
             funkcji Vector3d, na przyklad) bo przekazujemy WSKAZNIK i glu nie kopiuje
             sobie jego zawartosci ale pozniej przekazuje do glVertex3dv zapamietany
             wskaznik. Wiec te strukturki 3 x GLdouble musza byc troche bardziej trwale
             (wskazniki musza byc poprawne az do konca tesselowania tego znaku).
             Dlatego uzywamy tablicy vertices (zwroc uwage ze tablica o dynamicznym
             rozmiarze nie jest tu dobrym rozwiazaniem bo przy kazdej alokacji
             cala tablica dynamiczna moze zostac przesunieta w inne miejsce
             pamieci. Wiec wskazniki na elementy tablicy dynamicznej nie maja
             zadnej trwalosci ! }
           AddVertex(vertices^, Vector3d(x, y, polZ) );
           gluTessVertex(tobj,
             {$ifdef USE_GL_GLU_UNITS} T3dArray ( {$endif}
             LastAdded(vertices^)
             {$ifdef USE_GL_GLU_UNITS} ^) {$endif}
             , LastAdded(vertices^) );
          end;
          Inc(poz);
         end;
         Inc(poz); { ostatniego punktu linii nie czytamy - to jest pierwszy
                     punkt nastepnej linii lub pierwszy punkt polygonu }
        end;
        { TODO:  zrobic opcje ktora pozwoli na robienie tu krzywych beziera,
          jesli kiedys bedziesz potrzebowal BARDZO dokladnie wyrenderowac
          jakas literke (np. w duzym powiekszeniu) }
     end;
    end;
    gluTessEndContour(tobj);
   end;
   gluTessEndPolygon(tobj);
  end;

var PolygonNum, LineNum, PointNum: Integer;
    PointsKind: TPolygonKind;
begin
 inherited Create;
 New(vertices);
 try
  base := glGenListsCheck(TTTableCount, 'TGLOutlineFont.Create');
  Self.TTFont := TrueTypeFont;

  tobj := gluNewTess();  { inicjuj tesselator }
  gluTessCallback(tobj, GLU_TESS_VERTEX, {$ifndef FPC_OBJFPC} @ {$endif} glVertex3dv);
  gluTessCallback(tobj, GLU_TESS_BEGIN, {$ifndef FPC_OBJFPC} @ {$endif} glBegin);
  gluTessCallback(tobj, GLU_TESS_END, {$ifndef FPC_OBJFPC} @ {$endif} glEnd);

  { This is a workaround of Mesa3D bug.
    See ../doc/mesa_normals_edge_flag_bug.txt }
  if not GLVersion.IsMesa then
    gluTessCallback(tobj, GLU_TESS_EDGE_FLAG,
      {$ifndef FPC_OBJFPC} @ {$endif} glEdgeFlag);

  gluTessCallback(tobj, GLU_TESS_ERROR, @ReportGLError);
  gluTessCallback(tobj, GLU_TESS_COMBINE_DATA, @TessCombineCallback);

  if onlyLines then gluTessProperty(tobj, GLU_TESS_BOUNDARY_ONLY, GL_TRUE);

  {line below speeds up the tesselation and makes sure that all letters
   have consistent winding (conterclockwise with respect to normal 0, 0, -1)}
  gluTessNormal(tobj, 0, 0, -1);

  for i := 0 to 255 do
  begin
   Znak := TTFont^[Chr(i)];
   glNewList(i+base, GL_COMPILE);

   TesselatedPolygon(0);

   if depth <> 0 then
   begin
    TesselatedPolygon(depth); {narysuj na glebokosci depth kopie poligonu}

    poz := 0;
    for PolygonNum := 1 to Znak^.Info.PolygonsCount do
    begin
     Assert(Znak^.items[poz].Kind = pkNewPolygon);
     linesCount := Znak^.items[poz].Count;
     Inc(poz);

     if onlyLines then glBegin(GL_LINES) else glBegin(GL_QUAD_STRIP);
     for LineNum := 1 to LinesCount do
     begin
      Assert(Znak^.items[poz].Kind in [pkLines, pkBezier]);
      PointsKind := Znak^.items[poz].Kind;
      PointsCount := Znak^.items[poz].Count;
      Inc(poz);

      case PointsKind of
       pkLines,
       pkBezier:
         begin
          for PointNum := 1 to PointsCount-1 do
          begin
           with Znak^.items[poz] do begin
            glVertex2f(x, y);
            glVertex3f(x, y, depth);
           end;
           Inc(poz);
          end;
          Inc(poz); { ostatniego punktu linii nie czytamy - to jest pierwszy
                      punkt nastepnej linii lub pierwszy punkt polygonu }
         end;
         { TODO:  robic tu krzywe beziera jezeli kiedys bede potrzebowal
           takiej dokladnosci? }
      end;
     end;

     {na koncu - laczymy ostatnia pare z pierwsza}
     if not onlyLines then
     with Znak^.items[poz-1] do
     begin
      glVertex2f(x, y);
      glVertex3f(x, y, depth);
     end;

     glEnd;
    end;
   end;

   glEndList;

  end;

  gluDeleteTess(tobj);

 finally Dispose(vertices) end;

 fRowHeight := TTFontSimpleRowHeight(TTFont);
end;

destructor TGLOutlineFont.Destroy;
begin
 glDeleteLists(base, TTTableCount);
 inherited;
end;

procedure TGLOutlineFont.CharPrint(c: char);
begin
 glCallList(Ord(c)+base);
end;

procedure TGLOutlineFont.CharPrintAndMove(c: char);
begin
 CharPrint(c);
 glTranslatef(TTFont^[c]^.Info.MoveX, TTFont^[c]^.Info.MoveY, 0);
end;

procedure TGLOutlineFont.Print(const s: string);
begin
 glPushMatrix;
 PrintAndMove(s);
 glPopMatrix;
end;

procedure TGLOutlineFont.PrintAndMove(const s: string);
var i: integer;
begin
 for i := 1 to Length(s) do CharPrintAndMove(s[i]);
end;

function TGLOutlineFont.TextWidth(const s: string): single;
begin result := TTFontTextWidth(TTfont, s) end;

function TGLOutlineFont.TextHeight(const s: string): single;
begin result := TTFontTextHeight(TTfont, s) end;

procedure TGLOutlineFont.PrintTexturedAndMove(const s: string;
  const texOriginX, texOriginY: TGLfloat);
var
  i: integer;
  xshift: TGLfloat;
begin
 glPushAttrib(GL_TEXTURE_BIT);

 glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
 glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
 {texT = (objectY - texOriginY)/RowHeight =
         objectY/RowHeight - texOriginY/RowHeight}
 glTexGenv(GL_T, GL_OBJECT_PLANE, Vector4f(0, 1/RowHeight, 0, -texOriginY));
 glEnable(GL_TEXTURE_GEN_S);
 glEnable(GL_TEXTURE_GEN_T);

 xshift := 0;
 for i := 1 to Length(s) do
 begin
  {texS = (objectX+xshift - texOriginX)/RowHeight =
          objectX/RowHeight + (xshift-texOriginX)/RowHeight
   xshift sie zmienia, to jest powod dla ktorego musimy przed narysowaniem
   kazdego charactera ustawic glTexGenv(GL_S,...) od nowa}
  glTexGenv(GL_S, GL_OBJECT_PLANE,
    Vector4f(1/RowHeight, 0, 0,(xshift-texOriginX)/RowHeight));
  CharPrintAndMove(s[i]);
  xshift := xshift+TTFont^[s[i]]^.Info.MoveX;
 end;

 glPopAttrib;
end;

procedure TGLOutlineFont.PrintTextured(const s: string;
  const texOriginX, texOriginY: TGLfloat);
begin
 glPushMatrix;
 PrintTexturedAndMove(s, texOriginX, texOriginY);
 glPopMatrix;
end;

end.
