Notes about shading languages:

http://en.wikipedia.org/wiki/Shading_language

Assembly shading languages:
- blessed by ARB (standard in gl >= 2.0):
  ARB_vertex_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_program.txt
  ARB_fragment_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/fragment_program.txt

  http://en.wikipedia.org/wiki/ARB_%28GPU_assembly_language%29

  Very nice overview or ARB vertex/fragment assembly programs:
  http://www.ce.chalmers.se/edu/course/EDA425/lectures/shaders.pdf

  Note: no real "if" to make execution of shaders in parallel possible.
  There are only cheats like "CMP" - conditional copy,
    CMP result a b c
  means
    result := if a < 0 then b else c;
  or
    SLT result a b
  means
    result := if a < b then 1 else 0;
  Sure you can do tricks with this, actually you can emulate whole "if"
  (in the worst case, just set some variable based on the result of comparison,
  then perform both branches of "if", one after the other,
  multiply result if 1st branch with SLT result,
  multiply result if 2nd branch with (1-SLT result)).

  You can play with assembler languages, by compiling GLSL to it by cgc:
    cgc -oglsl -profile arbfp1 glsl_toon_shading.fs
  .. to see that this "if" compiles to "CMP" and "SLT".
  Example:

    void main()
    {
      if (gl_TexCoord[0].x > 0.5)
	gl_FragColor = vec4(1, 1, 1, 1); else
	gl_FragColor = vec4(0, 0, 0, 1);
    }

  =>

    PARAM c[1] = { { 1, 0, 0.5 } };
    TEMP R0;

    SLT R0.x, c[0].z, fragment.texcoord[0];
    # So R0.x = 1 means "0.5 < gl_TexCoord[0].x", that is 1st if branch
    # should be done. Otherwise it's R0.x = 0.

    ABS R0.x, R0;
    # This is useless ? Most probably this is a common "combo" of instructions
    # together with compare below.

    CMP R0.x, -R0, c[0].y, c[0];
    # last arg "c[0]" actually is equivalent to "c[0].x", since we use
    # only the 1st component of the vector (because result is only 1 component).
    # So this is equivalent to
    #   CMP R0.x, -R0.x, 0, 1;
    # So
    #   if -R0.x < 0 then R0.x = 0 else R0.x = 1
    # so (consider R0.x is either 0 or 1)
    #   if R0.x = 1 then R0.x = 0 else R0.x = 1
    # IOW, this was *really* convoluted way to say "R0.x := 1 - R0.x;"

    CMP result.color, -R0.x, c[0].yyyx, c[0].x;
    # "-R0.x < 0" still means just "R0.x = 1". So if that's the truth,
    # set result.color to (0, 0, 0, 1) otherwise (1, 1, 1, 1).

    END

  As usual, we could write better assembler code by hand, as we see
  that "ABS" was useless and actually "R0.x := 1 - R0.x;" was useless
  too (I could just swap the operands of CMP). So I can shorten this to:

    PARAM c[1] = { { 1, 0, 0.5 } };
    TEMP R0;

    SLT R0.x, c[0].z, fragment.texcoord[0];
    CMP result.color, -R0.x, c[0].x, c[0].yyyx;

    END

- NVidia-specific ancestors of ARB langs above (don't use, use ARB now):
  NV_fragment_program
  http://www.opengl.org/registry/specs/NV/fragment_program.txt
  NV_vertex_program.txt
  http://oss.sgi.com/projects/ogl-sample/registry/NV/vertex_program.txt
  Very similar to ARB counterparts.

- even older: NVidia register combiners
  http://developer.nvidia.com/object/registercombiners.html

  In some way, this is not a new language, it's only an extension to
  multitexturing, "programmed" by issuing appropriate OpenGL API calls,
  much like normal multitexturing.
  But with much more parameters and flexibility. So much that complexity
  of this qualifies it as an initial attempt at fragment programs.

Higher-level shading languages:
- blessed by ARB (standard in gl >= 2.0, gl >= 2.1 requires GLSL >= 1.20),
  compiled into ARB assembly langs above:
  GLSL or glslang

  Merges fragment and vertex langs in one syntax. What's even more
  important, allows vertex program to easily pass arguments
  to vertex program. (API creates one shader program to which you
  can attach vertex and/or fragment programs, that will communicate).

  Many many tutorials and references around the WWW,
  http://www.opengl.org/documentation/glsl/
  http://www.lighthouse3d.com/opengl/glsl/
  http://folk.uio.no/johans/publications/Seland.2006.INF3320.pdf
  http://nehe.gamedev.net/data/articles/article.asp?article=21
  basically just
  http://www.google.com/search?q=glsl

  Note: be sure to test your GLSL not only on NVidia cards.
  NVidia GL tends to be forgiving to various malformed (but reasonable...)
  code, most probably because cgc also is forgiving and they use the same
  parser there, and cgc is forgiving because it was initially for Cg language.
  NVidia does eat every valid GLSL code, they just also often eat invalid GLSL
  code (with some Cg shortcuts / syntax).
  So if you develop on NVidia, be sure to test afterwards also on ATI/Mesa
  and fix eventual small things (like texture coords for texture2D functions
  should have ".st" qualifiers).

  See kambi_vrml_test_suite/vrml_2/kambi_extensions/shaders/
  for demo how it's used from VRML.

- NVidia Cg
  http://en.wikipedia.org/wiki/Cg_%28programming_language%29

  Also high-level, also C-like. One advantage is that this is also
  usable for Direct X, assuming anyone cares.
  Although cgc can be used to compile GLSL to any other output language
  (even Direct X one, it seems, although I didn't test).

  This language is not built inside OpenGL. It's compiled into
  other languages --- like ARB_vertex_program, ARB_fragment_program,
  GLSL vertex/fragment. You can also compile *from* GLSL.
  You need NVidia Cg toolkit for this.

  - Shader may be compiled by a developer, when developing the game ---
    this means that you compile to one or several chosen hardware profiles
    that you expect that your game will run on. Like
      cgc cg_sample.cg -profile arbvp1 -o vertex_program_from_cg_sample.txt

  - Or it can be compiled at your game runtime. This means that you
    distribute your game with actual Cg shader sources, and compile
    on user machine. This means that you compile precisely for the
    hardware that will run the shader, so you may get more optimizations.
    The disadvantage is that you must program it, to link and call Cg runtime
    functions to compile from your program.

Notes:
- The "pipeline" requirement is not present in shaders.
  In one program I can access any texture coordinate and sample any texture.
  E.g. for ARB vertex program see fragment.texcoord[n], texture[n],
  operations like TEX, TXP.

    TEX some_result, some_coordinate, texture[some_texture_unit_number], 2D;

  So we can avoid the multitexture constraint that the calculations can
  only access calculation result from previous texture unit.

- Interesting non-trivial fragment shader ability: KIL, so we can easily
  reject some pixels using any convoluted rule.

http://www.opengl.org/code/category/C20

Demos:
- see kambi_vrml_test_suite demos:
  - shaders.wrl
  - see specular_demo_phong_shading
  - see e.g. fountain VRML with toon shading applied
- see bump mapping in VRML engine, when bmGLSL, implemented using GLSL shaders
