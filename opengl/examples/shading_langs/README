Notes about shading languages:

http://en.wikipedia.org/wiki/Shading_language

------------------------------------------------------------------------------
Assembly shading languages:
- really old: NVidia register combiners
  http://developer.nvidia.com/object/registercombiners.html

  In some way, this is not a new language, it's only an extension to
  multitexturing, "programmed" by issuing appropriate OpenGL API calls,
  much like normal multitexturing.
  But with much more parameters and flexibility. So much that complexity
  of this qualifies it as an initial attempt at fragment programs.

- NVidia-specific ancestors of ARB langs below (don't use, use ARB now):
  NV_fragment_program
  http://www.opengl.org/registry/specs/NV/fragment_program.txt
  NV_vertex_program.txt
  http://oss.sgi.com/projects/ogl-sample/registry/NV/vertex_program.txt
  Very similar to ARB counterparts.

- blessed by ARB (standard in gl >= 2.0):
  ARB_vertex_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_program.txt
  ARB_fragment_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/fragment_program.txt

  http://en.wikipedia.org/wiki/ARB_%28GPU_assembly_language%29

  Very nice overview or ARB vertex/fragment assembly programs:
  http://www.ce.chalmers.se/edu/course/EDA425/lectures/shaders.pdf

  - Show OpenGL API to init them (glProgramStringARB and friends).
  - They replace fixed-functionality (show diagrams, x3d specs about shaders also).
  - We have OpenGL state available.
  - Vectors are "primitive" types for them, most instructions work on whole
    vectors component-wise, i.e. naturally SIMD model
    (actually multiple *shaders* even run in parallel, see "no jumps" note
    later).
  - Each instruction can, by the way, negate and/or swizzle it's arguments,
    that is we expect that negation and swizzling is "free" as far as
    speed is concerned.
  - Various normal math operations (sin/cos, log/lg2/exp/ex2/pow, add/sub,
    rcp/rsq, dp3/dp4).
  - Special for fragment: texture lookup (tex and friends).

    Note the "pipeline" requirement is not present in shaders.
    In one program I can access any texture coordinate and sample any texture.
    E.g. for ARB vertex program see fragment.texcoord[n], texture[n],
    operations like TEX, TXP.

      TEX some_result, some_coordinate, texture[some_texture_unit_number], 2D;

    So we can avoid the multitexture constraint that the calculations can
    only access calculation result from previous texture unit.

  - Note: no real "if" to make execution of shaders in parallel possible.
    There are only cheats like "CMP" - conditional copy,
      CMP result a b c
    means
      result := if a < 0 then b else c;
    or
      SLT result a b
    means
      result := if a < b then 1 else 0;
    Sure you can do tricks with this, actually you can emulate whole "if"
    (in the worst case, just set some variable based on the result of comparison,
    then perform both branches of "if", one after the other,
    multiply result if 1st branch with SLT result,
    multiply result if 2nd branch with (1-SLT result)).

    You can play with assembler languages, by compiling GLSL to it by cgc:
      cgc -oglsl -profile arbfp1 glsl_test.fs
    .. to see that this "if" compiles to "CMP" and "SLT".
    Example:

      void main()
      {
	if (gl_TexCoord[0].x > 0.5)
	  gl_FragColor = vec4(1, 1, 1, 1); else
	  gl_FragColor = vec4(0, 0, 0, 1);
      }

    =>

      PARAM c[1] = { { 1, 0, 0.5 } };
      TEMP R0;

      SLT R0.x, c[0].z, fragment.texcoord[0];
      # So R0.x = 1 means "0.5 < gl_TexCoord[0].x", that is 1st if branch
      # should be done. Otherwise it's R0.x = 0.

      ABS R0.x, R0;
      # This is useless ? Most probably this is a common "combo" of instructions
      # together with compare below.

      CMP R0.x, -R0, c[0].y, c[0];
      # last arg "c[0]" actually is equivalent to "c[0].x", since we use
      # only the 1st component of the vector (because result is only 1 component).
      # So this is equivalent to
      #   CMP R0.x, -R0.x, 0, 1;
      # So
      #   if -R0.x < 0 then R0.x = 0 else R0.x = 1
      # so (consider R0.x is either 0 or 1)
      #   if R0.x = 1 then R0.x = 0 else R0.x = 1
      # IOW, this was *really* convoluted way to say "R0.x := 1 - R0.x;"

      CMP result.color, -R0.x, c[0].yyyx, c[0].x;
      # "-R0.x < 0" still means just "R0.x = 1". So if that's the truth,
      # set result.color to (0, 0, 0, 1) otherwise (1, 1, 1, 1).

      END

    As usual, we could write better assembler code by hand, as we see
    that "ABS" was useless and actually "R0.x := 1 - R0.x;" was useless
    too (I could just swap the operands of CMP). So I can shorten this to:

      PARAM c[1] = { { 1, 0, 0.5 } };
      TEMP R0;

      SLT R0.x, c[0].z, fragment.texcoord[0];
      CMP result.color, -R0.x, c[0].x, c[0].yyyx;

      END

  - Since no jumps, loops can be done by unrolling --- so don't depend
    on long running loops.
    Actually, simple shaders should probably avoid using loops, or use them
    only to iterate over a couple of light sources etc.

    See how glsl_test_loop.fs is compiled.

  - Interesting fragment shader instructions: KIL, so we can easily
    reject some pixels using any convoluted rule.

------------------------------------------------------------------------------
Higher-level shading languages:

They all merge fragment and vertex langs in one syntax (well, much like
assembly langs actually). What's even more
important, allows vertex program to easily pass arguments
to vertex program. (API creates one shader program to which you
can attach vertex and/or fragment programs, that will communicate).
At least at the beginning, they were just compiled to assembly langs
(but nowadays they probably are more built-in, or compiled to something
internal, more flexible than ARB vertex/fragment).

- NVidia Cg
  http://en.wikipedia.org/wiki/Cg_%28programming_language%29

  "C for graphics". High-level, also C-like. One advantage is that this is also
  usable for Direct X, assuming anyone cares.
  Although cgc can be used to compile GLSL to any other output language
  (even Direct X one, it seems, although I didn't test).

  This language is not built inside OpenGL. It's compiled into
  other languages --- like ARB_vertex_program, ARB_fragment_program,
  GLSL vertex/fragment. You can also compile *from* GLSL.
  You need NVidia Cg toolkit for this.

  - Shader may be compiled by a developer, when developing the game ---
    this means that you compile to one or several chosen hardware profiles
    that you expect that your game will run on. Like
      cgc cg_sample.cg -profile arbvp1 -o vertex_program_from_cg_sample.txt

  - Or it can be compiled at your game runtime. This means that you
    distribute your game with actual Cg shader sources, and compile
    on user machine. This means that you compile precisely for the
    hardware that will run the shader, so you may get more optimizations.
    The disadvantage is that you must program it, to link and call Cg runtime
    functions to compile from your program.

- blessed by ARB (standard in gl >= 2.0, gl >= 2.1 requires GLSL >= 1.20),
  compiled into ARB assembly langs above:
  GLSL or glslang

  Many many tutorials and references around the WWW,
  http://www.opengl.org/documentation/glsl/
  http://www.lighthouse3d.com/opengl/glsl/
  http://folk.uio.no/johans/publications/Seland.2006.INF3320.pdf
  http://nehe.gamedev.net/data/articles/article.asp?article=21
  basically just
  http://www.google.com/search?q=glsl

  Note: be sure to test your GLSL not only on NVidia cards.
  NVidia GL tends to be forgiving to various malformed (but reasonable...)
  code, most probably because cgc also is forgiving and they use the same
  parser there, and cgc is forgiving because it was initially for Cg language.
  NVidia does eat every valid GLSL code, they just also often eat invalid GLSL
  code (with some Cg shortcuts / syntax).
  So if you develop on NVidia, be sure to test afterwards also on ATI/Mesa
  and fix eventual small things (like texture coords for texture2D functions
  should have ".st" qualifiers).

  Some lang notes:
  - No pointers obviously, so this stays a true high-level lang.
  - Vectors and matrices are primitive types.
    Well, actually matrices not so much (they are mostly arrays of vectors),
    but vectors still. E.g.
    vec4 <> float[4], vec4 is the primitive optimized type. You can access
    both arrays and vcetors using [index] syntax, but only vectors have
    special ".x" etc. syntax. E.g.

      float[4] v;
      v[0] = ...,
      v[1] = ...;

      vec4 v;
      v.xyz = ...;

    Reflects assembly shading langs underneath, and ability to "swizzle"
    vector components for free. E.g. in
    kambi_vrml_test_suite/vrml_2/kambi_extensions/shaders/glsl_some_deform.vs,
    initial code was
      v[0] += v[1];
      v[2] += v[1];
    but actually I can write this as faster
      v.xz += v.y;

  - int->float type promotion doesn't happen in all cases, e.g.
    vector * 4 incorrect (although tolerated by NVidia, watch out),
    vector * 4.0 correct.
  - functions, overloading, in, inout, out params.

  See kambi_vrml_test_suite/vrml_2/kambi_extensions/shaders/
  for demo how it's used from VRML.

  http://www.opengl.org/code/category/C20

------------------------------------------------------------------------------
More:

Demos:
- see kambi_vrml_test_suite demos:
  - shaders.wrl
  - see specular_demo_phong_shading
  - see e.g. fountain VRML with toon shading applied

- see bump mapping in VRML engine, when bmGLSL, implemented using GLSL shaders
