Notes about shading languages:

http://en.wikipedia.org/wiki/Shading_language

Assembly shading languages:
- blessed by ARB (standard in gl >= 2.0):
  ARB_vertex_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_program.txt
  ARB_fragment_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/fragment_program.txt

  http://en.wikipedia.org/wiki/ARB_%28GPU_assembly_language%29

- NVidia-specific ancestors of ARB langs above (don't use, use ARB now):
  NV_fragment_program
  http://www.opengl.org/registry/specs/NV/fragment_program.txt
  NV_vertex_program.txt
  http://oss.sgi.com/projects/ogl-sample/registry/NV/vertex_program.txt
  Very similar to ARB counterparts.

- even older: NVidia register combiners
  http://developer.nvidia.com/object/registercombiners.html

  In some way, this is not a new language, it's only an extension to
  multitexturing, "programmed" by issuing appropriate OpenGL API calls,
  much like normal multitexturing.
  But with much more parameters and flexibility. So much that complexity
  of this qualifies it as an initial attempt at fragment programs.

Higher-level shading languages:
- blessed by ARB (standard in gl >= 2.0, gl >= 2.1 requires GLSL >= 1.20),
  compiled into ARB assembly langs above:
  GLSL or glslang

  Merges fragment and vertex langs in one syntax. What's even more
  important, allows vertex program to easily pass arguments
  to vertex program. (API creates one shader program to which you
  can attach vertex and/or fragment programs, that will communicate).

- NVidia Cg
  http://en.wikipedia.org/wiki/Cg_%28programming_language%29

  Also high-level, also C-like. One advantage is that this is also
  usable for Direct X, assuming anyone cares.

  This language is not built inside OpenGL. It's compiled into
  other languages --- like ARB_vertex_program, ARB_fragment_program,
  GLSL vertex/fragment. You can also compile *from* GLSL.
  You need NVidia Cg toolkit for this.

  - Shader may be compiled by a developer, when developing the game ---
    this means that you compile to one or several chosen hardware profiles
    that you expect that your game will run on. Like
      cgc cg_sample.cg -profile arbvp1 -o vertex_program_from_cg_sample.txt

  - Or it can be compiled at your game runtime. This means that you
    distribute your game with actual Cg shader sources, and compile
    on user machine. This means that you compile precisely for the
    hardware that will run the shader, so you may get more optimizations.
    The disadvantage is that you must program it, to link and call Cg runtime
    functions to compile from your program.

Didn't check in practice, but the "pipeline" requirement seems not present
in ARB vertex program. In one program I can access any texture coordinate
and sample any texture. See fragment.texcoord[n], texture[n],
operations like TEX, TXP.

  TEX some_result, some_coordinate, texture[some_texture_unit_number], 2D;

So we can avoid the multitexture constraint that the calculations can
only access calculation result from previous texture unit.

Interesting non-trivial fragment shader ability: KIL, so we can easily
reject some pixels using any convoluted rule.

Very nice overview or ARB vertex/fragment assembly programs:
http://www.ce.chalmers.se/edu/course/EDA425/lectures/shaders.pdf

http://www.opengl.org/code/category/C20

TODO:
dl urls, GL 2.1, GLSL spec and wikipedia articles on chantal
install nvidia cg runtime
- vertex_program_from_cg_sample.txt doesn't work, seems I should pass him
  modelViewProjection matrix, it uses something called program.local ?