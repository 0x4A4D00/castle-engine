Notes about shading languages:

http://en.wikipedia.org/wiki/Shading_language

Assembly shading languages:
- blessed by ARB (standard in gl >= 2.0):
  ARB_vertex_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_program.txt
  ARB_fragment_program
  http://oss.sgi.com/projects/ogl-sample/registry/ARB/fragment_program.txt

  http://en.wikipedia.org/wiki/ARB_%28GPU_assembly_language%29

  Very nice overview or ARB vertex/fragment assembly programs:
  http://www.ce.chalmers.se/edu/course/EDA425/lectures/shaders.pdf

- NVidia-specific ancestors of ARB langs above (don't use, use ARB now):
  NV_fragment_program
  http://www.opengl.org/registry/specs/NV/fragment_program.txt
  NV_vertex_program.txt
  http://oss.sgi.com/projects/ogl-sample/registry/NV/vertex_program.txt
  Very similar to ARB counterparts.

- even older: NVidia register combiners
  http://developer.nvidia.com/object/registercombiners.html

  In some way, this is not a new language, it's only an extension to
  multitexturing, "programmed" by issuing appropriate OpenGL API calls,
  much like normal multitexturing.
  But with much more parameters and flexibility. So much that complexity
  of this qualifies it as an initial attempt at fragment programs.

Higher-level shading languages:
- blessed by ARB (standard in gl >= 2.0, gl >= 2.1 requires GLSL >= 1.20),
  compiled into ARB assembly langs above:
  GLSL or glslang

  Merges fragment and vertex langs in one syntax. What's even more
  important, allows vertex program to easily pass arguments
  to vertex program. (API creates one shader program to which you
  can attach vertex and/or fragment programs, that will communicate).

  Many many tutorials and references around the WWW,
  http://www.opengl.org/documentation/glsl/
  http://www.lighthouse3d.com/opengl/glsl/
  http://nehe.gamedev.net/data/articles/article.asp?article=21
  basically just
  http://www.google.com/search?q=glsl

  Note: be sure to test your GLSL not only on NVidia cards.
  NVidia GL tends to be forgiving to various malformed (but reasonable...)
  code, most probably because cgc also is forgiving and they use the same
  parser there, and cgc is forgiving because it was initially for Cg language.
  NVidia does eat every valid GLSL code, they just also often eat invalid GLSL
  code (with some Cg shortcuts / syntax).
  So if you develop on NVidia, be sure to test afterwards also on ATI/Mesa
  and fix eventual small things (like texture coords for texture2D functions
  should have ".st" qualifiers).

  See kambi_vrml_test_suite/vrml_2/kambi_extensions/shaders/
  for demo how it's used from VRML.

- NVidia Cg
  http://en.wikipedia.org/wiki/Cg_%28programming_language%29

  Also high-level, also C-like. One advantage is that this is also
  usable for Direct X, assuming anyone cares.

  This language is not built inside OpenGL. It's compiled into
  other languages --- like ARB_vertex_program, ARB_fragment_program,
  GLSL vertex/fragment. You can also compile *from* GLSL.
  You need NVidia Cg toolkit for this.

  - Shader may be compiled by a developer, when developing the game ---
    this means that you compile to one or several chosen hardware profiles
    that you expect that your game will run on. Like
      cgc cg_sample.cg -profile arbvp1 -o vertex_program_from_cg_sample.txt

  - Or it can be compiled at your game runtime. This means that you
    distribute your game with actual Cg shader sources, and compile
    on user machine. This means that you compile precisely for the
    hardware that will run the shader, so you may get more optimizations.
    The disadvantage is that you must program it, to link and call Cg runtime
    functions to compile from your program.

Didn't check in practice, but the "pipeline" requirement seems not present
in ARB vertex program. In one program I can access any texture coordinate
and sample any texture. See fragment.texcoord[n], texture[n],
operations like TEX, TXP.

  TEX some_result, some_coordinate, texture[some_texture_unit_number], 2D;

So we can avoid the multitexture constraint that the calculations can
only access calculation result from previous texture unit.

Interesting non-trivial fragment shader ability: KIL, so we can easily
reject some pixels using any convoluted rule.


http://www.opengl.org/code/category/C20
