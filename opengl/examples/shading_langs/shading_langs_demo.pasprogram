{
  Copyright 2007 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

program shading_langs_demo;

uses GLWindow, GLW_Navigated, KambiGLUtils,
  MatrixNavigation, Boxes3d, SysUtils, KambiUtils, VectorMath,
  KambiClassUtils, KambiFilesUtils, KambiStringUtils,
  GLWinMessages,  BFNT_BitstreamVeraSans_Unit, OpenGLBmpFonts,
  { Need to use newer FPC OpenGL headers. }
  GL, GLU, GLExt;

const
  SceneBoundingBox: TBox3d =
  ( (-8, -3, -3),
    ( 4,  3,  3) );

var
  Tex: array [0..1] of TGLuint;
  VertexProgId: TGLuint;

type
  TProgram = (pNone, pARBExtension, pStandard);

var
  VertexProgram, FragmentProgram: TProgram;

{ utilities ------------------------------------------------------------------ }

{ Comfortable shortcut for glGetProgramivARB that always returns 1 value. }
function glGetProgramiARB(target: TGLenum; pname: TGLenum): TGLint;
begin
  glGetProgramivARB(target, pname, @Result);
end;

procedure LoadVertexProgram(const S: string);
begin
  glProgramStringARB(GL_VERTEX_PROGRAM_ARB,
    GL_PROGRAM_FORMAT_ASCII_ARB, Length(S), PCharOrNil(S));

  { writeln currents and limits }
  Write(Format(
    'Number of instructions: %d / %d' +NL+
    'Number of temporaries: %d / %d' +NL+
    'Number of program parameter bindings: %d / %d' +NL,
    [ glGetProgramiARB(GL_VERTEX_PROGRAM_ARB, GL_MAX_PROGRAM_INSTRUCTIONS_ARB),
      glGetProgramiARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_INSTRUCTIONS_ARB),
      glGetProgramiARB(GL_VERTEX_PROGRAM_ARB, GL_MAX_PROGRAM_TEMPORARIES_ARB),
      glGetProgramiARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_TEMPORARIES_ARB),
      glGetProgramiARB(GL_VERTEX_PROGRAM_ARB, GL_MAX_PROGRAM_PARAMETERS_ARB),
      glGetProgramiARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_PARAMETERS_ARB) ]));
end;

{ glw callbacks ------------------------------------------------------------ }

procedure Draw(glwin: TGLWindow);

  { Draw cube using really old-fashioned approach (no vertex arrays,
    just specify by hand 6 quads, 4 vertexes and tex coords each). }
  procedure DrawCube;

    procedure TexCoord(const X, Y: Single);
    begin
      glTexCoord2f(X, Y);
    end;

  begin
    glBegin(GL_QUADS);
      glNormal3f( 0.0, 0.0, 1.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);

      glNormal3f( 0.0, 0.0,-1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);

      glNormal3f( 0.0, 1.0, 0.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0,  1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);

      glNormal3f( 0.0,-1.0, 0.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0, -1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);

      glNormal3f( 1.0, 0.0, 0.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);

      glNormal3f(-1.0, 0.0, 0.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
    glEnd();
  end;

  procedure DrawCubes;
  begin
    glPushMatrix;
      glTranslatef(-6, 0, 0);
      glBindTexture(GL_TEXTURE_2D, Tex[0]);
      glEnable(GL_TEXTURE_2D);

      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(-2, 0, 0);
      glBindTexture(GL_TEXTURE_2D, Tex[1]);
      glEnable(GL_TEXTURE_2D);

      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(+2, 0, 0);
      glDisable(GL_TEXTURE_2D);
      DrawCube;
    glPopMatrix;
  end;

begin
  glClear(GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(1, 1, 0, 1));
  glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(1, 1, 0, 1));

  DrawCubes;

  glTranslatef(0, 3, 0);
  glEnable(GL_VERTEX_PROGRAM_ARB);
  DrawCubes;
  glDisable(GL_VERTEX_PROGRAM_ARB);
end;

procedure Resize(glwin: TGLWindow);

  procedure UpdateNavigatorProjectionMatrix;
  var
    ProjectionMatrix: TMatrix4f;
  begin
    glGetFloatv(GL_PROJECTION_MATRIX, @ProjectionMatrix);
    if Glw.Navigator is TMatrixWalker then
      Glw.NavWalker.ProjectionMatrix := ProjectionMatrix;
  end;

begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height,
    Box3dAvgSize(SceneBoundingBox) * 0.05,
    Box3dAvgSize(SceneBoundingBox) * 20.0);

  { In case I'll use walker navigator at some time. }
  UpdateNavigatorProjectionMatrix;
end;

procedure InitGL(glwin: TGLWindow);

  function LoadTexture(const FileName: string): TGLuint;
  begin
    Result := LoadGLTexture(FileName, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR,
      GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);
  end;

const
  ProgramNames: array [TProgram] of string =
  ( 'None', 'ARBExtension', 'Standard' );
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);

  glLightModelv(GL_LIGHT_MODEL_AMBIENT, Vector4Single(0.8, 0.8, 0.8, 1.0));

  { TODO: fow now only pARBExtension works, not pStandard. }

  { initialize vertex program }
  { if Load_GL_version_2_0 then
    VertexProgram := pStandard else }
  if Load_GL_ARB_vertex_program then
    VertexProgram := pARBExtension else
    VertexProgram := pNone;
  Writeln('VertexProgram: ', ProgramNames[VertexProgram]);

  if VertexProgram = pARBExtension then
  begin
    glGenProgramsARB(1, @VertexProgId);
    glBindProgramARB(GL_VERTEX_PROGRAM_ARB, VertexProgId);
    LoadVertexProgram(FileToString('vertex_program_simulate_conventional.txt'));
  end;

  { initialize fragment program }
  { if Load_GL_version_2_0 then
    FragmentProgram := pStandard else }
  if Load_GL_ARB_fragment_program then
    FragmentProgram := pARBExtension else
    FragmentProgram := pNone;
  Writeln('FragmentProgram: ', ProgramNames[FragmentProgram]);

  Tex[0] := LoadTexture('../../../../castle/data/textures/023pierres.jpg');
  Tex[1] := LoadTexture('../../../../castle/data/textures/bridgerock512side.jpg');
end;

procedure CloseGL(glwin: TGLWindow);
begin
  if VertexProgram <> pNone then
  begin
    glDeleteProgramsARB(1, @VertexProgId);
  end;
end;

{ menu ----------------------------------------------------------------------- }

procedure MenuCommand(glwin: TGLWindow; MenuItem: TMenuItem);

  procedure LoadVertexProgramMenu;
  var
    S: string;
  begin
    S := '';
    if Glwin.FileDialog('Open file with vertex program', S, true) then
      LoadVertexProgram(FileToString(S));
  end;

begin
  case MenuItem.IntData of
    10: LoadVertexProgramMenu;
  end;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load new ARB vertex program', 10));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);
end;

{ main program --------------------------------------------------------------- }

begin
  { parse params }
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHigh(0);

  { init Glw.Navigator }
  Glw.Navigator := TMatrixExaminer.Create(@Glw.PostRedisplayOnMatrixChanged);
  Glw.NavExaminer.Init(SceneBoundingBox);

  Glw.MainMenu := CreateMainMenu;
  Glw.OnMenuCommand := @MenuCommand;

  Glw.OnInit := @InitGL;
  Glw.OnClose := @CloseGL;
  Glw.OnDraw := @Draw;
  Glw.OnResize := @Resize;
  Glw.InitLoop;
end.
