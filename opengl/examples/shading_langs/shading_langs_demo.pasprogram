{
  Copyright 2007 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Demo of using OpenGL shading languages (ARB vertex / fragment programs
  and high-level GLSL). All the OpenGL calls to handle these shaders
  are actually moved to separate unit, GLShaders, so if you want to see
  how to initialize OpenGL shaders --- see there.
}
program shading_langs_demo;

uses GLWindow, GLW_Navigated, KambiGLUtils,
  Navigation, Boxes3d, SysUtils, KambiUtils, VectorMath,
  KambiClassUtils, KambiFilesUtils, KambiStringUtils,
  GLWinMessages,  BFNT_BitstreamVeraSans_Unit, OpenGLBmpFonts,
  GLImages, GL, GLU, GLExt, GLShaders;

const
  SceneBoundingBox: TBox3d =
  ( (-8, -3, -3),
    ( 8,  15,  3) );

var
  Tex: array [0..1] of TGLuint;

  VertexProgram: TARBVertexProgram;
  FragmentProgram: TARBFragmentProgram;
  GLSLProgram: TGLSLProgram;

{ glw callbacks ------------------------------------------------------------ }

procedure Draw(glwin: TGLWindow);

  { Draw cube using really old-fashioned approach (no vertex arrays,
    just specify by hand 6 quads, 4 vertexes and tex coords each). }
  procedure DrawCube;

    procedure TexCoord(const X, Y: Single);
    begin
      glTexCoord2f(X, Y);
    end;

  begin
    glBegin(GL_QUADS);
      glNormal3f( 0.0, 0.0, 1.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);

      glNormal3f( 0.0, 0.0,-1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);

      glNormal3f( 0.0, 1.0, 0.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0,  1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);

      glNormal3f( 0.0,-1.0, 0.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0, -1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);

      glNormal3f( 1.0, 0.0, 0.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);

      glNormal3f(-1.0, 0.0, 0.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
    glEnd();
  end;

  procedure DrawCubes;
  var
    Q: PGLUQuadric;
  begin
    glPushMatrix;
      glTranslatef(-6, 0, 0);
      glBindTexture(GL_TEXTURE_2D, Tex[0]);
      glEnable(GL_TEXTURE_2D);

      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(-2, 0, 0);
      glBindTexture(GL_TEXTURE_2D, Tex[1]);
      glEnable(GL_TEXTURE_2D);

      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(+2, 0, 0);
      glDisable(GL_TEXTURE_2D);
      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(+6, 0, 0);
      glRotatef(-90, 1, 0, 0);
      Q := NewGLUQuadric(true, GLU_SMOOTH, GLU_OUTSIDE, GLU_FILL);
      try
        gluSphere(Q, 1, 20, 20);
      finally gluDeleteQuadric(Q) end;
    glPopMatrix;
  end;

begin
  glClear(GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT);

  glLoadIdentity;
  glLightv(GL_LIGHT0, GL_POSITION, Vector4Single(0, 0, 1));

  glLoadMatrix(Glw.Navigator.Matrix);

  glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(1, 1, 0, 1));
  glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(1, 1, 0, 1));
  glMaterialv(GL_FRONT_AND_BACK, GL_SPECULAR, Vector4Single(1, 1, 1, 1));
  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 20.0);

  DrawCubes;

  glTranslatef(0, 3, 0);
  if VertexProgram.Support <> gsNone then
  begin
    VertexProgram.Enable;
    DrawCubes;
    VertexProgram.Disable;
  end;

  glTranslatef(0, 3, 0);
  if FragmentProgram.Support <> gsNone then
  begin
    FragmentProgram.Enable;
    DrawCubes;
    FragmentProgram.Disable;
  end;

  glTranslatef(0, 3, 0);
  if (VertexProgram.Support <> gsNone) and
     (FragmentProgram.Support <> gsNone) then
  begin
    FragmentProgram.Enable;
    VertexProgram.Enable;
    DrawCubes;
    FragmentProgram.Disable;
    VertexProgram.Disable;
  end;

  glTranslatef(0, 3, 0);
  if GLSLProgram.Support <> gsNone then
  begin
    GLSLProgram.Enable;
    DrawCubes;
    GLSLProgram.Disable;
  end;
end;

procedure Resize(glwin: TGLWindow);

  procedure UpdateNavigatorProjectionMatrix;
  var
    ProjectionMatrix: TMatrix4f;
  begin
    glGetFloatv(GL_PROJECTION_MATRIX, @ProjectionMatrix);
    if Glw.Navigator is TWalkNavigator then
      Glw.WalkNav.ProjectionMatrix := ProjectionMatrix;
  end;

begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height,
    Box3dAvgSize(SceneBoundingBox) * 0.05,
    Box3dAvgSize(SceneBoundingBox) * 20.0);

  { In case I'll use walker navigator at some time. }
  UpdateNavigatorProjectionMatrix;
end;

procedure InitGL(glwin: TGLWindow);

  function LoadTexture(const FileName: string): TGLuint;
  const
    Wrap: TTextureWrap2D = (GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);  
  begin
    Result := LoadGLTexture(FileName, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, Wrap);
  end;

const
  GLSLProgramBaseName =
  //'glsl_simple'
  'glsl_toon_shading'
  //'glsl_phong_shading'
  ;
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);

  { This is to 0, just because vertex_program_simulate_conventional.txt
    doesn't simulate global ambient, so it would look different. }
  glLightModelv(GL_LIGHT_MODEL_AMBIENT, Vector4Single(0.0, 0.0, 0.0, 1.0));

  glClearColor(0.3, 0.3, 0.3, 1);

  { initialize vertex program }
  VertexProgram := TARBVertexProgram.Create;
  VertexProgram.Load(FileToString('vertex_program_simulate_conventional.txt'));
  Writeln(VertexProgram.DebugInfo);

  { initialize fragment program }
  FragmentProgram := TARBFragmentProgram.Create;
  FragmentProgram.Load(FileToString('fragment_program_simulate_conventional.txt'));
  Writeln(FragmentProgram.DebugInfo);

  { initialize GLSL program }
  GLSLProgram := TGLSLProgram.Create;
  GLSLProgram.AttachVertexShader(FileToString(GLSLProgramBaseName + '.vs'));
  GLSLProgram.AttachFragmentShader(FileToString(GLSLProgramBaseName + '.fs'));
  { For this test program, we eventually allow shader to run in software }
  GLSLProgram.Link(false);
  Writeln(GLSLProgram.DebugInfo);

  Tex[0] := LoadTexture('../../../../castle/data/textures/023pierres.jpg');
  Tex[1] := LoadTexture('../../../../castle/data/textures/bridgerock512side.jpg');
end;

procedure CloseGL(glwin: TGLWindow);
begin
  FreeAndNil(VertexProgram);
  FreeAndNil(FragmentProgram);
  FreeAndNil(GLSLProgram);
end;

{ menu ----------------------------------------------------------------------- }

procedure MenuCommand(glwin: TGLWindow; MenuItem: TMenuItem);

  procedure LoadVertexProgramMenu;
  var
    S: string;
  begin
    S := '';
    if Glwin.FileDialog('Open file with vertex program', S, true) then
    begin
      VertexProgram.Load(FileToString(S));
      Writeln(VertexProgram.DebugInfo);
    end;
  end;

  procedure LoadFragmentProgramMenu;
  var
    S: string;
  begin
    S := '';
    if Glwin.FileDialog('Open file with fragment program', S, true) then
    begin
      FragmentProgram.Load(FileToString(S));
      Writeln(FragmentProgram.DebugInfo);
    end;
  end;

  procedure LoadGLSLProgramMenu;
  const
    GLSL_FileFilters =
    'All files|*|' +
    '*GLSL vertex of fragment shader (*.vs, *.fs)|*.vs;*.fs';
  var
    S: string;
  begin
    S := '';
    if Glwin.FileDialog('Open file with GLSL vertex or fragment shader', S, true,
      GLSL_FileFilters) then
    begin
      GLSLProgram.DetachAllShaders;
      GLSLProgram.AttachVertexShader(FileToString(ChangeFileExt(S,'.vs')));
      GLSLProgram.AttachFragmentShader(FileToString(ChangeFileExt(S,'.fs')));
      { For this test program, we eventually allow shader to run in software }
      GLSLProgram.Link(false);
      Writeln(GLSLProgram.DebugInfo);
    end;
  end;

begin
  case MenuItem.IntData of
    10: LoadVertexProgramMenu;
    20: LoadFragmentProgramMenu;
    30: LoadGLSLProgramMenu;
  end;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load new ARB vertex program', 10));
    M.Append(TMenuItem.Create('Load new ARB fragment program', 20));
    M.Append(TMenuItem.Create('Load new GLSL program (vertex shader must have *.vs extension, fragment *.fs)', 30));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);
end;

{ main program --------------------------------------------------------------- }

begin
  { parse params }
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHigh(0);

  { init Glw.Navigator }
  Glw.Navigator := TExamineNavigator.Create(@Glw.PostRedisplayOnMatrixChanged);
  Glw.ExamineNav.Init(SceneBoundingBox);

  Glw.MainMenu := CreateMainMenu;
  Glw.OnMenuCommand := @MenuCommand;

  Glw.OnInit := @InitGL;
  Glw.OnClose := @CloseGL;
  Glw.OnDraw := @Draw;
  Glw.OnResize := @Resize;
  Glw.InitLoop;
end.
