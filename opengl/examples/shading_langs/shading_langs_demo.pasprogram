{
  Copyright 2007 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

program shading_langs_demo;

uses GLWindow, GLW_Navigated, KambiGLUtils,
  MatrixNavigation, Boxes3d, SysUtils, KambiUtils, VectorMath,
  KambiClassUtils, KambiFilesUtils, KambiStringUtils,
  GLWinMessages,  BFNT_BitstreamVeraSans_Unit, OpenGLBmpFonts,
  { Need to use newer FPC OpenGL headers. }
  GL, GLU, GLExt;

const
  SceneBoundingBox: TBox3d =
  ( (-8, -3, -3),
    ( 8,  15,  3) );

var
  Tex: array [0..1] of TGLuint;
  VertexProgId, FragmentProgId: TGLuint;

type
  TProgram = (pNone, pARBExtension, pStandard);

var
  VertexProgram, FragmentProgram, GLSLProgram: TProgram;
  GLSLProgramId, GLSLFragmentId, GLSLVertexId: TGLuint;

{ utilities ------------------------------------------------------------------ }

{ Comfortable shortcut for glGetProgramivARB that always returns 1 value. }
function glGetProgramiARB(target: TGLenum; pname: TGLenum): TGLint;
begin
  glGetProgramivARB(target, pname, @Result);
end;

procedure LoadProgram(Target: TGLenum; const S: string);
begin
  glProgramStringARB(Target,
    GL_PROGRAM_FORMAT_ASCII_ARB, Length(S), PCharOrNil(S));

  { writeln currents and limits }
  Write(Format(
    'Number of instructions: %d / %d' +NL+
    'Number of temporaries: %d / %d' +NL+
    'Number of program parameter bindings: %d / %d' +NL,
    [ glGetProgramiARB(Target, GL_MAX_PROGRAM_INSTRUCTIONS_ARB),
      glGetProgramiARB(Target, GL_PROGRAM_INSTRUCTIONS_ARB),
      glGetProgramiARB(Target, GL_MAX_PROGRAM_TEMPORARIES_ARB),
      glGetProgramiARB(Target, GL_PROGRAM_TEMPORARIES_ARB),
      glGetProgramiARB(Target, GL_MAX_PROGRAM_PARAMETERS_ARB),
      glGetProgramiARB(Target, GL_PROGRAM_PARAMETERS_ARB) ]));

  if glGetProgramiARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB) <> 0 then
    Writeln('Program fits within native limits, OK.') else
    Writeln('Program doesn''t fit within native limits, performance/quality will suffer!');
end;

{ glw callbacks ------------------------------------------------------------ }

procedure Draw(glwin: TGLWindow);

  { Draw cube using really old-fashioned approach (no vertex arrays,
    just specify by hand 6 quads, 4 vertexes and tex coords each). }
  procedure DrawCube;

    procedure TexCoord(const X, Y: Single);
    begin
      glTexCoord2f(X, Y);
    end;

  begin
    glBegin(GL_QUADS);
      glNormal3f( 0.0, 0.0, 1.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);

      glNormal3f( 0.0, 0.0,-1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);

      glNormal3f( 0.0, 1.0, 0.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0,  1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);

      glNormal3f( 0.0,-1.0, 0.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0, -1.0, -1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);

      glNormal3f( 1.0, 0.0, 0.0);
      TexCoord(1.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);
      TexCoord(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      TexCoord(0.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      TexCoord(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);

      glNormal3f(-1.0, 0.0, 0.0);
      TexCoord(0.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      TexCoord(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      TexCoord(1.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);
      TexCoord(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
    glEnd();
  end;

  procedure DrawCubes;
  var
    Q: PGLUQuadric;
  begin
    glPushMatrix;
      glTranslatef(-6, 0, 0);
      glBindTexture(GL_TEXTURE_2D, Tex[0]);
      glEnable(GL_TEXTURE_2D);

      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(-2, 0, 0);
      glBindTexture(GL_TEXTURE_2D, Tex[1]);
      glEnable(GL_TEXTURE_2D);

      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(+2, 0, 0);
      glDisable(GL_TEXTURE_2D);
      DrawCube;
    glPopMatrix;

    glPushMatrix;
      glTranslatef(+6, 0, 0);
      glRotatef(-90, 1, 0, 0);
      Q := NewGLUQuadric(GL_TRUE, GLU_SMOOTH, GLU_OUTSIDE, GLU_FILL);
      try
        gluSphere(Q, 1, 20, 20);
      finally gluDeleteQuadric(Q) end;
    glPopMatrix;
  end;

begin
  glClear(GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT);

  glLoadIdentity;
  glLightv(GL_LIGHT0, GL_POSITION, Vector4Single(0, 0, 1));

  glLoadMatrix(Glw.Navigator.Matrix);

  glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(1, 1, 0, 1));
  glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(1, 1, 0, 1));
  glMaterialv(GL_FRONT_AND_BACK, GL_SPECULAR, Vector4Single(1, 1, 1, 1));
  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 20.0);

  DrawCubes;

  glTranslatef(0, 3, 0);
  if VertexProgram = pARBExtension then
  begin
    glEnable(GL_VERTEX_PROGRAM_ARB);
    DrawCubes;
    glDisable(GL_VERTEX_PROGRAM_ARB);
  end;

  glTranslatef(0, 3, 0);
  if FragmentProgram = pARBExtension then
  begin
    glEnable(GL_FRAGMENT_PROGRAM_ARB);
    DrawCubes;
    glDisable(GL_FRAGMENT_PROGRAM_ARB);
  end;

  glTranslatef(0, 3, 0);
  if (VertexProgram = pARBExtension) and
     (FragmentProgram = pARBExtension) then
  begin
    glEnable(GL_FRAGMENT_PROGRAM_ARB);
    glEnable(GL_VERTEX_PROGRAM_ARB);
    DrawCubes;
    glDisable(GL_FRAGMENT_PROGRAM_ARB);
    glDisable(GL_VERTEX_PROGRAM_ARB);
  end;

  glTranslatef(0, 3, 0);
  if GLSLProgram = pStandard then
  begin
    glUseProgram(GLSLProgramId);
    DrawCubes;
    glUseProgram(0);
  end;
end;

procedure Resize(glwin: TGLWindow);

  procedure UpdateNavigatorProjectionMatrix;
  var
    ProjectionMatrix: TMatrix4f;
  begin
    glGetFloatv(GL_PROJECTION_MATRIX, @ProjectionMatrix);
    if Glw.Navigator is TMatrixWalker then
      Glw.NavWalker.ProjectionMatrix := ProjectionMatrix;
  end;

begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height,
    Box3dAvgSize(SceneBoundingBox) * 0.05,
    Box3dAvgSize(SceneBoundingBox) * 20.0);

  { In case I'll use walker navigator at some time. }
  UpdateNavigatorProjectionMatrix;
end;

procedure InitGL(glwin: TGLWindow);

  function LoadTexture(const FileName: string): TGLuint;
  begin
    Result := LoadGLTexture(FileName, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR,
      GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);
  end;

const
  ProgramNames: array [TProgram] of string =
  ( 'None', 'ARBExtension', 'Standard' );

  { Based on Dean Ellis BasicShader.dpr }
  function CreateShaderFromString(const S: string; AType: GLenum): TGLuint;

    { Based on Dean Ellis BasicShader.dpr, but somewhat fixed ? <> 0 not > 1. }
    function ShaderGetInfoLog(Shader: GLuint): String;
    var
      Len, Len2: TGLint;
     begin
      glGetShaderiv(Shader, GL_INFO_LOG_LENGTH, @Len);

      if Len <> 0 then
      begin
        SetLength(Result, Len);
        glGetShaderInfoLog(Shader, Len, @Len2, PChar(Result));
      end else
        Result := '';
    end;

  var
    SrcPtr: PChar;
    SrcLength: Cardinal;
    Compiled: TGLint;
  begin
    Result := glCreateShader(AType);
    SrcPtr := PChar(S);
    SrcLength := Length(S);
    glShaderSource(Result, 1, @SrcPtr, @SrcLength);
    glCompileShader(Result);
    glGetShaderiv(Result, GL_COMPILE_STATUS, @Compiled);
    if Compiled <> GL_TRUE then
      raise Exception.CreateFmt('Shader not compiled: %s',
        [ShaderGetInfoLog(Result)]);
  end;

  function CreateShaderFromFile(const FileName: string; AType: TGLenum): TGLuint;
  begin
    Result := CreateShaderFromString(FileToString(FileName), AType);
  end;

const
  GLSLProgramBaseName =
  //'glsl_simple'
  'glsl_toon_shading'
  ;
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);

  { This is to 0, just because vertex_program_simulate_conventional.txt
    doesn't simulate global ambient, so it would look different. }
  glLightModelv(GL_LIGHT_MODEL_AMBIENT, Vector4Single(0.0, 0.0, 0.0, 1.0));

  glClearColor(0.3, 0.3, 0.3, 1);

  { TODO: fow now only pARBExtension works, not pStandard. }

  { initialize vertex program }
  { if Load_GL_version_2_0 then
    VertexProgram := pStandard else }
  if Load_GL_ARB_vertex_program then
    VertexProgram := pARBExtension else
    VertexProgram := pNone;
  Writeln('VertexProgram: ', ProgramNames[VertexProgram]);

  if VertexProgram = pARBExtension then
  begin
    glGenProgramsARB(1, @VertexProgId);
    glBindProgramARB(GL_VERTEX_PROGRAM_ARB, VertexProgId);
    LoadProgram(GL_VERTEX_PROGRAM_ARB,
      FileToString('vertex_program_simulate_conventional.txt'));
  end;

  { initialize fragment program }
  { if Load_GL_version_2_0 then
    FragmentProgram := pStandard else }
  if Load_GL_ARB_fragment_program then
    FragmentProgram := pARBExtension else
    FragmentProgram := pNone;
  Writeln('FragmentProgram: ', ProgramNames[FragmentProgram]);

  if FragmentProgram = pARBExtension then
  begin
    glGenProgramsARB(1, @FragmentProgId);
    glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, FragmentProgId);
    LoadProgram(GL_FRAGMENT_PROGRAM_ARB,
      FileToString('fragment_program_simulate_conventional.txt'));
  end;

  { initialize GLSL program }
  { TODO: I should also try to init shader from ARB extension }
  if Load_GL_version_2_0 then
    GLSLProgram := pStandard else
  {if Load_GL_ARB_xxx then
    GLSLProgram := pARBExtension else }
    GLSLProgram := pNone;
  Writeln('GLSLProgram: ', ProgramNames[GLSLProgram]);

  if GLSLProgram = pStandard then
  begin
    GLSLProgramId := glCreateProgram();

    GLSLVertexId := CreateShaderFromFile(GLSLProgramBaseName + '.vert', GL_VERTEX_SHADER);
    GLSLFragmentId := CreateShaderFromFile(GLSLProgramBaseName + '.frag', GL_FRAGMENT_SHADER);

    glAttachShader(GLSLProgramId, GLSLVertexId);
    glAttachShader(GLSLProgramId, GLSLFragmentId);

    glLinkProgram(GLSLProgramId);
  end;

  Tex[0] := LoadTexture('../../../../castle/data/textures/023pierres.jpg');
  Tex[1] := LoadTexture('../../../../castle/data/textures/bridgerock512side.jpg');
end;

procedure CloseGL(glwin: TGLWindow);
begin
  if VertexProgram = pARBExtension then
    glDeleteProgramsARB(1, @VertexProgId);

  if FragmentProgram = pARBExtension then
    glDeleteProgramsARB(1, @FragmentProgId);

  if GLSLProgram = pStandard then
    glDeleteProgram(GLSLProgramId);
end;

{ menu ----------------------------------------------------------------------- }

procedure MenuCommand(glwin: TGLWindow; MenuItem: TMenuItem);

  procedure LoadVertexProgramMenu;
  var
    S: string;
  begin
    S := '';
    if Glwin.FileDialog('Open file with vertex program', S, true) then
      LoadProgram(GL_VERTEX_PROGRAM_ARB, FileToString(S));
  end;

  procedure LoadFragmentProgramMenu;
  var
    S: string;
  begin
    S := '';
    if Glwin.FileDialog('Open file with fragment program', S, true) then
      LoadProgram(GL_FRAGMENT_PROGRAM_ARB, FileToString(S));
  end;

begin
  case MenuItem.IntData of
    10: LoadVertexProgramMenu;
    20: LoadFragmentProgramMenu;
  end;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load new ARB vertex program', 10));
    M.Append(TMenuItem.Create('Load new ARB fragment program', 20));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);
end;

{ main program --------------------------------------------------------------- }

begin
  { parse params }
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHigh(0);

  { init Glw.Navigator }
  Glw.Navigator := TMatrixExaminer.Create(@Glw.PostRedisplayOnMatrixChanged);
  Glw.NavExaminer.Init(SceneBoundingBox);

  Glw.MainMenu := CreateMainMenu;
  Glw.OnMenuCommand := @MenuCommand;

  Glw.OnInit := @InitGL;
  Glw.OnClose := @CloseGL;
  Glw.OnDraw := @Draw;
  Glw.OnResize := @Resize;
  Glw.InitLoop;
end.
