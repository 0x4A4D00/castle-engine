{
  Copyright 2007 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

{ Bump mapping demo.
  Emboss and dot3 bump mapping.

  Keys:
  eE change scale of emboss effect.
  awsd change light position[x, y], qQ change light position[z]
  h switch emboss shift from automatic (from light in tangent space) to by hand
  ijkl change emboss shift (if in "by hand" mode)
  m changes bump mapping method (emboss / dot3 / dot3 inside vrml)
  b reverts EmbossAlphaMultiplyByBlending (means that only 2 texture units will be enough)
  n reverts NormalizedDot3First
  enter changes navigation mode (examiner / walker)

  Keys the same as [http://vrmlengine.sf.net/view3dscene.php] for examiner mode:
    page up, page down, arrows: rotate the scene
    space: stop rotating
    ctrl + page up, page down, arrows: move the scene
    + / -: scale the scene
    home: restore default rotation, translation and scale
  and for walker mode
    arrows, etc.: doom like walking, see view3dscene docs

  TODO: VRML demo here is a hack, just to show off bump mapping
  on non-trivial models.
  It will be removed soon, and this demo program will not depend
  on VRMLFlatSceneGL. VRML engine will get proper bump mapping
  handling, and VRMLs with bump mapping will be viewable in view3dscene.
}
program bump_mapping;

uses GLWindow, GLW_Navigated, OpenGLh, KambiGLUtils,
  MatrixNavigation, Boxes3d, SysUtils, KambiUtils, VectorMath,
  KambiClassUtils, KambiFilesUtils, KambiStringUtils,
  GLWinMessages,  BFNT_BitstreamVeraSans_Unit, OpenGLBmpFonts, Images, Keys,
  NormalizationCubeMap,

  VRMLFlatSceneGL, Object3dAsVRML, ProgressUnit, BackgroundGL;

const
  SceneBoundingBox: TBox3d =
  ( (-6, -4, -3),
    ( 14,  8,  3) );

type
  TBumpMethod = (bmEmboss, bmDot3, bmVRML);

var
  { normal texture is for all methods, bumps in alpha for emboss only }
  NormalAndBumpTex: array [0..3] of TGLuint;

  Font: TGLBitmapFont;

  LightPosition: TVector3Single = (0, 0, 2);

  Method: TBumpMethod = bmEmboss;

  MaxTextureUnits: Cardinal;

  RotatingColumn: Single;

  Examiner: TMatrixExaminer;
  Walker: TMatrixWalker;

  Scene: TVRMLFlatSceneGL;

  { Vars below for emboss only }

  LighterAndBumpTex: array [0..High(NormalAndBumpTex)] of TGLuint;

  XShift: Single = 0;
  YShift: Single = 0;
  ShiftByHand: boolean = false;

  BumpImageWidth, BumpImageHeight: Cardinal;

  EmbossScale: Single = 1;

  EmbossAlphaMultiplyByBlending: boolean = false;

  { Vars below for dot3 only }

  NormalMap: array [0..High(NormalAndBumpTex)] of TGLuint;

  NormalizationCubeTex: TGLuint;

  NormalizedDot3First: boolean = false;

{ Returns (unnormalized) direction from Vertex to LightPosition,
  in tangent space.

  In many articles, the vectors forming tangent space I called
    tangent
    binormal
    normal
  referring to the fact that one approach is to get normal and tangent
  from called, and binormal is just calculated by normal x tangent.
  I call them tangent = STangent, binormal = TTangent to make
  the meaning of them more clear (S, T are texture coordinates directions).
  Also, I don't calculate TTangent from cross product, I take it
  as a parameter: this allows me to use STangent, TTangent, Normal
  look like left handed coord system (this allows me to orient texture
  freely on the face, otherwise normal + STangent force the direction
  of texture T coordinate).

  ModelInvertedTransformation is the inverted transformation from the
  space where LightPosition is (this is world space) to object space,
  i.e. the one where Vertex is.

  Think like:
  - LightPosition                 is in world space
  - ModelTransformation * Vertex  is also in world space
  - Vertex                                        is in object space
  - so ModelInvertedTrasformation * LightPosition is in object space

  IOW, ModelInvertedTrasformation inverts all transformations
  applied after the point where we were in space where LightPosition was good,
  that is after
    glLightv(GL_LIGHT0, GL_POSITION, Vector4Single(LightPosition, 1))
  call.

  This is needed, since LightPositionObjectSpace is crucial for this procedure.
}
function LightDirectionInTangentSpace(
  const ModelInvertedTrasformation: TMatrix4Single;
  const Vertex, Normal, STangent, TTangent: TVector3Single): TVector3Single;
var
  ToTangent: TMatrix4Single;
  I: Integer;
  LightPositionObjectSpace: TVector3Single;
begin
  { We want to have LightPositionObjectSpace (in the same space where Vertex
    already is), as this is also the space where we expressed our STangent,
    TTangent, Normal vectors. "Tangent space" is for current face, such that
    XY run along surface's S,T texture coords. }

  LightPositionObjectSpace := MultMatrixPoint(ModelInvertedTrasformation,
    LightPosition);

  { first init 4th row and column }
  ToTangent := IdentityMatrix4Single;

  for I := 0 to 2 do
  begin
    ToTangent[I, 0] := STangent[I];
    ToTangent[I, 1] := TTangent[I];
    ToTangent[I, 2] := Normal[I];
  end;

  Result := MultMatrixPoint(ToTangent,
    VectorSubtract(LightPositionObjectSpace, Vertex));
end;

{ ----------------------------------------------------------------------------
  Various TTexCoordVertexProc implementations.
  They should set texture coord(s), and call glVertex(Vertex).
  And do whatever else is needed for current bump mapping method.
  LightDirTangent is direction from current vertex to light,
  already in tangent space, not normalized. }

type
  TTexCoordVertexProc = procedure (const TexX, TexY: Single;
    const Vertex: TVector3Single; LightDirTangent: TVector3Single);

procedure TexCoordVertex_NoBump(const TexX, TexY: Single;
  const Vertex: TVector3Single; LightDirTangent: TVector3Single);
begin
  glMultiTexCoord2fARB(GL_TEXTURE0_ARB, TexX, TexY);
  glVertexv(Vertex);
end;

procedure TexCoordVertex_Emboss(const TexX, TexY: Single;
  const Vertex: TVector3Single; LightDirTangent: TVector3Single);
begin
  if not ShiftByHand then
  begin
    LightDirTangent[2] := 0;
    NormalizeTo1st(LightDirTangent);
    XShift := EmbossScale * LightDirTangent[0] / BumpImageWidth;
    YShift := EmbossScale * LightDirTangent[1] / BumpImageHeight;
  end;

  glMultiTexCoord2fARB(GL_TEXTURE0_ARB, TexX         , TexY         );
  glMultiTexCoord2fARB(GL_TEXTURE1_ARB, TexX + XShift, TexY + YShift);

  glVertexv(Vertex);
end;

procedure TexCoordVertex_Dot3_NotNormalized(const TexX, TexY: Single;
  const Vertex: TVector3Single; LightDirTangent: TVector3Single);
begin
  NormalizeTo1st(LightDirTangent);

  { pass LightDirTangent as RGB color }
  glColor3f(( LightDirTangent[0] + 1) / 2,
            (-LightDirTangent[1] + 1) / 2,
            ( LightDirTangent[2] + 1) / 2);

  glMultiTexCoord2fARB(GL_TEXTURE0_ARB, TexX, TexY);
  glMultiTexCoord2fARB(GL_TEXTURE1_ARB, TexX, TexY);

  glVertexv(Vertex);
end;

procedure TexCoordVertex_Dot3_Normalized(const TexX, TexY: Single;
  const Vertex: TVector3Single; LightDirTangent: TVector3Single);
begin
  { no need to normalize LightDirTangent, it will be normalized at each
    fragment anyway by normalizing cube map }

  glMultiTexCoord3fARB(GL_TEXTURE0_ARB,
     LightDirTangent[0],
    -LightDirTangent[1],
     LightDirTangent[2]);
  glMultiTexCoord2fARB(GL_TEXTURE1_ARB, TexX, TexY);
  glMultiTexCoord2fARB(GL_TEXTURE2_ARB, TexX, TexY);

  glVertexv(Vertex);
end;

{ glw callbacks ------------------------------------------------------------ }

procedure Draw(glwin: TGLWindow);
var
  ModelInvertedTrasformation: TMatrix4Single;

  { glTranslate, and update ModelInvertedTrasformation }
  procedure Translate(const X, Y, Z: Single);
  begin
    glTranslatef(X, Y, Z);
    { On ModelInvertedTrasformation, we add new matrix on the left side,
      to revert also the order of operations. This way we really get
      proper inverse. }
    ModelInvertedTrasformation := MultMatrices(
      TranslationMatrix(-X, -Y, -Z),
      ModelInvertedTrasformation);
  end;

  { glRotate, and update ModelInvertedTrasformation }
  procedure Rotate(const Angle, X, Y, Z: Single);
  begin
    glRotatef(Angle, X, Y, Z);
    ModelInvertedTrasformation := MultMatrices(
      RotationMatrixDeg(-Angle, X, Y, Z),
      ModelInvertedTrasformation);
  end;

  { glPushMatrix, and return current ModelInvertedTrasformation }
  function PushMatrix: TMatrix4Single;
  begin
    glPushMatrix;
    Result := ModelInvertedTrasformation;
  end;

  { glPopMatrix, and set given ModelInvertedTrasformation }
  procedure PopMatrix(const SavedMatrix: TMatrix4Single);
  begin
    glPopMatrix;
    ModelInvertedTrasformation := SavedMatrix;
  end;

  { Draw cube using really old-fashioned approach (no vertex arrays,
    just specify by hand 6 quads, 4 vertexes and tex coords each). }
  procedure DrawCube(
    const TexCoordVertex: TTexCoordVertexProc);
  var
    Normal, STangent, TTangent: TVector3Single;

    procedure DoTexCoordVertex(const TexX, TexY: Single;
      const Vertex: TVector3Single);
    begin
      TexCoordVertex(TexX, TexY, Vertex,
        LightDirectionInTangentSpace(ModelInvertedTrasformation, Vertex,
          Normal, STangent, TTangent));
    end;

  begin
    glBegin(GL_QUADS);
      Normal  := Vector3Single( 0, 0, 1);
      STangent := Vector3Single( 1, 0, 0);
      TTangent := Vector3Single( 0, 1, 0);
      glNormalv(Normal);
      DoTexCoordVertex(0, 0, Vector3Single(-1, -1,  1));
      DoTexCoordVertex(1, 0, Vector3Single( 1, -1,  1));
      DoTexCoordVertex(1, 1, Vector3Single( 1,  1,  1));
      DoTexCoordVertex(0, 1, Vector3Single(-1,  1,  1));

      Normal  := Vector3Single( 0, 0,-1);
      STangent := Vector3Single(-1, 0, 0);
      TTangent := Vector3Single( 0, 1, 0);
      glNormalv(Normal);
      DoTexCoordVertex(1, 0, Vector3Single(-1, -1, -1));
      DoTexCoordVertex(1, 1, Vector3Single(-1,  1, -1));
      DoTexCoordVertex(0, 1, Vector3Single( 1,  1, -1));
      DoTexCoordVertex(0, 0, Vector3Single( 1, -1, -1));

      Normal  := Vector3Single( 0, 1, 0);
      STangent := Vector3Single( 1, 0, 0);
      TTangent := Vector3Single( 0, 0, -1);
      glNormalv(Normal);
      DoTexCoordVertex(0, 1, Vector3Single(-1,  1, -1));
      DoTexCoordVertex(0, 0, Vector3Single(-1,  1,  1));
      DoTexCoordVertex(1, 0, Vector3Single( 1,  1,  1));
      DoTexCoordVertex(1, 1, Vector3Single( 1,  1, -1));

      Normal  := Vector3Single( 0,-1, 0);
      STangent := Vector3Single(-1, 0, 0);
      TTangent := Vector3Single( 0, 0, -1);
      glNormalv(Normal);
      DoTexCoordVertex(1, 1, Vector3Single(-1, -1, -1));
      DoTexCoordVertex(0, 1, Vector3Single( 1, -1, -1));
      DoTexCoordVertex(0, 0, Vector3Single( 1, -1,  1));
      DoTexCoordVertex(1, 0, Vector3Single(-1, -1,  1));

      Normal  := Vector3Single( 1, 0, 0);
      STangent := Vector3Single( 0, 0,-1);
      TTangent := Vector3Single( 0, 1, 0);
      glNormalv(Normal);
      DoTexCoordVertex(1, 0, Vector3Single( 1, -1, -1));
      DoTexCoordVertex(1, 1, Vector3Single( 1,  1, -1));
      DoTexCoordVertex(0, 1, Vector3Single( 1,  1,  1));
      DoTexCoordVertex(0, 0, Vector3Single( 1, -1,  1));

      Normal  := Vector3Single(-1, 0, 0);
      STangent := Vector3Single( 0, 0, 1);
      TTangent := Vector3Single( 0, 1, 0);
      glNormalv(Normal);
      DoTexCoordVertex(0, 0, Vector3Single(-1, -1, -1));
      DoTexCoordVertex(1, 0, Vector3Single(-1, -1,  1));
      DoTexCoordVertex(1, 1, Vector3Single(-1,  1,  1));
      DoTexCoordVertex(0, 1, Vector3Single(-1,  1, -1));
    glEnd();
  end;

  procedure Test(TextureNum: Integer);

    procedure SetTexturesForEmboss(ShowRealBump, Modulate: boolean);
    var
      Tex: TGLuint;
    begin
      if Modulate then
        Tex := LighterAndBumpTex[TextureNum] else
        Tex := NormalAndBumpTex[TextureNum];

      glActiveTextureARB(GL_TEXTURE0_ARB);
      glBindTexture(GL_TEXTURE_2D, Tex);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);
      { only alpha 0.5 is important below }
      glTexEnvv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, Vector4Single(0, 0, 0, 0.5));

      { Texture unit 0 RGB calculates normal texturing (PRIMARY_COLOR
        modulate with TEXTURE in this unit). }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

      { Texture unit 0 alpha loads bump map (not shifted) value.
        *Loads*, i.e. it's not mixed with PRIMARY_COLOR in any way. }
      if Modulate then
        { I add 0.5 here, so that original bump is in 0.5...1.0
          range, and subtraction will give us result in 0.0..1.0,
          where 0.5 = no difference between shifted bumps. }
        glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_ADD) else
        { SOURCE1 and OPERAND1 will be ignored in this case. }
        glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_EXT, GL_CONSTANT_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA_EXT, GL_SRC_ALPHA);

      glActiveTextureARB(GL_TEXTURE1_ARB);
      { Load Tex again, as it has bump in the alpha
        channel. Don't care about RGB channels of texture loaded here,
        they will not be used. }
      glBindTexture(GL_TEXTURE_2D, Tex);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { Texture unit 1 RGB simply passes the result forward, no modifications.
        This step is only to subtract bump maps. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);

      { Texture unit 1 alpha does subtraction: from previous result
        (unshifted bump) subtract shifted bump. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_SUBTRACT);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA_EXT, GL_SRC_ALPHA);

      { Now we have RGB and alpha color that should be multiplied for the final
        color. We want to keep 1-pass approach, so I see two ways to solve this:

        1. Use another texture unit, with no texture bound to it,
           only to perform this operation.

           As a bonus, we can use this to grab alpha value from PRIMARY_COLOR
           and simply put it here. This way you can use your "normal" alpha
           from color/material, e.g. for doing partially transparent materials
           using blending.

        2. On older (but still reasonable ?) hardware, you may have
           only 2 texture units.

           - On kocury (newer NVidia: GeForce FX 5200): 4
           - On ii.107 (poor Radeon (GL_VERSION : 1.4.5469 WinXP Release so really old drivers)): 8
           - On chantal (Radeon don't remeber, MacBookPro): 8
           - On ii.137: TODO
           - On kocur.ii (older NVidia: GeForce4 MX 440): 2, indeed
           - On crypto.ii (Radeon X300): 8
           - Mesa on kocury: TODO

           Then you can use blending to multiply incoming color by it's own
           incoming alpha with glBlendFunc(GL_SRC_ALPHA, GL_ZERO).
           This means that you lose the ability to do partial transparency,
           as you lost alpha from your PRIMARY_COLOR --- but you keep 1-pass
           method, which is crucial.

        You could also make this into 2-pass method, it's probably even possible
        to do this without EXT_texture_env_combine (only ARB_multitexture).
        But since EXT_texture_env_combine and ARB_multitexture should be
        pretty much commonly found (OpenGL >= 1.3), I don't see much point for
        more elaborate tricks. }

      if not EmbossAlphaMultiplyByBlending then
      begin
        glActiveTextureARB(GL_TEXTURE2_ARB);
        { Hm, funny, actually I have to bind *any* texture here
          (it's values will not be used by equation on this texture unit),
          otherwise this texture unit is always off. }
        glBindTexture(GL_TEXTURE_2D, Tex);
        glEnable(GL_TEXTURE_2D);
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

        if ShowRealBump then
        begin
          if Modulate then
            glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE) else
            glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_ADD);

          glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
          glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
          glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_PREVIOUS_EXT);
          glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_ALPHA);
        end else
        begin
          { just for test: show the current alpha values
            (subtracted bumps) }
          glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);
          glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
          glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_ALPHA);
        end;

        glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_REPLACE);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_PRIMARY_COLOR_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
      end;
    end;

    procedure DrawEmbossCubes;
    var
      SavedMatrix: TMatrix4Single;
    begin
      { bump_amount * normal_color, with lighter textures }

      if not EmbossAlphaMultiplyByBlending then
      begin
        SetTexturesForEmboss(false, true);

        SavedMatrix := PushMatrix;
          Translate(+0, 0, 0);
          DrawCube(@TexCoordVertex_Emboss);
        PopMatrix(SavedMatrix);
      end;

      SetTexturesForEmboss(true, true);

      if EmbossAlphaMultiplyByBlending then
      begin
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ZERO);
      end;

      SavedMatrix := PushMatrix;
        Translate(+4, 0, 0);
        DrawCube(@TexCoordVertex_Emboss);
      PopMatrix(SavedMatrix);

      SavedMatrix := PushMatrix;
        Translate(+8, 0, 0);
        { Rotate just to show that lightdir tangent calculation works }
        Rotate(RotatingColumn, 0, 1, 0);
        DrawCube(@TexCoordVertex_Emboss);
      PopMatrix(SavedMatrix);

      if EmbossAlphaMultiplyByBlending then
        glDisable(GL_BLEND);

      { bump_amount + normal_color hack }

      if not EmbossAlphaMultiplyByBlending then
      begin
        SetTexturesForEmboss(false, false);

        SavedMatrix := PushMatrix;
          Translate(+12, 0, 0);
          DrawCube(@TexCoordVertex_Emboss);
        PopMatrix(SavedMatrix);

        SetTexturesForEmboss(true, false);

        SavedMatrix := PushMatrix;
          Translate(+16, 0, 0);
          DrawCube(@TexCoordVertex_Emboss);
        PopMatrix(SavedMatrix);
      end;
    end;

    procedure SetTexturesForDot3NotNormalized;
    begin
      glActiveTextureARB(GL_TEXTURE0_ARB);
      glBindTexture(GL_TEXTURE_2D, NormalMap[TextureNum]);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { texture unit 0: make dot between PRIMARY_COLOR and
        current texture (normal map). IOW, calculate diffuse factor. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_DOT3_RGB_ARB);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

      glActiveTextureARB(GL_TEXTURE1_ARB);
      { We bind NormalAndBumpTex, although actually we don't use
        bump stored there as alpha channel (they are only for emboss
        method). }
      glBindTexture(GL_TEXTURE_2D, NormalAndBumpTex[TextureNum]);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { texture unit 1: multiply diffuse factor by texture value. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

      if MaxTextureUnits > 2 then
      begin
        { texture unit 2 not used. }
        glActiveTextureARB(GL_TEXTURE2_ARB);
        glDisable(GL_TEXTURE_2D);
      end;
    end;

    procedure SetTexturesForDot3Normalized;
    begin
      { texture unit 0: just lookup your coordinates (which are
        3D lighting dir, not normalized) in cube map.
        This calculates normalized lighting dir. }
      glActiveTextureARB(GL_TEXTURE0_ARB);
      glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, NormalizationCubeTex);
      glEnable(GL_TEXTURE_CUBE_MAP_ARB);
      { make sure GL_TEXTURE_2D is disabled here (other bump mapping
        methods could enable this) }
      glDisable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);

      glActiveTextureARB(GL_TEXTURE1_ARB);
      glBindTexture(GL_TEXTURE_2D, NormalMap[TextureNum]);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { texture unit 1: make dot between previous (light dir normalized) and
        current texture (normal map). IOW, calculate diffuse factor. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_DOT3_RGB_ARB);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

      glActiveTextureARB(GL_TEXTURE2_ARB);
      { We bind NormalAndBumpTex, although actually we don't use
        bump stored there as alpha channel (they are only for emboss
        method). }
      glBindTexture(GL_TEXTURE_2D, NormalAndBumpTex[TextureNum]);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { texture unit 1: multiply diffuse factor by texture value. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);
    end;

    procedure DrawDot3Cubes;
    var
      Dot3Normalized, Dot3NotNormalized: TGLfloat;
      SavedMatrix: TMatrix4Single;
    begin
      if NormalizedDot3First then
      begin
        Dot3Normalized := 0;
        Dot3NotNormalized := 4;
      end else
      begin
        Dot3NotNormalized := 0;
        Dot3Normalized := 4;
      end;

      SetTexturesForDot3NotNormalized;

      glDisable(GL_LIGHTING);
      glColorv(White3Single);

      SavedMatrix := PushMatrix;
        Translate(Dot3NotNormalized, 0, 0);
        DrawCube(@TexCoordVertex_Dot3_NotNormalized);
      PopMatrix(SavedMatrix);

      if MaxTextureUnits > 2 then
      begin
        SetTexturesForDot3Normalized;

        SavedMatrix := PushMatrix;
          Translate(Dot3Normalized, 0, 0);
          DrawCube(@TexCoordVertex_Dot3_Normalized);
        PopMatrix(SavedMatrix);

        SavedMatrix := PushMatrix;
          Translate(8, 0, 0);
          { Rotate just to show that lightdir tangent calculation works }
          Rotate(RotatingColumn, 0, 1, 0);
          DrawCube(@TexCoordVertex_Dot3_Normalized);
        PopMatrix(SavedMatrix);

        { clean after ourselves, otherwise we'd have to call
          glDisable(GL_TEXTURE_CUBE_MAP_ARB) everywhere where we
          enable GLTEXTURE_2D.
          TODO: push/pop tex environments to make this cleaner. }
        glActiveTextureARB(GL_TEXTURE0_ARB);
        glDisable(GL_TEXTURE_CUBE_MAP_ARB);
      end;

      glEnable(GL_LIGHTING);
    end;

  var
    SavedMatrix: TMatrix4Single;
  begin
    { texture unit 0 contains normal texture value mixed with scene color }
    glActiveTextureARB(GL_TEXTURE0_ARB);
    glBindTexture(GL_TEXTURE_2D, NormalAndBumpTex[TextureNum]);
    glEnable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

    { texture unit 1 not used. }
    glActiveTextureARB(GL_TEXTURE1_ARB);
    glDisable(GL_TEXTURE_2D);

    { texture unit 2 not used. }
    if MaxTextureUnits > 2 then
    begin
      glActiveTextureARB(GL_TEXTURE2_ARB);
      glDisable(GL_TEXTURE_2D);
    end;

    SavedMatrix := PushMatrix;
      Translate(-4, 0, 0);
      DrawCube(@TexCoordVertex_NoBump);
    PopMatrix(SavedMatrix);

    case Method of
      bmEmboss: DrawEmbossCubes;
      bmDot3: DrawDot3Cubes;
      else raise EInternalError.Create('method?');
    end;
  end;

  procedure DisableTextures;
  begin
    glActiveTextureARB(GL_TEXTURE0_ARB);
    glDisable(GL_TEXTURE_2D);

    glActiveTextureARB(GL_TEXTURE1_ARB);
    glDisable(GL_TEXTURE_2D);

    if MaxTextureUnits > 2 then
    begin
      glActiveTextureARB(GL_TEXTURE2_ARB);
      glDisable(GL_TEXTURE_2D);
    end;

    { reset as active 0 texture unit, to be in default state }
    glActiveTextureARB(GL_TEXTURE0_ARB);
  end;

  procedure RenderStatus;
  var
    S: string;
  const
    MethodNames: array [TBumpMethod] of string = ('emboss', 'dot3', 'dot3 in VRML');
  begin
    glPushAttrib(GL_ENABLE_BIT);
      glDisable(GL_DEPTH_TEST);
      glDisable(GL_LIGHTING);
      DisableTextures;

      glColorv(Yellow3Single);

      S := //Format('FPS : %f (real : %f)' +nl, [Glw.FpsFrameTime, Glw.FpsRealTime]);
        '' { fps on caption };
      S += 'Method: ' + MethodNames[Method] + nl;
      if ShiftByHand then
        S += Format('Shift: %f %f' +nl, [XShift, YShift]) else
        S += 'Shift automatic from tangent space light position' +nl;
      S += Format('Dot3 normalized first (for quick visual compare): %s', [BoolToStr[NormalizedDot3First]]) +nl;
      S += Format('Emboss scale: %f', [EmbossScale]) +nl;
      S += Format('Emboss alpha multiply by blending: %s',
        [BoolToStr[EmbossAlphaMultiplyByBlending]]);

      Font.Projection2DPrintStrings(5, 5, S);
    glPopAttrib;
  end;

begin
  glClear(GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT);

  DisableTextures;

  if Method = bmVRML then
  begin
    glLoadMatrix(Glw.Navigator.RotationOnlyMatrix);
    Scene.Background.Render;
  end;

  glLoadMatrix(Glw.Navigator.Matrix);

  if (Method = bmEmboss) and
    (glGetInteger(GL_MAX_TEXTURE_UNITS_ARB) < 3) then
  begin
    { You can't have emboss with not EmbossAlphaMultiplyByBlending
      on this hardware. }
    EmbossAlphaMultiplyByBlending := true;
  end;

  glLightv(GL_LIGHT0, GL_POSITION, Vector4Single(LightPosition, 1));

  glPushAttrib(GL_ENABLE_BIT);
    glDisable(GL_LIGHTING);

    glColorv(Yellow3Single);
    glBegin(GL_POINTS);
      glVertexv(LightPosition);
    glEnd;
  glPopAttrib;

  if Method = bmVRML then
  begin
    Scene.Attributes.BumpMappingLightPosition := LightPosition;
    if Glw.Navigator = Walker then
      Scene.RenderFrustumOctree(Glw.NavWalker.Frustum, tgAll) else
      Scene.Render(nil, tgAll);
  end else
  begin
    ModelInvertedTrasformation := IdentityMatrix4Single;

    glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(1, 1, 1, 1));
    glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(1, 1, 1, 1));

    Translate(0,-4, 0);
    Test(2);

    Translate(0, 4, 0);
    Test(0);

    Translate(0, 4, 0);
    Test(1);

    Translate(0, 4, 0);
    Test(3);
  end;

  RenderStatus;
end;

procedure Resize(glwin: TGLWindow);

  procedure UpdateNavigatorProjectionMatrix;
  var
    ProjectionMatrix: TMatrix4f;
  begin
    glGetFloatv(GL_PROJECTION_MATRIX, @ProjectionMatrix);
    Walker.ProjectionMatrix := ProjectionMatrix;
  end;

var
  ProjectionNear, ProjectionFar: Single;
begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionNear := Box3dAvgSize(SceneBoundingBox) * 0.05;
  ProjectionFar := Box3dAvgSize(SceneBoundingBox) * 20.0;
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height,
    ProjectionNear, ProjectionFar);

  Scene.BackgroundSkySphereRadius :=
    TBackgroundGL.NearFarToSkySphereRadius(
      ProjectionNear, ProjectionFar);

  { In case I use walker navigator. }
  UpdateNavigatorProjectionMatrix;
end;

procedure InitGL(glwin: TGLWindow);
const
  MinFilter = GL_LINEAR_MIPMAP_LINEAR;
  MagFilter = GL_LINEAR;

  procedure LoadTextureBumpMap(const BaseFileName, BumpFileName: string;
    var Tex: TGLuint);
  var
    BaseImage: TRGBImage;
    BumpImage: TGrayscaleImage;
    Image: TAlphaImage;
  begin
    BaseImage := nil;
    BumpImage := nil;
    Image := nil;
    try
      BaseImage := LoadImage('textures/' + BaseFileName,
        [TRGBImage], []) as TRGBImage;

      BumpImage := LoadImage('textures/' + BumpFileName,
        [TGrayscaleImage], []) as TGrayscaleImage;
      BumpImage.HalfColors;
      BumpImageWidth := BumpImage.Width;
      BumpImageHeight := BumpImage.Height;

      Image := TAlphaImage.Create;
      Image.Compose(BaseImage, BumpImage);

      Tex := LoadGLTexture(Image, MinFilter, MagFilter,
        GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);

      { BumpTex := LoadGLTexture(BumpImage, MinFilter, MagFilter,
        GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE, true); }
    finally
      FreeAndNil(BaseImage);
      FreeAndNil(BumpImage);
      FreeAndNil(Image);
    end;
  end;

  procedure LoadNormalMap(const FileName: string;
    var Tex: TGLuint);
  begin
    { This is quite simple... }
    Tex := LoadGLTexture('textures/' + FileName, MinFilter, MagFilter,
      GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);
  end;

begin
  Check(GL_EXT_texture_env_combine, 'EXT_texture_env_combine required');
  Check(GL_ARB_multitexture, 'ARB_multitexture required');
  Check(GLVersion.AtLeast(1, 3), 'GL 1.3 >= required for GL_SUBTRACT');
  Check(GL_ARB_texture_env_dot3, 'ARB_texture_env_dot3 required (for dot3 method)');
  Check(GL_ARB_texture_cube_map, 'ARB_texture_cube_map required (for dot3 corrected method)');

  MaxTextureUnits := glGetInteger(GL_MAX_TEXTURE_UNITS_ARB);

  Check(MaxTextureUnits >= 2, 'At least 2 texture units required for dot3 (for emboss, 3 texture units)');

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);

  glLightModelv(GL_LIGHT_MODEL_AMBIENT, Vector4Single(0.5, 0.5, 0.5, 1.0));

  glClearColor(0.3, 0.3, 0.3, 1);

  glPointSize(10);

  LoadTextureBumpMap('brick_1.png'      , 'brick_1_bump.png', NormalAndBumpTex[0]);
  LoadTextureBumpMap('brick_1_light.png', 'brick_1_bump.png', LighterAndBumpTex[0]);
  LoadNormalMap('brick_1_normalmap.png', NormalMap[0]);

  LoadTextureBumpMap('brick_2.png'      , 'brick_2_bump.png', NormalAndBumpTex[1]);
  LoadTextureBumpMap('brick_2_light.png', 'brick_2_bump.png', LighterAndBumpTex[1]);
  LoadNormalMap('brick_2_normalmap.png', NormalMap[1]);

  LoadTextureBumpMap('brick_1.png'      , 'brick_1_bump_better.png', NormalAndBumpTex[2]);
  LoadTextureBumpMap('brick_1_light.png', 'brick_1_bump_better.png', LighterAndBumpTex[2]);
  LoadNormalMap('brick_1_normalmap_worse.png', NormalMap[2]);

  LoadTextureBumpMap('shell.png'      , 'shell_bump.png', NormalAndBumpTex[3]);
  LoadTextureBumpMap('shell.png'      , 'shell_bump.png', LighterAndBumpTex[3]);
  LoadNormalMap('shell_normalmap.jpg', NormalMap[3]);

  NormalizationCubeTex := MakeNormalizationCubeMap;

  Font := TGLBitmapFont.Create(@BFNT_BitstreamVeraSans);

  Scene := TVRMLFlatSceneGL.Create(LoadAsVRML(
    '../../../../castle/data/levels/fountain/fountain_bumpdemo_final.wrl', true),
    true, roNone);
  { for RenderFrustumOctree }
  Progress.UserInterface := ProgressNullInterface;
  Scene.DefaultShapeStateOctree :=
    Scene.CreateShapeStateOctree('Building ShapeState octree');
  Scene.Attributes.BumpMapping := true;
end;

procedure CloseGL(glwin: TGLWindow);
begin
  FreeAndNil(Font);
  FreeAndNil(Scene);
end;

procedure Idle(glwin: TGLWindow);
begin
  if Glwin.KeysDown[K_A] then LightPosition[0] -= Glwin.IdleCompSpeed / 10;
  if Glwin.KeysDown[K_D] then LightPosition[0] += Glwin.IdleCompSpeed / 10;
  if Glwin.KeysDown[K_S] then LightPosition[1] -= Glwin.IdleCompSpeed / 10;
  if Glwin.KeysDown[K_W] then LightPosition[1] += Glwin.IdleCompSpeed / 10;

  if Glwin.KeysDown[K_Q] then
  begin
    if mkShift in Glwin.ModifiersDown then
      LightPosition[2] += Glwin.IdleCompSpeed / 10 else
      LightPosition[2] -= Glwin.IdleCompSpeed / 10;
  end;

  if Glwin.KeysDown[K_J] then XShift -= Glwin.IdleCompSpeed / 1000;
  if Glwin.KeysDown[K_L] then XShift += Glwin.IdleCompSpeed / 1000;
  if Glwin.KeysDown[K_K] then YShift -= Glwin.IdleCompSpeed / 1000;
  if Glwin.KeysDown[K_I] then YShift += Glwin.IdleCompSpeed / 1000;

  if Glwin.KeysDown[K_E] then
  begin
    if mkShift in Glwin.ModifiersDown then
      EmbossScale -= Glwin.IdleCompSpeed / 10 else
      EmbossScale += Glwin.IdleCompSpeed / 10;
  end;

  RotatingColumn += Glwin.IdleCompSpeed / 5;
end;

procedure KeyDown(Glwin: TGLWindow; Key: TKey; C: char);
var
  CamPos, CamDir, CamUp, GravityUp: TVector3Single;
begin
  case C of
    'h': ShiftByHand := not ShiftByHand;
    'm':
      begin
        if Method = High(Method) then
          Method := Low(Method) else
          Method := Succ(Method);
        if Method = bmVRML then
        begin
          { some preparations for bmVRML, to make it look better.
            Like all VRML code here, don't look at this: this is only
            a hack to show off VRML with bump mapping, will be implemented
            much nicer in view3dscene later. }

          LightPosition := Vector3Single(3, 3, 5);

          Scene.GetPerspectiveViewpoint(CamPos, CamDir, CamUp, GravityUp);
          Walker.Init(CamPos,
            VectorAdjustToLength(CamDir, Box3dAvgSize(Scene.BoundingBox) * 0.01*0.4),
            CamUp, GravityUp,
            0.0, 0.0 { unused, we don't use Gravity here });
        end;
      end;
    'b': EmbossAlphaMultiplyByBlending := not EmbossAlphaMultiplyByBlending;
    'n': NormalizedDot3First := not NormalizedDot3First;
    CharEnter:
      if Glw.Navigator = Examiner then
        Glw.Navigator := Walker else
        Glw.Navigator := Examiner;
  end;
end;

begin
  { parse params }
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHigh(0);

  { init Glw.Navigator }
  Examiner := TMatrixExaminer.Create(@Glw.PostRedisplayOnMatrixChanged);
  Examiner.Init(SceneBoundingBox);

  Walker := TMatrixWalker.Create(@Glw.PostRedisplayOnMatrixChanged);
  Walker.Init(Vector3Single(0, 0, 10), Vector3Single(0, 0, -1),
    Vector3Single(0, 1, 0), Vector3Single(0, 1, 0),
    0.0, 0.0 { unused, we don't use Gravity here });

  Glw.OwnsNavigator := false;
  Glw.Navigator := Examiner;

  try
    Glw.AutoRedisplay := true; { for easy Idle code }
    Glw.OnInit := @InitGL;
    Glw.OnClose := @CloseGL;
    Glw.OnDraw := @Draw;
    Glw.OnResize := @Resize;
    Glw.OnIdle := @Idle;
    Glw.OnKeyDown := @KeyDown;
    Glw.InitLoop;
  finally
    FreeAndNil(Walker);
    FreeAndNil(Examiner);
  end;
end.
