{
  Copyright 2007 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

{ Bump mapping demo.
  Emboss bump mapping for now.

  Keys:

  eE change scale of emboss effect.
  lL change light position.
  rR change light radius.
  h switch emboss shift from automatic (from light in tangent space) to by hand
  awsd change emboss shift (if in "by hand" mode)
  m changes emboss method

  Examine mode keys from [http://vrmlengine.sf.net/view3dscene.php]:
    page up, page down, arrows: rotate the scene
    space: stop rotating
    ctrl + page up, page down, arrows: move the scene
    + / -: scale the scene
    home: restore default rotation, translation and scale
 }

program bump_mapping;

uses GLWindow, GLW_Navigated, OpenGLh, KambiGLUtils,
  MatrixNavigation, Boxes3d, SysUtils, KambiUtils, VectorMath,
  KambiClassUtils, KambiFilesUtils, KambiStringUtils,
  GLWinMessages,  BFNT_BitstreamVeraSans_Unit, OpenGLBmpFonts, Images, Keys;

const
  SceneBoundingBox: TBox3d =
  ( (-5, -5, -3),
    ( 14,  5,  3) );

type
  TBumpMethod = (bmEmboss, bmDot3);

var
  { normal texture is for all methods, bumps in alpha for emboss only }
  NormalAndBumpTex: array [0..2] of TGLuint;

  Font: TGLBitmapFont;

  LightPosition: TVector3Single;
  LightRotation: Single = 0;
  LightRadius: Single = 3;

  Method: TBumpMethod = bmEmboss;

  MaxTextureUnits: Cardinal;

  { Vars below for emboss only }

  LighterAndBumpTex: array [0..2] of TGLuint;

  XShift: Single = 0;
  YShift: Single = 0;
  ShiftByHand: boolean = false;

  BumpImageWidth, BumpImageHeight: Cardinal;

  EmbossScale: Single = 1;

  { Vars below for dot3 only }

  NormalMap: array [0..2] of TGLuint;

{ Returns (unnormalized) direction from Vertex to LightPosition,
  in tangent space.

  ModelviewMatrix is used to transform Vertex,
  LightPosition will be transformed by Glw.Navigator.Matrix
  (following the way we render them; the idea is that we want
  to have their positions in world space). }
function LightDirectionInTangentSpace(
  const ModelviewMatrix: TMatrix4Single;
  const Vertex, Normal, Tangent: TVector3Single): TVector3Single;
var
  ToTangent: TMatrix4Single;
  I: Integer;
  Binormal, VertexWorldSpace, LightPositionWorldSpace: TVector3Single;
begin
  VertexWorldSpace := MultMatrixPoint(ModelviewMatrix, Vertex);
  LightPositionWorldSpace := MultMatrixPoint(Glw.Navigator.Matrix, LightPosition);

  Binormal := VectorProduct(Normal, Tangent);

  { first init 4th row and column }
  ToTangent := IdentityMatrix4Single;

  for I := 0 to 2 do
  begin
    ToTangent[I, 0] := Tangent[I];
    ToTangent[I, 1] := Binormal[I];
    ToTangent[I, 2] := Normal[I];
  end;

  Result := MultMatrixPoint(ToTangent,
    VectorSubtract(LightPositionWorldSpace, VertexWorldSpace));
end;

{ glw callbacks ------------------------------------------------------------ }

procedure Draw(glwin: TGLWindow);

  { Draw cube using really old-fashioned approach (no vertex arrays,
    just specify by hand 6 quads, 4 vertexes and tex coords each). }
  procedure DrawCube;
  var
    Normal: TVector3Single;
    Tangent: TVector3Single;

    ModelviewMatrix: TMatrix4Single;

    procedure TexCoordVertex(const TexX, TexY: Single;
      const Vertex: TVector3Single);
    var
      L: TVector3Single;
    begin
      case Method of
        bmEmboss:
        begin
          if not ShiftByHand then
          begin
            L := LightDirectionInTangentSpace(ModelviewMatrix, Vertex, Normal, Tangent);
            L[2] := 0;
            NormalizeTo1st(L);
            XShift := EmbossScale * L[0] / BumpImageWidth;
            YShift := EmbossScale * L[1] / BumpImageHeight;
          end;

          glMultiTexCoord2fARB(GL_TEXTURE0_ARB, TexX         , TexY         );
          glMultiTexCoord2fARB(GL_TEXTURE1_ARB, TexX + XShift, TexY + YShift);
        end;

        bmDot3:
        begin
          L := LightDirectionInTangentSpace(ModelviewMatrix, Vertex, Normal, Tangent);
          NormalizeTo1st(L);

          { put L as RGB color }
          glColor3f((L[0] + 1) / 2,
                    (L[1] + 1) / 2,
                    (L[2] + 1) / 2);

          glMultiTexCoord2fARB(GL_TEXTURE0_ARB, TexX, TexY);
          glMultiTexCoord2fARB(GL_TEXTURE1_ARB, TexX, TexY);
        end;
      end;

      glVertexv(Vertex);
    end;

  begin
    glGetFloatv(GL_MODELVIEW_MATRIX, @ModelviewMatrix);

    glBegin(GL_QUADS);
      Normal  := Vector3Single( 0, 0, 1);
      Tangent := Vector3Single( 1, 0, 0);
      glNormalv(Normal);
      TexCoordVertex(0, 0, Vector3Single(-1, -1,  1));
      TexCoordVertex(1, 0, Vector3Single( 1, -1,  1));
      TexCoordVertex(1, 1, Vector3Single( 1,  1,  1));
      TexCoordVertex(0, 1, Vector3Single(-1,  1,  1));

      Normal  := Vector3Single( 0, 0,-1);
      Tangent := Vector3Single(-1, 0, 0);
      glNormalv(Normal);
      TexCoordVertex(1, 0, Vector3Single(-1, -1, -1));
      TexCoordVertex(1, 1, Vector3Single(-1,  1, -1));
      TexCoordVertex(0, 1, Vector3Single( 1,  1, -1));
      TexCoordVertex(0, 0, Vector3Single( 1, -1, -1));

      Normal  := Vector3Single( 0, 1, 0);
      Tangent := Vector3Single( 1, 0, 0);
      glNormalv(Normal);
      TexCoordVertex(0, 1, Vector3Single(-1,  1, -1));
      TexCoordVertex(0, 0, Vector3Single(-1,  1,  1));
      TexCoordVertex(1, 0, Vector3Single( 1,  1,  1));
      TexCoordVertex(1, 1, Vector3Single( 1,  1, -1));

      Normal  := Vector3Single( 0,-1, 0);
      Tangent := Vector3Single(-1, 0, 0);
      glNormalv(Normal);
      TexCoordVertex(1, 1, Vector3Single(-1, -1, -1));
      TexCoordVertex(0, 1, Vector3Single( 1, -1, -1));
      TexCoordVertex(0, 0, Vector3Single( 1, -1,  1));
      TexCoordVertex(1, 0, Vector3Single(-1, -1,  1));

      Normal  := Vector3Single( 1, 0, 0);
      Tangent := Vector3Single( 0, 0,-1);
      glNormalv(Normal);
      TexCoordVertex(1, 0, Vector3Single( 1, -1, -1));
      TexCoordVertex(1, 1, Vector3Single( 1,  1, -1));
      TexCoordVertex(0, 1, Vector3Single( 1,  1,  1));
      TexCoordVertex(0, 0, Vector3Single( 1, -1,  1));

      Normal  := Vector3Single(-1, 0, 0);
      Tangent := Vector3Single( 0, 0, 1);
      glNormalv(Normal);
      TexCoordVertex(0, 0, Vector3Single(-1, -1, -1));
      TexCoordVertex(1, 0, Vector3Single(-1, -1,  1));
      TexCoordVertex(1, 1, Vector3Single(-1,  1,  1));
      TexCoordVertex(0, 1, Vector3Single(-1,  1, -1));
    glEnd();
  end;

  procedure Test(TextureNum: Integer);

    procedure SetTexturesForEmboss(ShowRealBump, Modulate: boolean);
    var
      Tex: TGLuint;
    begin
      if Modulate then
        Tex := LighterAndBumpTex[TextureNum] else
        Tex := NormalAndBumpTex[TextureNum];

      glActiveTextureARB(GL_TEXTURE0_ARB);
      glBindTexture(GL_TEXTURE_2D, Tex);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);
      { only alpha 0.5 is important below }
      glTexEnvv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, Vector4Single(0, 0, 0, 0.5));

      { Texture unit 0 RGB calculates normal texturing (PRIMARY_COLOR
        modulate with TEXTURE in this unit). }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

      { Texture unit 0 alpha loads bump map (not shifted) value.
        *Loads*, i.e. it's not mixed with PRIMARY_COLOR in any way. }
      if Modulate then
        { I add 0.5 here, so that original bump is in 0.5...1.0
          range, and subtraction will give us result in 0.0..1.0,
          where 0.5 = no difference between shifted bumps. }
        glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_ADD) else
        { SOURCE1 and OPERAND1 will be ignored in this case. }
        glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_EXT, GL_CONSTANT_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA_EXT, GL_SRC_ALPHA);

      glActiveTextureARB(GL_TEXTURE1_ARB);
      { Load Tex again, as it has bump in the alpha
        channel. Don't care about RGB channels of texture loaded here,
        they will not be used. }
      glBindTexture(GL_TEXTURE_2D, Tex);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { Texture unit 1 RGB simply passes the result forward, no modifications.
        This step is only to subtract bump maps. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);

      { Texture unit 1 alpha does subtraction: from previous result
        (unshifted bump) subtract shifted bump. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_SUBTRACT);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA_EXT, GL_SRC_ALPHA);

      { Now we have RGB and alpha color that should be multiplied for the final
        color. We want to keep 1-pass approach, so I see two ways to solve this:

        1. Use another texture unit, with no texture bound to it,
           only to perform this operation.

           As a bonus, we can use this to grab alpha value from PRIMARY_COLOR
           and simply put it here. This way you can use your "normal" alpha
           from color/material, e.g. for doing partially transparent materials
           using blending.

        2. On older (but still reasonable ?) hardware, you may have
           only 2 texture units.

           - On kocury (newer NVidia: GeForce FX 5200): 4
           - On ii.107 (poor Radeon (GL_VERSION : 1.4.5469 WinXP Release so really old drivers)): 8
           - On chantal (Radeon don't remeber, MacBookPro): 8
           - On ii.137: TODO
           - On kocur.ii (older NVidia: GeForce4 MX 440): 2
           - On crypto.ii (Radeon X300): 8
           - Mesa on kocury: TODO

           Then you can use blending to multiply incoming color by it's own
           incoming alpha with glBlendFunc(GL_SRC_ALPHA, GL_ZERO). (TODO: untested)
           This means that you lose the ability to do partial transparency,
           as you lost alpha from your PRIMARY_COLOR --- but you keep 1-pass
           method, which is crucial.

        You could also make this into 2-pass method, it's probably even possible
        to do this without EXT_texture_env_combine (only ARB_multitexture).
        But since EXT_texture_env_combine and ARB_multitexture should be
        pretty much commonly found (OpenGL >= 1.3), I don't see much point for
        more elaborate tricks. }

      glActiveTextureARB(GL_TEXTURE2_ARB);
      { Hm, funny, actually I have to bind *any* texture here
        (it's values will not be used by equation on this texture unit),
        otherwise this texture unit is always off. }
      glBindTexture(GL_TEXTURE_2D, Tex);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      if ShowRealBump then
      begin
        if Modulate then
          glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE) else
          glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_ADD);

        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_PREVIOUS_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_ALPHA);
      end else
      begin
        { just for test: show the current alpha values
          (subtracted bumps) }
        glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_ALPHA);
      end;

      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
    end;

    procedure DrawEmbossCubes;
    begin
      { bump_amount * normal_color, with lighter textures }

      SetTexturesForEmboss(false, true);

      glPushMatrix;
        glTranslatef(+0, 0, 0);
        DrawCube;
      glPopMatrix;

      SetTexturesForEmboss(true, true);

      //glDisable(GL_LIGHTING);
      //glColorv(White3Single);

      glPushMatrix;
        glTranslatef(+4, 0, 0);
        DrawCube;
      glPopMatrix;

      //glEnable(GL_LIGHTING);

      { bump_amount + normal_color hack }

      SetTexturesForEmboss(false, false);

      glPushMatrix;
        glTranslatef(+8, 0, 0);
        DrawCube;
      glPopMatrix;

      SetTexturesForEmboss(true, false);

      glPushMatrix;
        glTranslatef(+12, 0, 0);
        DrawCube;
      glPopMatrix;
    end;

    procedure SetTexturesForDot3;
    begin
      glActiveTextureARB(GL_TEXTURE0_ARB);
      glBindTexture(GL_TEXTURE_2D, NormalMap[TextureNum]);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { texture unit 0: make dot between PRIMARY_COLOR and
        current texture (normal map). IOW, calculate diffuse factor. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_DOT3_RGB_ARB);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

      glActiveTextureARB(GL_TEXTURE1_ARB);
      { We bind NormalAndBumpTex, although actually we don't use
        bump stored there as alpha channel (they are only for emboss
        method). }
      glBindTexture(GL_TEXTURE_2D, NormalAndBumpTex[TextureNum]);
      glEnable(GL_TEXTURE_2D);
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

      { texture unit 1: multiply diffuse factor by texture value. }
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);

      if MaxTextureUnits > 2 then
      begin
        { texture unit 2 not used. }
        glActiveTextureARB(GL_TEXTURE2_ARB);
        glDisable(GL_TEXTURE_2D);
      end;
    end;

    procedure DrawDot3Cubes;
    begin
      SetTexturesForDot3;

      glDisable(GL_LIGHTING);
      glColorv(White3Single);

      glPushMatrix;
        glTranslatef(+0, 0, 0);
        DrawCube;
      glPopMatrix;

      glEnable(GL_LIGHTING);
    end;

  begin
    { texture unit 0 contains normal texture value mixed with scene color }
    glActiveTextureARB(GL_TEXTURE0_ARB);
    glBindTexture(GL_TEXTURE_2D, NormalAndBumpTex[TextureNum]);
    glEnable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

    { texture unit 1 not used. }
    glActiveTextureARB(GL_TEXTURE1_ARB);
    glDisable(GL_TEXTURE_2D);

    { texture unit 2 not used. }
    if MaxTextureUnits > 2 then
    begin
      glActiveTextureARB(GL_TEXTURE2_ARB);
      glDisable(GL_TEXTURE_2D);
    end;

    glPushMatrix;
      glTranslatef(-4, 0, 0);
      DrawCube;
    glPopMatrix;

    case Method of
      bmEmboss: DrawEmbossCubes;
      bmDot3: DrawDot3Cubes;
      else raise EInternalError.Create('method?');
    end;
  end;

  procedure DisableTextures;
  begin
    glActiveTextureARB(GL_TEXTURE0_ARB);
    glDisable(GL_TEXTURE_2D);

    glActiveTextureARB(GL_TEXTURE1_ARB);
    glDisable(GL_TEXTURE_2D);

    if MaxTextureUnits > 2 then
    begin
      glActiveTextureARB(GL_TEXTURE2_ARB);
      glDisable(GL_TEXTURE_2D);
    end;
  end;

  procedure RenderStatus;
  var
    S: string;
  const
    MethodNames: array [TBumpMethod] of string = ('emboss', 'dot3');
  begin
    glPushAttrib(GL_ENABLE_BIT);
      glDisable(GL_DEPTH_TEST);
      glDisable(GL_LIGHTING);
      DisableTextures;

      glColorv(Yellow3Single);

      S := //Format('FPS : %f (real : %f)' +nl, [Glw.FpsFrameTime, Glw.FpsRealTime]);
        '' { fps on caption };
      S += 'Method: ' + MethodNames[Method] + nl;
      if ShiftByHand then
        S += Format('Shift: %f %f' +nl, [XShift, YShift]) else
        S += 'Shift automatic from tangent space light position' +nl;
      S += Format('Emboss scale: %f', [EmbossScale]);

      Font.Projection2DPrintStrings(5, 5, S);
    glPopAttrib;
  end;

begin
  glClear(GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  if (Method = bmEmboss) and
    (glGetInteger(GL_MAX_TEXTURE_UNITS_ARB) < 3) then
    Method := bmDot3;

  glLightv(GL_LIGHT0, GL_POSITION, Vector4Single(LightPosition, 1));

  glPushAttrib(GL_ENABLE_BIT);
    glDisable(GL_LIGHTING);
    DisableTextures;

    glColorv(Yellow3Single);
    glBegin(GL_POINTS);
      glVertexv(LightPosition);
    glEnd;
  glPopAttrib;

  glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(1, 1, 1, 1));
  glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(1, 1, 1, 1));

  glPushMatrix;
    glTranslatef(0, -4, 0);
    Test(2);
  glPopMatrix;

  glPushMatrix;
    glTranslatef(0, +0, 0);
    Test(0);
  glPopMatrix;

  glPushMatrix;
    glTranslatef(0, +4, 0);
    Test(1);
  glPopMatrix;

  RenderStatus;
end;

procedure Resize(glwin: TGLWindow);

  procedure UpdateNavigatorProjectionMatrix;
  var
    ProjectionMatrix: TMatrix4f;
  begin
    glGetFloatv(GL_PROJECTION_MATRIX, @ProjectionMatrix);
    if Glw.Navigator is TMatrixWalker then
      Glw.NavWalker.ProjectionMatrix := ProjectionMatrix;
  end;

begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height,
    Box3dAvgSize(SceneBoundingBox) * 0.05,
    Box3dAvgSize(SceneBoundingBox) * 20.0);

  { In case I'll use walker navigator at some time. }
  UpdateNavigatorProjectionMatrix;
end;

procedure UpdateLightPosition;
begin
  LightPosition[0] := cos(LightRotation) * LightRadius;
  LightPosition[1] := sin(LightRotation) * LightRadius;
  LightPosition[2] := 2;
end;

procedure InitGL(glwin: TGLWindow);
const
{  MinFilter = GL_NEAREST;
  MagFilter = GL_NEAREST;}

  // TODO: restore normal mapping ? are they OK ?
  MinFilter = GL_LINEAR_MIPMAP_LINEAR;
  MagFilter = GL_LINEAR;

  procedure LoadTextureBumpMap(const BaseFileName, BumpFileName: string;
    var Tex: TGLuint);
  var
    BaseImage: TRGBImage;
    BumpImage: TGrayscaleImage;
    Image: TAlphaImage;
  begin
    BaseImage := nil;
    BumpImage := nil;
    Image := nil;
    try
      BaseImage := LoadImage(BaseFileName, [TRGBImage], []) as TRGBImage;

      BumpImage := LoadImage(BumpFileName, [TGrayscaleImage], []) as TGrayscaleImage;
      BumpImage.HalfColors;

      BumpImageWidth := BumpImage.Width;
      BumpImageHeight := BumpImage.Height;

      Image := TAlphaImage.Create;
      Image.Compose(BaseImage, BumpImage);

      Tex := LoadGLTexture(Image, MinFilter, MagFilter,
        GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);

      { BumpTex := LoadGLTexture(BumpImage, MinFilter, MagFilter,
        GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE, true); }
    finally
      FreeAndNil(BaseImage);
      FreeAndNil(BumpImage);
      FreeAndNil(Image);
    end;
  end;

  procedure LoadNormalMap(const FileName: string;
    var Tex: TGLuint);
  begin
    { for now this is simple... }
    Tex := LoadGLTexture(FileName, MinFilter, MagFilter,
      GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);
  end;

begin
  Check(GL_EXT_texture_env_combine, 'EXT_texture_env_combine required');
  Check(GL_ARB_multitexture, 'ARB_multitexture required');
  Check(GLVersion.AtLeast(1, 3), 'GL 1.3 >= required for GL_SUBTRACT');
  Check(GL_ARB_texture_env_dot3, 'ARB_texture_env_dot3 required (for dot3 method)');

  MaxTextureUnits := glGetInteger(GL_MAX_TEXTURE_UNITS_ARB);

  Check(MaxTextureUnits >= 2, 'At least 2 texture units required for dot3 (for emboss, 3 texture units)');

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);

  glLightModelv(GL_LIGHT_MODEL_AMBIENT, Vector4Single(0.5, 0.5, 0.5, 1.0));

  glClearColor(0.3, 0.3, 0.3, 1);

  glPointSize(10);

  LoadTextureBumpMap('brick_1.png'      , 'brick_1_bump.png', NormalAndBumpTex[0]);
  LoadTextureBumpMap('brick_1_light.png', 'brick_1_bump.png', LighterAndBumpTex[0]);

  LoadTextureBumpMap('brick_2.png'      , 'brick_2_bump.png', NormalAndBumpTex[1]);
  LoadTextureBumpMap('brick_2_light.png', 'brick_2_bump.png', LighterAndBumpTex[1]);

  LoadTextureBumpMap('brick_1.png'      , 'brick_1_bump_better.png', NormalAndBumpTex[2]);
  LoadTextureBumpMap('brick_1_light.png', 'brick_1_bump_better.png', LighterAndBumpTex[2]);

  { TODO: I use one normal map for all, totally unrelated to model }
  LoadNormalMap('normal_map.jpg', NormalMap[0]);
  { for now, these are the same }
  NormalMap[1] := NormalMap[0];
  NormalMap[2] := NormalMap[0];

  Font := TGLBitmapFont.Create(@BFNT_BitstreamVeraSans);

  UpdateLightPosition;
end;

procedure CloseGL(glwin: TGLWindow);
begin
  FreeAndNil(Font);
end;

procedure Idle(glwin: TGLWindow);
begin
  if Glwin.KeysDown[K_A] then XShift -= Glwin.IdleCompSpeed / 1000;
  if Glwin.KeysDown[K_D] then XShift += Glwin.IdleCompSpeed / 1000;
  if Glwin.KeysDown[K_S] then YShift -= Glwin.IdleCompSpeed / 1000;
  if Glwin.KeysDown[K_W] then YShift += Glwin.IdleCompSpeed / 1000;

  if Glwin.KeysDown[K_L] then
  begin
    if mkShift in Glwin.ModifiersDown then
      LightRotation -= Glwin.IdleCompSpeed / 10 else
      LightRotation += Glwin.IdleCompSpeed / 10;
    UpdateLightPosition;
  end;

  if Glwin.KeysDown[K_R] then
  begin
    if mkShift in Glwin.ModifiersDown then
      LightRadius -= Glwin.IdleCompSpeed / 10 else
      LightRadius += Glwin.IdleCompSpeed / 10;
    UpdateLightPosition;
  end;

  if Glwin.KeysDown[K_E] then
  begin
    if mkShift in Glwin.ModifiersDown then
      EmbossScale -= Glwin.IdleCompSpeed / 10 else
      EmbossScale += Glwin.IdleCompSpeed / 10;
    UpdateLightPosition;
  end;
end;

procedure KeyDown(Glwin: TGLWindow; Key: TKey; C: char);
begin
  case C of
    'h': ShiftByHand := not ShiftByHand;
    'm': if Method = High(Method) then
           Method := Low(Method) else
           Method := Succ(Method);
  end;
end;

begin
  { parse params }
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHigh(0);

  { init Glw.Navigator }
  Glw.Navigator := TMatrixExaminer.Create(@Glw.PostRedisplayOnMatrixChanged);
  Glw.NavExaminer.Init(SceneBoundingBox);

  Glw.AutoRedisplay := true; { for easy Idle code }
  Glw.OnInit := @InitGL;
  Glw.OnClose := @CloseGL;
  Glw.OnDraw := @Draw;
  Glw.OnResize := @Resize;
  Glw.OnIdle := @Idle;
  Glw.OnKeyDown := @KeyDown;
  Glw.InitLoop;
end.
