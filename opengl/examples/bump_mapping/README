Bump mapping overview: brick wall.
Texturing: because obviously too costly to model each brick.
Bump mapping: increase the look, still without increasing geometric complexity.
Idea: normals change within. How about we store normals somehow in some texture
(to be able to vary them on pixel-by-pixel basis ?) ? This changes the look,
without changing the geometry.

------------------------------------------------------------------------------
GL_ARB_multitexture:

GL_ARB_multitexture avail from OpenGL 1.2.1, incorporated as standard since
OpenGL 1.3.

http://www.opengl.org/wiki/index.php/GL_ARB_multitexture - short.
http://www.berkelium.com/OpenGL/GDC99/multitexture.html - nice intro.
Multiple textures, mixed freely - multiple uses.
Common (first ?) example: lightmaps in GLQuake.
First, historically, "ARB" extension (reviewed by ARB, as opposed to EXT
that are popular and accepted but not necessarily reviewed). ARB essentially
means "we think that this will definitely go into gl standard".

Separate texture units: separate coords, matrix (stack ? probably, but
TODO: not sure), environment, bound unit (although the same texture can
be bound to multiple channels; and yes, we will use this for emboss).
Set active unit:

glActiveTextureARB(GL_TEXTUREn_ARB); // 0 <= n < GL_MAX_TEXTURE_UNITS_ARB

Note that glTexCoord2f still affects only 0th texture (regardless
of glActiveTexture calls). To change coords for other textures, use

glMultiTexCoord2fARB(GL_TEXTUREn_ARB, x, y);
(so glTexCoord2f(x, y); is just a shortcut for
glMultiTexCoord2fARB(GL_TEXTURE0_ARB, x, y)).

One more: for client things (notably glEnableClientState(GL_TEXTURE_COORD_ARRAY))
there's glClientActiveTextureARB(GL_TEXTURE0_ARB) (analogous to
glActiveTextureARB(GL_TEXTURE0_ARB)). E.g.

  glClientActiveTextureARB(GL_TEXTURE1_ARB);
  glTexCoordPointer(2, GL_FLOAT, 0, tp1);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);

(This will be improved soon by GL_EXT_texture_env_combine, but for now,
state of GL_ARB_multitexture:)

Textures are mixed as specified by TEXTURE_ENV_MODE.
- interpolated pixel color (from vertex colors, that already include
  lights (materials, eventually colors set explicitly by glColor), fog).
- ... is mixed with texture 0 color. This is where we stop without multitexturing.
- ... the result above is mixed with texture 1 color.
- ... and so on, for each enabled texture unit.

See glTexEnv. For example, GL_MODULATE means (for texture RGB case)
that color is multipled component-wise by tex color. GL_ADD may be useful
for 2nd and further texture units.

Note that some equations still require multipass technique, e.g.
  A * B + C * D
(where A, B, C and D are 4 textures). Without multitetexturing, this
is not doable at all with screen rendering. Multipass doesn't help:
you could render A, then mutliply by B, then add C. Nothing to do with D...
With multitexturing, you can actually do (A * B + C) in one pass.
So you can do multitexturing with 2 passes, one pass does A*B and 2nd one adds C*D.

Naturally, it turns out that multitexturing allows us to do the same things
as multipass in the past. Multitexturing is just better (you have to transform,
rasterize, z-test, stencil-test etc. only once).

------------------------------------------------------------------------------
GL_EXT_texture_env_combine:

Emboss is (Bump - shifted(at runtime) Bump) * normal scene color.

Bump is one texture unit, "shifted(at runtime) Bump" goes to 2nd texture
unit. Actually, we can also invent ourselves, so "- shifted(at runtime) Bump"
goes to 2nd texture unit. Then texture env may use GL_ADD.
Actually, we can avoid precalculating inversion (saves texture memory)
since GL 1.3 gives us GL_SUBTRACT.
Also, note that we want (...) to be in 0..1 range. Right now it's in -1..1 range.
So scale / 2. Totally we have:
  0.5 + Bump/2 + (- shifted(at runtime) Bump/2)

Still, how to do this by 1-pass multutexturing ? At the beginning we have to
input "normal scene color", so no way to multiply by combined
"(Bump - shifted(at runtime) Bump)". Here's GL_EXT_texture_env_combine
useful.

GL_EXT_texture_env_combine
later
GL_ARB_texture_env_combine
later
standard in gl 1.3
1.3 also added GL_SUBTRACT, we will use it.

Idea:
glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
and then
glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_xxx, ...);
determine the actual computation.

GL_COMBINE_RGB,
GL_COMBINE_ALPHA,
           RGB_SCALE,
	   ALPHA_SCALE,
           SOURCE0_RGB,    OPERAND0_RGB,
	   SOURCE1_RGB,	   OPERAND1_RGB,
	   SOURCE2_RGB,	   OPERAND2_RGB,
	   SOURCE0_ALPHA,  OPERAND0_ALPHA,
	   SOURCE1_ALPHA,  OPERAND1_ALPHA,
	   SOURCE2_ALPHA   OPERAND2_ALPHA

Advantages of texture_env_combine
- you can specify RGB and ALPHA mixing orthogonally (old, classic modes for
  TEXTURE_ENV_MODE, like glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)
  specified both RGB and ALPHA methods at once).

- we have more modes,  like GL_SUBTRACT, GL_INTERPOLATE (one texture unit
  specifies interpolation between two other texture units, this uses three
  arguments).

- For each of 3 arguments, we have
  GL_COMBINE_SOURCEn_RGB, SOURCEn_ALPHA,
             OPERANDn_RGB, OPERANDn_ALPHA

  SOURCEn values tell from where to take this (from fragment unmodified color
  PRIMARY_COLOR (as normal for 0th texture unit), from previous texture
  PREVIOUS (as normal for > 0th texture units), from constant color,
  explicitly selected texture unit, currently bound texture unit...).

  OPERANDn values allow you to additionally transform the value.
  Usually, it's GL_SRC_COLOR or GL_SRC_ALPHA for OPERANDn_RGB, OPERANDn_ALPHA,
  but you can also change them. This allows you to mix RGB+Alpha to, well,
  RGB and/or alpha of this texture unit.

Since SOURCEn may point to any texture unit, not only to "current unit",
we can arrange our calculation completely independent of loaded textures.
That is, enable(GL_TEXTURE_2) and set glTexEnv is one set of texture units.
And you can load actual textures (and point to them by SOURCEn) to totally
independent texture units.

Stil, one limitation: only GL_PREVIOUS can get result of previous calculation.
So we *cannot* make any calculation arrangement... this is still a pipeline
arrangement, one result goes to another. That's why many multitexturing tricks
use alpha and RGB channels for totally different jobs.

For emboss, this will allow a 1-pass method.

http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_env_combine.txt

See "Texture Mapping: Beyond the Basics"
http://www.informit.com/content/images/9780321498823/samplechapter/0321498828_CH09.pdf
for practical overview of texture extensions in OpenGL.

http://www.opengl.org/sdk/docs/man/ - glTexEnv manpage as of OpenGL 2006.

------------------------------------------------------------------------------
1-pass:

Back to
  (0.5 + Bump/2 - shifted(at runtime) Bump/2) * normal scene color
Normal scene color is actually PRIMARY_COLOR * normal texture, so this
is still not so easy. You cannot make it 1-pass without using alpha channels.
Only on RGB, you would have to make
  PRIMARY_COLOR * normal texture
as first calculation and then multiply it by (0.5 + Bump/2 - shifted(at runtime) Bump/2)
which is not doable...

Idea is to use alpha channel. Compute "PRIMARY_COLOR * normal texture"
in RGB channel and in parallel "(0.5 + Bump/2 - shifted(at runtime) Bump/2)" in alpha
channels. This may work, since for "normal texture" and "0.5 + Bump/2" you
want the same texture coordinates, so you can put them on a single RGBA texture.

------------------------------------------------------------------------------
Light in tangent space: how to calculate the shift.
See code, see Moller+Haines.

Emboss bump mapping example:
http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=22
http://nehe.gamedev.net/data/lessons/extras/lesson22/EmbossBumpMapping.ppt

Some my improvements: 1-pass only method (as implemented now needs 3 tex units,
although could get away with 2 if using blending for the last step), GL_SUBTRACT.

------------------------------------------------------------------------------
Emboss finish:

So I have bump_amount * normal_color. normal_color = primary_color * tex_color.
The idea is that bump_amount replaces (approximates, but with bumps)
normal lighting diffuse color.
So the "bump_amount * normal_color" seems to be the correct way, assuming
that normal color is calculated with diffuse factor = always 1.0.
And with lighting off.

Actually getting rid of normal diffuse calculation is not good, bump_amount
doesn't catch any normal diffuse behavior, we miss the fact that light
doesn't shine at all on some surfaces, when it's on heir back side,
we miss the fact that light is much smaller when viewed from small angle...
So we have to turn on lighting to catch this.
Also, surfaces are darker, as now 0.5 modulation = normal lighting (shifted
bumps equal, and this occurs on most places).
Could balance by making lighter textures.
Implemented (2nd and 3rd columns).

Also, another hack would be make "(Bump/2 - shifted(at runtime) Bump/2)"
(so result may be < 0, although OpenGL will clamp to 0) and simply add
bump_amount + normal_color. Totally not related to any lighting equation,
but looks quite OK.
Implemented (4th and 5th columns).

------------------------------------------------------------------------------
Note about generating bump images:
- get image, increase brightness and contrast almost to the max,
  making it almost black and white image.
- middle row looks worse, because it contained many small white/black
  stains. In lower row these stains are removed, image much better.
So seems that automatic generation of sensible bump images is easy and doable.

------------------------------------------------------------------------------
Dot3 bump mapping:

Requirement: texture combine function DOT3_RGB_ARB. Added by
ARB_texture_env_dot3 extension (obviously depends on ARB_multitexture
and EXT_texture_env_combine). Standard since GL 1.3. It works on RGB sources,
calculates
  4*((Arg0_r - 0.5)*(Arg1_r - 0.5) +
     (Arg0_g - 0.5)*(Arg1_g - 0.5) +
     (Arg0_b - 0.5)*(Arg1_b - 0.5))
and places the same result in all R, G, B. (There's also analogous
DOT3_RGBA_ARB, not important for us).

Idea:

1. pass direction of light-to-vertex (in vertex space, i.e. calculated
   by transforming light pos to tangent space just like for emboss) as
   some 3f value that will be interpolated. It can be passed as color3f,
   texCoord3f (for some texture unit), etc. --- whatever, it's only important
   that this should be available for texture unit calculations.

   In practice TODO.

   It should be renormalized ! (interpolating breaks normalization).

2. Make a texture with normals stored as 3-value vectors.

Use DOT3_RGB_ARB to calculate dot between light direction and normal
at this point of the screen. Effectively, this calculates the diffuse
factor of the lighting equation, so we can use this just like
bump_amount in emboss bump mapping.

http://nehe.gamedev.net/data/articles/article.asp?article=20

http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
(testing normal_map.jpg from there)

------------------------------------------------------------------------------
TODO: Finish reading nehe demo, is there good expl of tangent space ?
  If not, xero 6 pages from Moller+Haines ? There's a short and good expl.
TODO: dot3 method, environemnt bump mapping, parallax mapping, displacement?
TODO: make it faster on Radeon (chantal)
TODO: show on larger/more complicated models, like an orange
TODO: implement in VRML
  http://www.parallelgraphics.com/developer/products/cortona/extensions/bumpmap/
TODO: walker navigator.
TODO: 2 pass method implement ? if needed also for dot3 ?

TODO: test, elaborate on
  Note also that this cube CAN NOT be done using a display list, since
  display-lists seem to use an internal floating point accuracy
  different from GLfloat. Since this leads to several nasty effects,
  generally referred to as "decaling"-problems, I kicked display
  lists. I assume that a general rule for multipass algorithms is to do
  the entire geometry with or without display lists.
from http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=22

TODO: dl all URLs here to chantal, gl 2.1 spec.