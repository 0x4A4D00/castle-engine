@section(2 OpenGLOptimization
  OpenGL rendering optimization notes)

Notes about optimizing OpenGL rendering for the (most usual)
case when you know that user will usually not see the whole scene.

@section(3 OpenGLOptimizationTerms
  First, some terminology)

@definitionList(
  @itemLabel What is an "active part" of VRML model ?
  @item(
    This is simply the whole VRML model without parts excluded because
    they are inactive children of Switch or LOD nodes. E.g. consider
    this VRML file:

@preformatted(
  #VRML V1.0 ascii
  Switch { Sphere { } }
  Cone { }
)

    Active part of it consists of only one cone, since sphere is not
    visible.)

  @itemLabel What is a shape?
  @item(
    It's a VRML geometry node with a state.
    For VRML 2.0, this corresponds to an instance of a @code(Shape) node.
    It's TVRMLShape class. E.g. this VRML file

@preformatted(
  #VRML V1.0 ascii
  Texture { filename "aaa.png" }
  DEF MySphere Sphere { }
  DEF MyCone Cone { }
  Texture { filename "bbb.png" }
  USE MySphere
)

    consists of @bold(two) geometry nodes (named MySphere and MyCone) and has
    @bold(three) shapes:

    @orderedList(
      @itemSpacing compact
      @item MySphere textured by aaa.png
      @item MyCone textured by aaa.png
      @item MySphere textured by bbb.png
    )

    Many VRML nodes are either geometry nodes
    (that represent something visible) or nodes that affect subsequent state.

    @italic(Shape) is the basis
    of optimizations outlined below. After loading the VRML model,
    class @link(TVRMLScene) creates a simple tree of the shapes in the model.)
)

@section(3 OpenGLOptimizationDone
  What is currently implemented ?)

@orderedList(
  @item(
    You can use @link(TVRMLGLScene) with @link(TVRMLGLScene.Optimization
    Optimization) = roSeparateShapes
    and use it's Render* methods that take into account your visibility
    frustum (e.g. @link(TVRMLGLScene.RenderFrustum RenderFrustum))
    or visibility sphere or something like that
    (generally speaking: methods that generate some function
    TestShapeVisibility that can quickly decide that some Shapes
    are not visible by the user).

    Simple approach to this, i.e. testing each shape
    for visibility separately,
    works great when you have relatively few shapes in your
    scene (let's say <= 100, but this estimation may be too big or too
    small in some practical cases). And such shapes have small
    BoundingBoxes. Then this scheme will be often able to quickly
    eliminate whole shapes from rendering pipeline, thus
    decreasing amount of triangles that we pass to OpenGL, thus speeding
    up the rendering.

    Drawbacks: this means that "internal" design of your model
    (how it's divided into shapes) matters a lot.
    E.g. don't define your entire model as one IndexedFaceSet node.
    Don't define your model as many many many IndexedFaceSet nodes
    that have very few (let's say <= 10) triangles.
    Don't create IndexedFaceSet nodes with triangles that
    are scattered all around the whole scene (i.e., nodes that have
    BoundingBox that is very large and is visible from almost every
    camera position in the scene).)

  @item(
    This approach is the best thing implemented for now:

    It is actually approach (1) but done in a little more sophisticated
    way: I'm traversing down octree (entering only into nodes that
    collide with my viewing frustum), and this way I mark shapes
    that are possibly visible.

    To use this: just build your octree by adding ssRendering to
    @link(TVRMLScene.Spatial) and then render using
    @link(TVRMLGLScene.RenderFrustum).
    @link(TVRMLGLScene) still (like in approach (1))
    should be constructed with Optimization = roSeparateShapes.

    This way I keep using roSeparateShapes, so most
    of drawbacks of (1) remain, but one drawback is removed:
    the case when you have many many shapes in your scene is more
    tolerable now. You can even get @italic(better) performance by dividing
    some of your shapes to more shapes. Of course,
    this will work only to a certain point, i.e. at some point
    making more shapes will again degrade performance.
    But now you can squeeze more shapes than with approach (1).)

  @item(
    There's also a modified version of approach (2).
    With Optimization = roSeparateShapes, I create a separate
    display list for each shape, that includes shape's
    tranformation and lighting settings.

    However, this prevents
    display lists sharing between various shapes:
    If the scene uses the same shape many times, but transformed
    differently, I would like to create only one display list for
    such shape. Moreover, when using TVRMLGLAnimation, if the
    same shape is used within each animation frame (and it's
    only transformed differently), I would also like to use one
    display list. This is achieved by
    Optimization = roSeparateShapesNoTransform.

    This is important that we save display list usage, as display lists
    can eat a huge amount of memory (as they have to store many things,
    like all vertex coordinates).)
)

@section(3 OpenGLOptimizationAlternatives
  What are the alternatives ?)

@orderedList(
  @itemSetNumber 4
  @item(
    Then comes the obvious idea to don't use scene division given
    by shapes, but instead use triangles. This means that you
    will not any longer depend on how model designer divided your scene
    into shapes. All the drawbacks of (1) disappear : you can
    have large shapes with large BoundingBoxes, you can have
    many many shapes, etc.

    To make this work you have to traverse octree to decide
    which triangles are in your visibility frustum/sphere/etc.
    (Doing this without octree, i.e. testing each triangle against
    your visibility frustum/sphere/etc. would be pointless,
    since this is what OpenGL already does itself.)

    Such traversing of the octree should be the first pass,
    when you're somehow marking visible triangles.
    Then, in the second pass, you should render your triangles
    shape-by-shape. Otherwise (if you would try
    to render triangles immediately when traversing your octree)
    you could produce too much overhead to OpenGL by too often
    changing your material/texture/etc. properties,
    since you will probably find triangles from various nodes
    (with various material/texture/etc. properties)
    very close in some octree nodes/leafs.
    Well, OK, this seems negotiable: maybe in some cases
    it would be sensible and more efficient to render triangles
    immediately when traversing your octree (let's assign
    number (5) to this approach).

    Drawbacks: well, first of all your octree must be really good.
    Just like for ray-tracer. Too shallow octree (like the one
    that may be sufficient for collision detection) is not good.
    But this is not really a problem, since my octree can be
    constructed with quite aggressive requirements.
    Constructing such octree may take a while of time,
    but that's another story.

    The real problem is that you will be unable to put large parts
    of rendering pipeline into OpenGL display lists,
    since you're deciding what to render on the "triangle-level granularity",
    so to speak. Of course, you could construct separate display list for
    each triangle, but this will (probably) not give you much speed.)
)

Final notes: don't blame me if you found an invalid statement
in this document. This is only a quick draft of some of my thoughts
and ideas. But I'm no guru on this matter, and I'm learning
new things every day. You think you have a better approach to some of
the issues here (even if it works only in certain cases) ?
I want to know about it. So @link(SectionAuthor email me).
