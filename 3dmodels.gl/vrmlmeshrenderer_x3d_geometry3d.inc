{
  Copyright 2002-2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

{ TVRMLMeshRenderer descendants implementing nodes in X3D "Geometry3D"
  component. (Some simpler nodes are in separate file:
  see vrmlmeshrenderer_simple_nodes.inc file.) }

type
  TElevationGridRenderer = class(TVRMLMeshRenderer)
  protected
    procedure DoRender; override;
  public
    constructor Create(ARenderer: TVRMLOpenGLRenderer);
  end;

  TExtrusionRenderer = class(TVRMLMeshRenderer)
  protected
    procedure DoRender; override;
  end;

  { Handling IndexedFaceSet for VRML <= 1.0 and >= 2.0.

    Note that this cannot deal with NorImplementation = niNone,
    you're expected to set NorImplementation to non-none in constructor.
    A simplest way to do this is to use AutoGenerateNormals. }
  TIndexedFaceSetRenderer = class(TAbstractNorColMatTexCoordinateRenderer)
  private
    { Helpers for bump mapping }
    HasTangentVectors: boolean;
    STangent, TTangent: TVector3Single;
    LightPositionObjectSpace: TVector3Single;
    NormalsAutoGenerated: boolean;
  protected
    procedure RenderCoordinate; override;
    procedure RenderCoordinateBegin; override;
    procedure RenderCoordinateEnd; override;
    procedure RenderVertex(IndexNum: Integer); override;
    procedure RenderCoordsRange(const RangeNumber: Cardinal;
      BeginIndex, EndIndex: Integer); override;

    { Auto-generate normals and set Normals, NormalsCcw, NorImplementation
      properties to use them. }
    procedure AutoGenerateNormals(const CreaseAngle: Single);

    { Set these in descendant's constructor. }
    FaceConvex: boolean;
  public
    constructor Create(ARenderer: TVRMLOpenGLRenderer);
    destructor Destroy; override;

    { These must be set by Renderer if BumpMappingMethod <> bmNone }
    TexOriginal, TexNormalMap, TexHeightMap, TexNormalizationCube: TGLuint;
    TexOriginalAlpha: boolean;
    TexHeightMapScale: Single;
  end;

  TIndexedFaceSet_1Renderer = class(TIndexedFaceSetRenderer)
  public
    constructor Create(ARenderer: TVRMLOpenGLRenderer;
      ANode: TNodeIndexedFaceSet_1);
  end;

  TIndexedFaceSet_2Renderer = class(TIndexedFaceSetRenderer)
  public
    constructor Create(ARenderer: TVRMLOpenGLRenderer;
      ANode: TNodeIndexedFaceSet_2);
  end;

{ TElevationGridRenderer --------------------------------------------------------- }

constructor TElevationGridRenderer.Create(ARenderer: TVRMLOpenGLRenderer);
var
  Node: TNodeElevationGrid;
begin
  inherited;

  Node := Geometry as TNodeElevationGrid;

  { About normals orientation, ccw and solid fields:

    See Extrusion implementation for general notes.
    In short, ccw only says which side is visible(if solid)/lighted
    (if one-sided lighting). We always want to generate normals from
    CCW, and avoid calling glFrontFace.

    Spec says that xSpacing and zSpacing should always be > 0,
    so always up (where height points to) is visible when ccw = TRUE
    and solid = TRUE. So flipping ccw simply culls the other face. }

  CullBackFaces := Node.FdSolid.Value;
  FrontFaceCcw := Node.FdCcw.Value;
end;

procedure TElevationGridRenderer.DoRender;
var
  Node: TNodeElevationGrid;
  { Just shortcuts for appropriate Node fields. }
  XDimension, ZDimension: Integer;

  { Return normals, calculated or not, for given node.

    Calculated normals are ordered just like VRML / X3D spec says
    for normals recorded in VRML / X3D file, so you just don't need
    to care about it. }
  procedure CalculateNormals(
    out Normal: TDynVector3SingleArray;
    out NormalPerVertex: boolean;
    out NormalGenerated: boolean);

    procedure GenerateNormals;
    var
      FaceNormals: TDynVector3SingleArray;
      VertexNormals: array [0..3] of TVector3Single;
      VertexNormalsSum: TVector3Single;
      VertexNormalsCount: Integer;

      procedure AddVertexNormal(const I, J: Integer);
      begin
        if Between(I, 0, XDimension - 2) and
           Between(J, 0, ZDimension - 2) then
        begin
          VertexNormals[VertexNormalsCount] :=
            FaceNormals.Items[I  + J * (XDimension - 1)];
          VectorAddTo1st(VertexNormalsSum, VertexNormals[VertexNormalsCount]);
          Inc(VertexNormalsCount);
        end;
      end;

    var
      I, J: Integer;
      Last1, Last2, Next1, Next2: TVector3Single;
    begin
      NormalGenerated := true;

      { Always start by generating flat (per-quad) normals.
        Later, if creaseAngle > 0, we will use this flat normals to make
        smooth ones. }
      NormalPerVertex := false;
      Normal := TDynVector3SingleArray.Create((XDimension - 1) *
                                              (ZDimension - 1));

      for I := 1 to XDimension - 1 do
      begin
        Last1[0] := Node.FdXSpacing.Value * (I - 1);
        Last1[1] := Node.FdHeight.Items.Items[I - 1];
        Last1[2] := 0;
        Last2[0] := Node.FdXSpacing.Value * I;
        Last2[1] := Node.FdHeight.Items.Items[I];
        Last2[2] := 0;
        { Next X-coordinate will be const for the life of "for J := " below. }
        Next1[0] := Last1[0];
        Next2[0] := Last2[0];

        for J := 1 to ZDimension - 1 do
        begin
          Next1[1] := Node.FdHeight.Items.Items[
            I - 1 + J * XDimension];
          Next1[2] := Node.FdZSpacing.Value * J;
          Next2[1] := Node.FdHeight.Items.Items[
            I     + J * XDimension];
          Next2[2] := Next1[2];

          { As a normal we take avarage normal of two triangles of rendered
            quad. We have to normalize two sum components
            (use TriangleNormal, not TriangleDir), otherwise taking
            the average woudn't be good.

            Also, we normalize resulting VectorAdd, in case we'll want
            to generate smooth normals (for OpenGL flat rendering,
            this is actually not needed, as we have GL_NORMALIZE
            enabled anyway). }
          Normal.Items[I - 1 + (J - 1) * (XDimension - 1)] :=
            Normalized(VectorAdd(
              TriangleNormal(Last2, Last1, Next1),
              TriangleNormal(Last2, Next1, Next2)));

          Last1 := Next1;
          Last2 := Next2;
        end;
      end;

      if Attributes.SmoothShading and
         (Node.FdCreaseAngle.Value <> 0) then
      begin
        FaceNormals := Normal;
        Normal := nil;
        try
          NormalPerVertex := true;
          Normal := TDynVector3SingleArray.Create(XDimension * ZDimension);

          for I := 0 to XDimension - 1 do
          begin
            for J := 0 to ZDimension - 1 do
            begin
              VertexNormalsCount := 0;
              VertexNormalsSum := ZeroVector3Single;
              AddVertexNormal(I - 1, J - 1);
              AddVertexNormal(I    , J - 1);
              AddVertexNormal(I - 1, J    );
              AddVertexNormal(I    , J    );

              { TODO: For now, just ignore creaseAngle (we know it's > 0)
                and smooth all. }
              if VertexNormalsCount = 0 then
              begin
                { special case: no neighbor face for vertex }
                Assert(XDimension = 1);
                Assert(ZDimension = 1);
                Normal.Items[I + J * XDimension] := Vector3Single(0, 1, 0);
              end else
              begin
                Normal.Items[I + J * XDimension] :=
                  VectorScale(VertexNormalsSum, 1 / VertexNormalsCount);
              end;
            end;
          end;
        finally FreeAndNil(FaceNormals); end;
      end;
    end;

  const
    SNotEnoughNormals = 'Elevation grid specifies normal node, but with not enough items. Falling back to auto-generation of normals';
  begin
    if (Node.FdNormal.Value <> nil) and
       (Node.FdNormal.Value is TNodeNormal) then
    begin
      Normal := TNodeNormal(Node.FdNormal.Value).FdVector.Items;
      NormalPerVertex := Node.FdNormalPerVertex.Value;
      NormalGenerated := false;

      { check are enough items available }
      if (NormalPerVertex and
           (Normal.Count < XDimension *
                           ZDimension)) or
         ((not NormalPerVertex) and
           (Normal.Count < (XDimension - 1) *
                           (ZDimension - 1))) then
      begin
        VRMLNonFatalError(SNotEnoughNormals);
        GenerateNormals;
      end else
      begin
        { Then user-supplied normals point from CW.
          But we want them from CCW... so we have to copy and negate them. }
        if not FrontFaceCcw then
        begin
          Normal := TDynVector3SingleArray.CreateCopy(Normal);
          Normal.Negate;
          NormalGenerated := true;
        end;
      end;
    end else
      GenerateNormals;
  end;

var
  TexCoordUseful: boolean;

  procedure TextureCoord(const I, J: Integer);
  begin
    if Renderer.Render_TexCoordsNeeded then
    begin
      if TexCoordUseful then
        glTexCoordv(
          TNodeTextureCoordinate(Node.FdTexCoord.Value).FdPoint.
            Items.Items[I + J * XDimension]) else
        glTexCoord2f(I / (XDimension - 1),
                     J / (ZDimension - 1));
    end;
  end;

var
  Normal: TDynVector3SingleArray;
  NormalPerVertex: boolean;
  NormalGenerated: boolean;

  procedure VertexNormal(const I, J: Integer);
  begin
    if NormalPerVertex then
      glNormalv(Normal.Items[I + J * XDimension]);
  end;

var
  I, J: Integer;
  Last1, Last2, Next1, Next2: TVector3Single;
begin
  Node := Geometry as TNodeElevationGrid;
  XDimension := Node.FdXDimension.Value;
  ZDimension := Node.FdZDimension.Value;

  if Node.IsNotEmpty then
  begin
    CalculateNormals(Normal, NormalPerVertex, NormalGenerated);

    TexCoordUseful :=
      (Node.FdTexCoord.Value <> nil) and
      (Node.FdTexCoord.Value is TNodeTextureCoordinate) and
      (TNodeTextureCoordinate(Node.FdTexCoord.Value).FdPoint.Count >=
        XDimension * ZDimension);

    glPushAttrib(GL_LIGHTING_BIT { for shade model });

      if not NormalPerVertex then
        glShadeModel(GL_FLAT);

      for I := 1 to XDimension - 1 do
      begin
        glBegin(GL_QUAD_STRIP);
          Last1[0] := Node.FdXSpacing.Value * (I - 1);
          Last1[1] := Node.FdHeight.Items.Items[I - 1];
          Last1[2] := 0;
          Last2[0] := Node.FdXSpacing.Value * I;
          Last2[1] := Node.FdHeight.Items.Items[I];
          Last2[2] := 0;
          { Next X-coordinate will be const for the life of "for J := " below. }
          Next1[0] := Last1[0];
          Next2[0] := Last2[0];

          { Vertices are ordered such that face is CCW from up (i.e.
            looking from positive Y axis). }

          TextureCoord(I, 0);
          VertexNormal(I, 0);
          DoGLVertex(Last2);

          TextureCoord(I - 1, 0);
          VertexNormal(I - 1, 0);
          DoGLVertex(Last1);

          for J := 1 to ZDimension - 1 do
          begin
            Next1[1] := Node.FdHeight.Items.Items[
              I - 1 + J * XDimension];
            Next1[2] := Node.FdZSpacing.Value * J;
            Next2[1] := Node.FdHeight.Items.Items[
              I     + J * XDimension];
            Next2[2] := Next1[2];

            if not NormalPerVertex then
              glNormalv(Normal.Items[I - 1 + (J - 1) * (XDimension - 1)]);

            TextureCoord(I, J);
            VertexNormal(I, J);
            DoGLVertex(Next2);

            TextureCoord(I - 1, J);
            VertexNormal(I - 1, J);
            DoGLVertex(Next1);

            Last1 := Next1;
            Last2 := Next2;
          end;
        glEnd;
      end;
    glPopAttrib;

    if NormalGenerated then
      FreeAndNil(Normal);
  end;
end;

{ TExtrusionRenderer --------------------------------------------------------- }

type
  TExtrusionTriangleProcData = record
    Node: TNodeExtrusion;
    Render_TexCoordsNeeded: boolean;
    TexCapsTranslation: Single;
    TexCapsScale: Single;
  end;
  PExtrusionTriangleProcData = ^TExtrusionTriangleProcData;

procedure ExtrusionCapTriangle(const Tri: TVector3Longint;
  TriangleProcData: Pointer);
var
  Data: PExtrusionTriangleProcData absolute TriangleProcData;

  procedure CapTexCoord(Index: Integer);
  begin
    with Data^ do
      if Render_TexCoordsNeeded then
      begin
        glTexCoord2f(
          (Node.FdCrossSection.Items.Items[Index][0] + TexCapsTranslation)
          * TexCapsScale,
          (Node.FdCrossSection.Items.Items[Index][1] + TexCapsTranslation)
          * TexCapsScale);
      end;
  end;

begin
  with Data^ do
  begin
    CapTexCoord(Tri[0]);
    glVertexv(Node.CrossSection3D(Tri[0]));
    CapTexCoord(Tri[1]);
    glVertexv(Node.CrossSection3D(Tri[1]));
    CapTexCoord(Tri[2]);
    glVertexv(Node.CrossSection3D(Tri[2]));
  end;
end;

procedure TExtrusionRenderer.DoRender;
var
  Node: TNodeExtrusion;
  TexCapsTranslation, TexCapsScale: Single;

  procedure DrawCap;

    procedure CapTexCoord(Index: Integer);
    begin
      if Renderer.Render_TexCoordsNeeded then
      begin
        glTexCoord2f(
          (Node.FdCrossSection.Items.Items[Index][0] + TexCapsTranslation)
          * TexCapsScale,
          (Node.FdCrossSection.Items.Items[Index][1] + TexCapsTranslation)
          * TexCapsScale);
      end;
    end;

    procedure DrawConvexCap;
    var
      I: Integer;
    begin
      glBegin(GL_TRIANGLE_FAN);
        for I := 0 to Node.FdCrossSection.Count - 1 do
        begin
          CapTexCoord(I);
          glVertexv(Node.CrossSection3D(I));
        end;
      glEnd();
    end;

  var
    TriangleProcData: TExtrusionTriangleProcData;
  begin
    if Node.FdConvex.Value then
    begin
      { We could call TriangulateConvexFace, but it's faster to do it directly,
        using OpenGL triangle_fan }
      DrawConvexCap;
    end else
    begin
      TriangleProcData.Node := Node;
      TriangleProcData.TexCapsTranslation := TexCapsTranslation;
      TriangleProcData.TexCapsScale := TexCapsScale;
      TriangleProcData.Render_TexCoordsNeeded := Renderer.Render_TexCoordsNeeded;

      glBegin(GL_TRIANGLES);
        TriangulateFace(nil, Node.FdCrossSection.Count,
          @Node.CrossSection3D, @ExtrusionCapTriangle,
          @TriangleProcData, 0);
      glEnd();
    end;
  end;

type
  T01 = 0..1;
var
  { We have separate pointers and data for matrix, to speed up
    Transform[0] := Transform[1] operation. It's much faster to
    copy a pointer than 16 Single floats. }
  TransformData: array [T01] of TMatrix4Single;
  Transform: array [T01] of PMatrix4Single;

  procedure MakeCrossPoint(out Point: TVector3Single; WhichTransform: T01;
    CrossIndex: Integer);
  var
    Point2d: PVector2Single;
  begin
    Point2d := @Node.FdCrossSection.Items.Items[CrossIndex];
    Point := MultMatrixPoint(Transform[WhichTransform]^,
      Vector3Single(Point2d^[0], 0, Point2d^[1]));
  end;

var
  E: TVRMLExtrusion;

  procedure SideTexCoord(SpineIndex, CrossSectionIndex: Integer);
  var
    U, V: Single;
  begin
    if Renderer.Render_TexCoordsNeeded then
    begin
      { Check ranges, to avoid dividing by zero (eventually the
        corresponding coord is set to a preditable zero :) ). }
      if E.High > 0 then
        V := SpineIndex / E.High else
        V := 0;
      if Node.FdCrossSection.Count > 1 then
        U := CrossSectionIndex / (Node.FdCrossSection.Count - 1) else
        U := 0;
      glTexCoord2f(U, V);
    end;
  end;

var
  I, J: Integer;
  LastY, LastZ: TVector3Single;
  Cross: array [T01, T01] of TVector3Single;
  TransformCap: TMatrix4Single;
  IsBeginCapCCW: boolean;
  Normal: TVector3Single;
  TexCapsMin, TexCapsMax: TVector2Single;
begin
  Node := Geometry as TNodeExtrusion;
  if Node.FdCrossSection.Count = 0 then Exit;

  { IsBeginCapCCW =
    when viewed from the positive axis (in local coords of spine 0)
    on begin cap, is it CCW?
    In other words, when IsBeginCapCCW then the normal vector
    (in local coords of spine 0) from CCW is (0, -1, 0).
    Remember that FdCrossSection specify X, Z values. }
  IsBeginCapCCW := IsPolygon2dCCW(Node.FdCrossSection.Items.ItemsArray,
    Node.FdCrossSection.Items.Count) > 0;

  glPushAttrib(GL_LIGHTING_BIT { for shade model } or
    GL_POLYGON_BIT { for glCullFace and CULL_FACE enable state });

  if Node.FdSolid.Value then
  begin
    { An explanation of ccw and solid fields interpretation for Extrusion:

      "ccw" field actually doesn't say how we should generate normals.
      Obviously, this is the decision of the implementor, like us,
      and we always want to generate normals from CCW (see comments
      at the beginning of this unit to know why we don't want ever to use
      glFrontFace in this unit).
      Instead, "ccw" says from which side the normal should go for the sake
      of interpreting solid (if enabled) and one-side lighting (if enabled ---
      although we always do two_side lighting, for now). The object is visible
      only from the side where faces are CCW, and lighted only from CCW,
      unless ccw = FALSE, when it's visible/lighted only when faces are CW.

      Also "ccw" says what normals the user provided, but this is not
      important for Extrusion --- user cannot provide normals for
      Extrusion, we always generate them.

      So what does CCW really say for Extrusion?
      It says which face is visible(if solid)/lighted.
      Assuming the order as spec says

        spine[0](crossSection[0], crossSection[1])
        spine[1](crossSection[1], crossSection[0])

      then sides which are CCW with the above order should be visible,
      and CW invisible (assuming solid = TRUE and ccw = TRUE;
      for ccw = FALSE, visibility is reverted).

      Note that this doesn't precisely say whether inside or outside
      is visible: direction of crossSection (ordered cw or ccw)
      determines whether the above
      (e.g. for solid = TRUE and ccw = TRUE) will result in culling
      outside or inside. And this is good, I mean the VRML author
      has to take care to write crossSection in good direction.
      We don't have to detect it.

      For sides:

      Now we generate normals from CCW with the same order
      as spec says. So when CCW = true, we have to cull CW,
      which is simply back. When CCW = false, we have to cull CCW,
      which is front.

      For caps:

      (As I understand VRML spec, I should just adjust so that
      always all outside or all inside is culled).
      Begin cap with our default order (which is just natural order
      of crossSection) gets CW on the same side where sides are CCW,
      so the glCullFace will be reverted there. End cap will have
      CCW on the same side as sides, so it will have glCullFace just
      like our sides. }

    { We set below glCullFace for sides of the extrusion.
      Caps will also be done under GL_CULL_FACE, but they will
      potentially change glCullFace. }

    if Node.FdCcw.Value then
      glCullFace(GL_BACK) else
      glCullFace(GL_FRONT);
    glEnable(GL_CULL_FACE);
  end;

  { TODO: for now we always generate flat normals(1 normal per face) }
  glShadeModel(GL_FLAT);

  Transform[0] := @TransformData[0];
  Transform[1] := @TransformData[1];

  E := TVRMLExtrusion.Create;
  try
    { This is just to shut up FPC 2.2.0 warnings about Cross not initialized. }
    Cross[0, 0][0] := 0.0;

    E.Node := Node;
    if E.High > 0 then
    begin
      E.SpineTransformTo1st(0, LastY, LastZ, Transform[0]^);
      for I := 1 to E.High do
      begin
        E.SpineTransformTo1st(I, LastY, LastZ, Transform[1]^);

        glBegin(GL_QUAD_STRIP);

        { I first render Cross[1, 0], then Cross[0, 0]
          as this sets direction for the first quad.
          This isn't really essential, but this way I render points
          in the same order as indicated by Extrusion X3D / VRML spec,
          which just helps me wrap my mind around it :) (especially
          when thinking about this ccw/solid). }

        MakeCrossPoint(Cross[1, 0], 1, 0);
        MakeCrossPoint(Cross[0, 0], 0, 0);

        SideTexCoord(I    , 0); glVertexv(Cross[1, 0]);
        SideTexCoord(I - 1, 0); glVertexv(Cross[0, 0]);

        for J := 1 to Node.FdCrossSection.Count - 1 do
        begin
          MakeCrossPoint(Cross[1, 1], 1, J);
          MakeCrossPoint(Cross[0, 1], 0, J);

          { Normal is average of normals of two triangles. }
          Normal := VectorAdd(
            TriangleNormal(Cross[1, 0], Cross[0, 0], Cross[0, 1]),
            TriangleNormal(Cross[0, 1], Cross[1, 1], Cross[1, 0]));
          glNormalv(Normal);

          { Now make a quad using 4 Cross points. }
          SideTexCoord(I    , J); glVertexv(Cross[1, 1]);
          SideTexCoord(I - 1, J); glVertexv(Cross[0, 1]);

          Cross[1, 0] := Cross[1, 1];
          Cross[0, 0] := Cross[0, 1];
        end;

        glEnd();

        { I don't care about preserving current Transform[0]^.
          But current Transform[1]^ must become Transform[0]^ in the
          next loop roll. So I exchange pointers. }
        SwapValues(Transform[0], Transform[1]);
      end;
    end;

    if Node.FdBeginCap.Value or
       Node.FdEndCap.Value then
    begin
      if Renderer.Render_TexCoordsNeeded then
      begin
        { calculate TexCapsTranslation, TexCapsScale }
        TexCapsTranslation := 0;
        TexCapsScale := 1;
        if Node.FdCrossSection.Items.MinMax(TexCapsMin, TexCapsMax) then
        begin
          if TexCapsMax[0] - TexCapsMin[0] >=
             TexCapsMax[1] - TexCapsMin[1] then
          begin
            if not IsZero(TexCapsMax[0] - TexCapsMin[0]) then
            begin
              { scale such that U is along the X of cap.
                Coord calculation will go like
                  u := (x - TexCapsMin[0]) / (TexCapsMax[0] - TexCapsMin[0]) }
              TexCapsTranslation := -TexCapsMin[0];
              TexCapsScale := 1 /  (TexCapsMax[0] - TexCapsMin[0]);
            end;
          end else
          begin
            if not IsZero(TexCapsMax[1] - TexCapsMin[1]) then
            begin
              TexCapsTranslation := -TexCapsMin[1];
              TexCapsScale := 1 /  (TexCapsMax[1] - TexCapsMin[1]);
            end;
          end;
        end;
      end;

      if Node.FdBeginCap.Value then
      begin
        { calculate TransformCap.
          Note that LastY, LastZ are just ignored here (they are "out only"
          for Spine = 0). }
        E.SpineTransformTo1st(0, LastY, LastZ, TransformCap);

        glPushMatrix;
          glMultMatrix(TransformCap);
          if Node.FdCcw.Value then
            glCullFace(GL_FRONT) else
            glCullFace(GL_BACK);
          if IsBeginCapCCW then
            glNormal3f(0, -1, 0) else
            glNormal3f(0, +1, 0);
          DrawCap;
        glPopMatrix;
      end;

      if Node.FdEndCap.Value then
      begin
        { calculate TriangleProcData.TransformEnd. }
        if E.High > 0 then
          { We already have it in Transform[0]^.
            This is most fortunate, otherwise calculating last transform
            is not easy (we have to iterate over whole spine for correct
            LastY, LastZ values). }
          TransformCap := Transform[0]^ else
          { Then this can be calculated just like TransformBegin
            (or copied from there, if available) }
        if not Node.FdBeginCap.Value then
          E.SpineTransformTo1st(0, LastY, LastZ, TransformCap);
          { else calculations for Node.FdBeginCap.Value already set TransformCap }

        { I used to have here
            TexCapsZScale := -1;
          (see diff between revision 2752 and 2753 for details).
          This way texture was correctly aligned on both begin and end cap
          sides. VRML / X3D spec doesn't say whether this is needed,
          saying only that Z axis aligns with texture T axis. Interpreting
          it naturally, this suggests that TexCapsZScale should not be done.

          For some time TexCapsZScale trick was present because the image in
          "Annotated VRML 97 reference" about Extrusion suggests this.

          On the other hand, NIST VRML test (Appearance.ImageTexture test 12,
          "Test of default Extrusion mapping for JPG files." shows that
          top cap has reverted texture.

          For now, TexCapsZScale is not done, as this seems more natural
          with spec (nothing suggests there to do such trick) and passes
          NIST test. }

        glPushMatrix;
          glMultMatrix(TransformCap);
          if Node.FdCcw.Value then
            glCullFace(GL_BACK) else
            glCullFace(GL_FRONT);
          if IsBeginCapCCW then
            glNormal3f(0, -1, 0) else
            glNormal3f(0, +1, 0);
          DrawCap;
        glPopMatrix;
      end;
    end;

  finally FreeAndNil(E) end;

  glPopAttrib;
end;

{ TIndexedFaceSetRenderer -------------------------------------------------- }

constructor TIndexedFaceSetRenderer.Create(ARenderer: TVRMLOpenGLRenderer);
begin
  inherited;
  BumpMappingAllowed := true;
end;

destructor TIndexedFaceSetRenderer.Destroy;
begin
  if NormalsAutoGenerated then
    FreeAndNil(Normals);
  inherited;
end;

procedure TIndexedFaceSetRenderer.RenderCoordinate;
begin
  RenderCoordsRanges;
end;

procedure TIndexedFaceSetRenderer.RenderVertex(IndexNum: Integer);

  procedure DoBumpMapping;
  var
    Normal, Vertex: TVector3Single;

    function CalculateLightDirTangent: TVector3Single;

      function LightDirectionInTangentSpace(
        const Vertex, Normal, STangent, TTangent: TVector3Single): TVector3Single;
      var
        ToTangent: TMatrix3Single;
        I: Integer;
      begin
        for I := 0 to 2 do
        begin
          ToTangent[I, 0] := STangent[I];
          ToTangent[I, 1] := TTangent[I];
          ToTangent[I, 2] := Normal[I];
        end;

        Result := MultMatrixVector(ToTangent,
          VectorSubtract(LightPositionObjectSpace, Vertex));
      end;

    var
      LocalSTangent, LocalTTangent: TVector3Single;
    begin
      { calculate LightDirTangent }
      if HasTangentVectors and
        (Abs(VectorDotProduct(STangent, Normal)) < 0.95) and
        (Abs(VectorDotProduct(TTangent, Normal)) < 0.95) then
      begin
        if NormalsFlat then
        begin
          Result := LightDirectionInTangentSpace(
            Vertex, Normal, STangent, TTangent);
        end else
        begin
          { If not NormalsFlat, you want to calculate local STangent and TTangent,
            I mean STangent and TTangent adjusted to current vertex (since each
            vertex may have different normal on the face when not NormalsFlat).

            Without doing this, you would see strange artefacts, smoothed
            faces would look somewhat like flat faces. Concenptually, for smoothed
            faces, whole tangent space should vary for each vertex, so Normal,
            and both tangents may be different on each vertex. }

          LocalSTangent := STangent;
          MakeVectorsOrthoOnTheirPlane(LocalSTangent, Normal);

          LocalTTangent := TTangent;
          MakeVectorsOrthoOnTheirPlane(LocalTTangent, Normal);

          Result := LightDirectionInTangentSpace(
            Vertex, Normal, LocalSTangent, LocalTTangent);
        end;
      end else
        Result := Vector3Single(0, 0, 1);
    end;

    procedure SetBumpMappingAttribs;

      procedure SetMatrixToTangent(const Normal, STangent, TTangent: TVector3Single);
      var
        ToTangent: TMatrix3Single;
        I: Integer;
      begin
        for I := 0 to 2 do
        begin
          ToTangent[I, 0] := STangent[I];
          ToTangent[I, 1] := TTangent[I];
          ToTangent[I, 2] := Normal[I];
        end;

        Renderer.BmGLSLAttribObjectSpaceToTangent[
          BumpMappingMethod >= bmGLSLParallax].SetValue(ToTangent);
      end;

    var
      LocalSTangent, LocalTTangent: TVector3Single;
    begin
      { This somewhat duplicates CalculateLightDirTangent logic,
        but instead of calling LightDirectionInTangentSpace this must
        call SetMatrixToTangent. }
      if HasTangentVectors and
        (Abs(VectorDotProduct(STangent, Normal)) < 0.95) and
        (Abs(VectorDotProduct(TTangent, Normal)) < 0.95) then
      begin
        if NormalsFlat then
        begin
          SetMatrixToTangent(Normal, STangent, TTangent);
        end else
        begin
          { If not NormalsFlat, you want to calculate local STangent and TTangent,
            I mean STangent and TTangent adjusted to current vertex (since each
            vertex may have different normal on the face when not NormalsFlat).

            Without doing this, you would see strange artefacts, smoothed
            faces would look somewhat like flat faces. Concenptually, for smoothed
            faces, whole tangent space should vary for each vertex, so Normal,
            and both tangents may be different on each vertex. }

          LocalSTangent := STangent;
          MakeVectorsOrthoOnTheirPlane(LocalSTangent, Normal);

          LocalTTangent := TTangent;
          MakeVectorsOrthoOnTheirPlane(LocalTTangent, Normal);

          SetMatrixToTangent(Normal, LocalSTangent, LocalTTangent);
        end;
      end else
      begin
        SetMatrixToTangent(Normal,
          { would be more correct to set LocalSTangent as anything perpendicular
            to Normal, and LocalTTangent as vector product (normal, LocalSTangent) }
          Vector3Single(1, 0, 0), Vector3Single(0, 1, 0));
      end;
    end;

  var
    LightDirTangent: TVector3Single;
    Tex: TVector2Single;
  begin
    GetNormal(IndexNum, CurrentRangeNumber, Normal);

    { This is OK, we want Vertex in object space here. }
    Vertex := Coord.Items.ItemsArray^[CoordIndex.Items.Items[indexNum]];

    Check(GetTextureCoord(IndexNum, Tex), 'TexCoord for BumpMapping');

    { set all textures coordinates }
    case BumpMappingMethod of
      bmMultiTexDotNotNormalized:
        begin
          LightDirTangent := CalculateLightDirTangent;
          NormalizeTo1st(LightDirTangent);

          { pass LightDirTangent as RGB color }
          glColor3f((LightDirTangent[0] + 1) / 2,
                    (LightDirTangent[1] + 1) / 2,
                    (LightDirTangent[2] + 1) / 2);

          glMultiTexCoord2fARB(GL_TEXTURE0_ARB, Tex[0], Tex[1]);
          glMultiTexCoord2fARB(GL_TEXTURE1_ARB, Tex[0], Tex[1]);
        end;

      bmMultiTexDotNormalized:
        begin
          LightDirTangent := CalculateLightDirTangent;
          glMultiTexCoord3fARB(GL_TEXTURE0_ARB,
            LightDirTangent[0],
            LightDirTangent[1],
            LightDirTangent[2]);

          glMultiTexCoord2fARB(GL_TEXTURE1_ARB, Tex[0], Tex[1]);
          glMultiTexCoord2fARB(GL_TEXTURE2_ARB, Tex[0], Tex[1]);
        end;

      bmGLSLNormal,
      bmGLSLParallax:
        begin
          SetBumpMappingAttribs;
          glMultiTexCoord2fARB(GL_TEXTURE0_ARB, Tex[0], Tex[1]);
          { No need to pass texture coords for 2nd texture, GL_TEXTURE1_ARB.
            Shader knows that they are the same, and will just use gl_TexCoord[0]
            to access both textures. }
        end;
      else raise EInternalError.Create('BumpMappingMethod ?');
    end;
  end;

begin
  if BumpMappingMethod <> bmNone then
    DoBumpMapping;

  inherited;
end;

procedure TIndexedFaceSetRenderer.RenderCoordinateBegin;

  { pass alpha from primary_color (this is actual material Opacity) *
    texture alpha }
  procedure glTexEnvAlphaFromMaterialAndTexture;
  begin
    if TexOriginalAlpha then
    begin
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_MODULATE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_EXT, GL_TEXTURE);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA_EXT, GL_SRC_ALPHA);
    end else
    begin
      glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, GL_REPLACE);
      glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT, GL_PRIMARY_COLOR_EXT);
      glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT, GL_SRC_ALPHA);
    end;
  end;

  procedure EnableForMultiTexDotNotNormalized;
  begin
    Renderer.ActiveTexture(0);
    glBindTexture(GL_TEXTURE_2D, TexNormalMap);
    glEnable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

    { texture unit 0: make dot between PRIMARY_COLOR and
      current texture (normal map). IOW, calculate diffuse factor. }
    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_DOT3_RGB_ARB);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PRIMARY_COLOR_EXT);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

    Renderer.ActiveTexture(1);
    glBindTexture(GL_TEXTURE_2D, TexOriginal);
    glEnable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

    { texture unit 1: multiply diffuse factor by texture value. }
    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

    glTexEnvAlphaFromMaterialAndTexture;

    LightPositionObjectSpace := MultMatrixPoint(
      State.InvertedTransform,
      Renderer.BumpMappingLightPosition);
  end;

  procedure EnableForMultiTexDotNormalized;
  begin
    { texture unit 0: just lookup your coordinates (which are
      3D lighting dir, not normalized) in cube map.
      This calculates normalized lighting dir. }
    Renderer.ActiveTexture(0);
    glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, TexNormalizationCube);
    glEnable(GL_TEXTURE_CUBE_MAP_ARB);
    { make sure GL_TEXTURE_2D is disabled here (other bump mapping
      methods could enable this) }
    glDisable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_TEXTURE);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);

    Renderer.ActiveTexture(1);
    glBindTexture(GL_TEXTURE_2D, TexNormalMap);
    glEnable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

    { texture unit 1: make dot between previous (light dir normalized) and
      current texture (normal map). IOW, calculate diffuse factor. }
    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_DOT3_RGB_ARB);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

    Renderer.ActiveTexture(2);
    { We bind NormalAndBumpTex, although actually we don't use
      bump stored there as alpha channel (they are only for emboss
      method). }
    glBindTexture(GL_TEXTURE_2D, TexOriginal);
    glEnable(GL_TEXTURE_2D);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

    { texture unit 2: multiply diffuse factor by texture value. }
    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MODULATE);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT, GL_PREVIOUS_EXT);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT, GL_SRC_COLOR);
    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);
    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);

    glTexEnvAlphaFromMaterialAndTexture;

    LightPositionObjectSpace := MultMatrixPoint(
      State.InvertedTransform,
      Renderer.BumpMappingLightPosition);
  end;

  procedure EnableForGLSL;
  var
    BmParallax: boolean;
  begin
    { This binds textures in the same way as EnableForMultiTexDotNotNormalized,
      but this doesn't call glTexEnvi or glEnable(GL_TEXTURE_2D)
      (it's useless, shader will control this). }
    Renderer.ActiveTexture(0);
    glBindTexture(GL_TEXTURE_2D, TexNormalMap);

    Renderer.ActiveTexture(1);
    glBindTexture(GL_TEXTURE_2D, TexOriginal);

    BmParallax := BumpMappingMethod >= bmGLSLParallax;

    if BmParallax then
    begin
      Renderer.ActiveTexture(2);
      glBindTexture(GL_TEXTURE_2D, TexHeightMap);
    end;

    Renderer.BmGLSLProgram[BmParallax].Enable;
    Renderer.BmGLSLProgram[BmParallax].SetUniform('world_space_to_object',
      State.InvertedTransform);

    if BmParallax then
    begin
      Renderer.BmGLSLProgram[BmParallax].SetUniform('scale', TexHeightMapScale);
      if not Renderer.BmSteepParallaxMapping then
        Renderer.BmGLSLProgram[BmParallax].SetUniform('bias', -TexHeightMapScale/2);
    end;

    glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(1, 1, 1, 1));
  end;

begin
  inherited;

  if BumpMappingMethod <> bmNone then
  begin
    case BumpMappingMethod of
      bmMultiTexDotNotNormalized: EnableForMultiTexDotNotNormalized;
      bmMultiTexDotNormalized   : EnableForMultiTexDotNormalized;
      bmGLSLNormal,
      bmGLSLParallax            : EnableForGLSL;
      else raise EInternalError.Create('BumpMappingMethod ?');
    end;
  end;
end;

procedure TIndexedFaceSetRenderer.AutoGenerateNormals(const CreaseAngle: Single);
begin
  { I could just do normal CreateNormals for all CreaseAngle values,
    so the test for "CreaseAngle <> 0" is not really required below.
    But I want to set NormalsFlat to @true whenever possible
    (as NormalsFlat allow some optimizations), so the test for
    "CreaseAngle <> 0" is useful there (as many VRML models will have
    default creaseAngle = 0, so NormalsFlat = true optimizations may be
    often applicable). }

  if Renderer.Attributes.SmoothShading and (CreaseAngle <> 0) then
  begin
    Normals := CreateNormals(
      CoordIndex.Items, Coord.Items, CreaseAngle, true);
    NorImplementation := niPerVertexNonIndexed;
  end else
  begin
    Normals := CreateFlatNormals(
      CoordIndex.Items, Coord.Items, true);
    NorImplementation := niPerFace;
  end;
  NormalsCcw := true; { always generated from CCW }
  NormalsAutoGenerated := true;
end;

procedure TIndexedFaceSetRenderer.RenderCoordinateEnd;

  { DisableXxx procedures disable textures (2d and cube map)
    that were enabled by their SetXxx counterparts in RenderCoordinateBegin.
    In case of shader implementation, this also disables the shader.

    Note that they still leave some state behind:
    - currently bound textures
    - texture environments
    - the currently bound texture is left unspecified
    These must be set always when anything will enable some texture. }

  procedure DisableForMultiTexDotNotNormalized;
  begin
    Renderer.ActiveTexture(0);
    glDisable(GL_TEXTURE_2D);

    Renderer.ActiveTexture(1);
    glDisable(GL_TEXTURE_2D);
  end;

  procedure DisableForMultiTexDotNormalized;
  begin
    { texture unit 0: just lookup your coordinates (which are
      3D lighting dir, not normalized) in cube map.
      This calculates normalized lighting dir. }
    Renderer.ActiveTexture(0);
    glDisable(GL_TEXTURE_CUBE_MAP_ARB);

    Renderer.ActiveTexture(1);
    glDisable(GL_TEXTURE_2D);

    Renderer.ActiveTexture(2);
    glDisable(GL_TEXTURE_2D);;
  end;

  procedure DisableForGLSL;
  begin
    { No need to disable textures, as we didn't enable them in
      EnableForGLSL (shader doesn't need them enabled). }

    Renderer.BmGLSLProgram[BumpMappingMethod >= bmGLSLParallax].Disable;
  end;

begin
  if BumpMappingMethod <> bmNone then
  begin
    case BumpMappingMethod of
      bmMultiTexDotNotNormalized: DisableForMultiTexDotNotNormalized;
      bmMultiTexDotNormalized   : DisableForMultiTexDotNormalized;
      bmGLSLNormal,
      bmGLSLParallax            : DisableForGLSL;
      else raise EInternalError.Create('BumpMappingMethod ?');
    end;
  end;

  inherited;
end;

procedure Render_Triangulated(const TriIndices: TVector3Longint; Data: Pointer);
begin
 TIndexedFaceSetRenderer(Data).RenderVertex(TriIndices[0]);
 TIndexedFaceSetRenderer(Data).RenderVertex(TriIndices[1]);
 TIndexedFaceSetRenderer(Data).RenderVertex(TriIndices[2]);
end;

procedure TIndexedFaceSetRenderer.RenderCoordsRange(
  const RangeNumber: Cardinal;
  BeginIndex, EndIndex: Integer);

  { Calculates HasTangentVectors, STangent, TTangent }
  procedure CalculateTangentVectors;

    { This procedure can change Triangle*, but only by swapping some vertexes,
      so we pass Triangle* by reference instead of by value, to avoid
      needless mem copying.

      Returns @false if cannot be calculated. }
    function CalculateTangent(IsSTangent: boolean; var Tangent: TVector3Single;
      var Triangle3D: TTriangle3Single;
      var TriangleTexCoord: TTriangle2Single): boolean;
    var
      D: TVector2Single;
      LineA, LineBC, DIn3D: TVector3Single;
      MiddleIndex: Integer;
      FarthestDistance, NewDistance, Alpha: Single;
      SearchCoord, OtherCoord: Cardinal;
    begin
      if ISSTangent then
        SearchCoord := 0 else
        SearchCoord := 1;
      OtherCoord := 1 - SearchCoord;

      { choose such that 1st and 2nd points have longest distance along
        OtherCoord, so 0 point is in the middle. }

      { MiddleIndex means that
        MiddleIndex, (MiddleIndex + 1) mod 3 are farthest. }

      MiddleIndex := 2;
      FarthestDistance := Abs(TriangleTexCoord[0][OtherCoord] - TriangleTexCoord[1][OtherCoord]);

      NewDistance := Abs(TriangleTexCoord[1][OtherCoord] - TriangleTexCoord[2][OtherCoord]);
      if NewDistance > FarthestDistance then
      begin
        MiddleIndex := 0;
        FarthestDistance := NewDistance;
      end;

      NewDistance := Abs(TriangleTexCoord[2][OtherCoord] - TriangleTexCoord[0][OtherCoord]);
      if NewDistance > FarthestDistance then
      begin
        MiddleIndex := 1;
        FarthestDistance := NewDistance;
      end;

      if IsZero(FarthestDistance) then
        Exit(false);

      if MiddleIndex <> 0 then
      begin
        SwapValues(TriangleTexCoord[0], TriangleTexCoord[MiddleIndex]);
        SwapValues(Triangle3D      [0], Triangle3D      [MiddleIndex]);
      end;

      if IsSTangent then
      begin
        { we want line Y = TriangleTexCoord[0][1]. }
        LineA[0] := 0;
        LineA[1] := 1;
        LineA[2] := -TriangleTexCoord[0][1];
      end else
      begin
        { we want line X = TriangleTexCoord[0][0]. }
        LineA[0] := 1;
        LineA[1] := 0;
        LineA[2] := -TriangleTexCoord[0][0];
      end;
      LineBC := LineOfTwoDifferentPoints2d(
        TriangleTexCoord[1], TriangleTexCoord[2]);

      try
        D := Lines2DIntersection(LineA, LineBC);
      except
        on ELinesParallel do begin Result := false; Exit; end;
      end;

      { LineBC[0, 1] is vector 2D orthogonal to LineBC.
        If Abs(LineBC[0]) is *smaller* then it means that B and C points
        are most different on 0 coord. }
      if Abs(LineBC[0]) < Abs(LineBC[1]) then
        Alpha := (                  D[0] - TriangleTexCoord[1][0]) /
                 (TriangleTexCoord[2][0] - TriangleTexCoord[1][0]) else
        Alpha := (                  D[1] - TriangleTexCoord[1][1]) /
                 (TriangleTexCoord[2][1] - TriangleTexCoord[1][1]);

      DIn3D := VectorAdd(
        VectorScale(Triangle3D[1], 1 - Alpha),
        VectorScale(Triangle3D[2], Alpha));

      if D[SearchCoord] > TriangleTexCoord[0][SearchCoord] then
        Tangent := VectorSubtract(DIn3D, Triangle3D[0]) else
        Tangent := VectorSubtract(Triangle3D[0], DIn3D);

      NormalizeTo1st(Tangent);

      Result := true;
    end;

  var
    Triangle3D: TTriangle3Single;
    TriangleTexCoord: TTriangle2Single;
  begin
    HasTangentVectors := false;
    if (BumpMappingMethod <> bmNone) and (BeginIndex + 2 < EndIndex) then
    begin
      { calculate Triangle3D }
      Triangle3D[0] := Coord.Items.ItemsArray^[CoordIndex.Items.Items[BeginIndex]];
      Triangle3D[1] := Coord.Items.ItemsArray^[CoordIndex.Items.Items[BeginIndex + 1]];
      Triangle3D[2] := Coord.Items.ItemsArray^[CoordIndex.Items.Items[BeginIndex + 2]];

      { This is just to shut up FPC 2.2.0 warnings about
        TriangleTexCoord not initialized. }
      TriangleTexCoord[0][0] := 0.0;

      HasTangentVectors :=
        { calculate TriangleTexCoord }
        GetTextureCoord(BeginIndex    , TriangleTexCoord[0]) and
        GetTextureCoord(BeginIndex + 1, TriangleTexCoord[1]) and
        GetTextureCoord(BeginIndex + 2, TriangleTexCoord[2]) and
        { calculate STangent, TTangent }
        CalculateTangent(true , STangent, Triangle3D, TriangleTexCoord) and
        CalculateTangent(false, TTangent, Triangle3D, TriangleTexCoord) and
        (Abs(VectorDotProduct(STangent, TTangent)) < 0.95);
    end;
  end;

begin
  inherited;

  CalculateTangentVectors;

 if not FaceConvex then
 begin
  glBegin(GL_TRIANGLES);
  TriangulateFace(Addr(CoordIndex.Items.Items[BeginIndex]),
    EndIndex-BeginIndex, Coord.Items.ItemsArray,
    {$ifdef FPC_OBJFPC} @ {$endif} Render_Triangulated, Self, BeginIndex);
  glEnd;
 end else
 begin
   {$ifdef DARWIN}

   { On Mac OS X 10.4.9, with Radeon ATI graphic card
     (it's MacBook Pro computer), there's definitely a bug
     in OpenGL implementation: it seems not able to handle
     GL_TRIANGLE_FAN properly, which is visible on "The Gate" and
     "Cages" levels of "The Castle": some triangles on these
     levels (on "The Gate", it concerns that back wall and gate
     geometry) seem to randomly disappear.

     I didn't make enough
     tests to actually make sure what's the precise condition
     to trigger this bug (as other "The Castle" levels,
     and castle.wrl sample VRML work OK). I also didn't test
     on other Mac OS X systems. (However, I did test this on the
     same computer with Linux Radeon OpenGL, and on Linux
     it works OK --- so the problem is within software, OpenGL
     probably, on Mac OS X ?). For safety I disable using
     GL_TRIANGLE_FAN entirely for now on Darwin. }

  glBegin(GL_TRIANGLES);
  TriangulateConvexFace(EndIndex-BeginIndex,
    {$ifdef FPC_OBJFPC} @ {$endif} Render_Triangulated, Self, BeginIndex);
  glEnd;

  {$else DARWIN}

  { zamiast GL_POLYGON uzywamy GL_TRIANGLES i robimy cos jak GL_TRIANGLE_FAN
    uzywajac glEdgeFlag. De facto, to co my chcemy zrobic to jest
    wlasnie wykonac GL_TRIANGLE_FAN tyle ze w triangle fan glEdgeFlag
    jest ignorowane (jakby zawsze bylo GL_TRUE).

    Zamiast GL_POLYGON uzywamy GL_TRIANGLE_FAN. Dlaczego ?
    Bo chcemy miec 1-znaczna triangulacje kazdego polygonu. To ma
    znaczenie kiedy np. renderujemy prostokat z cieniowaniem smooth
    i kazdy z 4 vertexow ma inny kolor. Wtedy widac wzdluz ktorej
    przekatnej biegnie triangulacja trojkata. I np. jezeli kawalek
    kwadratu wyjezdza za ekran wtedy widac jak (na skutek przycinania
    polygonu do frustum) przesuwa sie linia triangulacji. Wychodzi
    bardzo dziwny efekt, bo widac ze kolory na prostokacie sie nieco
    zmieniaja w miare jak ten wyjezdza za ekran, a to zdecydowanie nie jest
    efekt na jakim nam zalezy. Rozwiazaniem jest ustawlic 1-znaczna
    triangulacje prostokata, wtedy linia podzialu zawsze bedzie taka
    sama i problemu nie bedzie.

    Jedyna rzecz jaka (poza 1-znacznym wyznaczeniem triangulacji) robi
    GL_TRIANGLE_FAN to dodawanie w srodku dodatkowych krawedzi.
    Mozna to zobaczyc gdy przelaczymy sie na widok wireframe.
    Nie mozna uzywac glEdgeFlag z GL_TRIANGLE_FAN, jest przez nie
    ignorowane. Wiec zeby obejsc ten problem trzeba recznie realizowac
    GL_TRIANGLE_FAN przez GL_TRIANGLES i tam uzywac glEdgeFlag.
    Zrobilem to - patrz VRMLNodes_old_funcs.txt, ale niestety
    okazalo sie to bardzo zwalniac rendering (nic dziwnego -
    - musialem przeciez podawac wiele razy te same vertexy). Wiec
    chwilowo tego nie uzywam. A to ze GL_TRIANGLES_FAN powoduje ze
    w widoku wireframe widoczne jest wiecej krawedzi ? No coz,
    to zaden problem, przeciez nikt mi nie kaze dokladnie renderowac
    obiektu wireframe. }

  glBegin(GL_TRIANGLE_FAN);
  while BeginIndex < endIndex do
  begin
   RenderVertex(BeginIndex);
   Inc(BeginIndex);
  end;
  glEnd;

  {$endif DARWIN}
 end;
end;

{ TIndexedFaceSet_1Renderer -------------------------------------------------- }

constructor TIndexedFaceSet_1Renderer.Create(
  ARenderer: TVRMLOpenGLRenderer;
  ANode: TNodeIndexedFaceSet_1);
var
  SH: TNodeShapeHints;
begin
  inherited Create(ARenderer);

  CoordIndex := ANode.FdCoordIndex;
  Coord := State.LastNodes.Coordinate3.FdPoint;
  TexCoordIndex := ANode.FdTextureCoordIndex;
  TexCoord := State.LastNodes.TextureCoordinate2.FdPoint;

  MaterialIndex := ANode.FdMaterialIndex;
  MaterialBinding := State.LastNodes.MaterialBinding.FdValue.Value;

  SH := State.LastNodes.ShapeHints;

  { W tym miejscu uznajemy VERTORDER_UNKNOWN_ORDERING za COUNTERCLOCKWISE
    (a autorzy VRMLi w ogole nie powinni podawac normali jesli
    nie podadza vertexOrdering innego niz UNKNOWN) }
  FrontFaceCcw := SH.FdVertexOrdering.Value <> VERTORDER_CLOCKWISE;

  CullBackFaces :=
    (SH.FdVertexOrdering.Value <> VERTORDER_UNKNOWN) and
    (SH.FdShapeType.Value = SHTYPE_SOLID);

  FaceConvex := SH.FdFaceType.Value = FACETYPE_CONVEX;

  NormalIndex := ANode.FdNormalIndex;
  Normals := State.LastNodes.Normal.FdVector.Items;
  NormalsCcw := FrontFaceCcw;
  NorImplementation := NorImplementationFromVRML1Binding(
    State.LastNodes.NormalBinding.FdValue.Value);
  if NorImplementation = niNone then
    AutoGenerateNormals(SH.FdCreaseAngle.Value);
end;

{ TIndexedFaceSet_2Renderer -------------------------------------------------- }

constructor TIndexedFaceSet_2Renderer.Create(
  ARenderer: TVRMLOpenGLRenderer;
  ANode: TNodeIndexedFaceSet_2);
begin
  inherited Create(ARenderer);

  CoordIndex := ANode.FdCoordIndex;
  Coord := ANode.Coord;
  TexCoordIndex := ANode.FdTexCoordIndex;
  TexCoord := ANode.TexCoord;

  Normals := ANode.NormalItems;
  if Normals <> nil then
  begin
    { FrontFaceCcw is calculated already, TVRMLMeshRenderer.Create
      initializes it for all X3DComposedGeometryNode from ccw field. }
    NormalsCcw := FrontFaceCcw;
    NormalIndex := ANode.FdNormalIndex;
    if ANode.FdNormalPerVertex.Value then
    begin
      if NormalIndex.Count > 0 then
        NorImplementation := niPerVertexNormalIndexed else
        NorImplementation := niPerVertexCoordIndexed;
    end else
    begin
      if NormalIndex.Count > 0 then
        NorImplementation := niPerFaceNormalIndexed else
        NorImplementation := niPerFace;
    end;
  end else
    AutoGenerateNormals(ANode.FdCreaseAngle.Value);

  FaceConvex := ANode.FdConvex.Value;

  { calculate Color, ColorPerVertex, ColorIndex fields }
  Color := ANode.Color;
  ColorPerVertex := ANode.FdColorPerVertex.Value;
  ColorIndex := ANode.FdColorIndex;
end;
