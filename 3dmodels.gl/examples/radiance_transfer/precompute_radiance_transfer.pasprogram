{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Process arbitrary model for PRT. Computes and adds "radianceTransfer"
  field to all geometry nodes (descending from X3DComposedGeometryNode,
  this includes most often used nodes).

  $1 is the source model, $2 is the output model (output is always VRML/X3D,
  so use .wrl/.x3dv extension).

  TODO: for now, radianceTransfer is calculated for whole model.
  This means that self-shadowing takes whole model into account,
  but also that whole model must remain static (or radianceTransfer must
  be animated along with coords).

  Alternative approach is possible: calculate radianceTransfer only
  for this specific shape. Then shape must stay static (or it's
  radianceTransfer must be animated along with it's coords), but it can
  move with respect to other shapes. But note that then self-shadowing
  takes only this shape into account... TODO: make this possible,
  and document on kambi_vrml_extensions.

  We compute radianceTransfer in scene space (not in local shape
  space). This is important, otherwise incoming light SH (calculated
  when rendering at every frame) would have to be transformed (rotated)
  for each shape. Right now, it only has to be rotated once, for each scene.

  Note that your geometry nodes shouldn't use DEF/USE mechanism.
  If the same shape is instantiated many times, it will have the same
  radianceTransfer. Which is bad, since self-shadowing may be different
  on different instances...
  TODO: move to kambi_vrml_extensions docs.
}

program precompute_radiance_transfer;

uses SysUtils, KambiUtils, VectorMath, VRMLScene, VRMLNodes, Object3dAsVRML,
  NormalsCalculator;

var
  Scene: TVRMLScene;
  Normals: TDynVector3SingleArray;

procedure ComputeTransfer(RadianceTransfer: TDynSingleArray;
  Coord: TDynVector3SingleArray; const Transform: TMatrix4Single);
var
  I: Integer;
  V, N: TVector3Single;
begin
  RadianceTransfer.Count := Coord.Count * 3 { anything };
  for I := 0 to Coord.Count - 1 do
  begin
    { V = scene-space vertex coord }
    V := MatrixMultPoint(Transform, Coord.Items[I]);
    {RadianceTransfer.Items[I * 3    ] := MapRange(V[0], Scene.BoundingBox[0][0], Scene.BoundingBox[1][0], 0, 1);
    RadianceTransfer.Items[I * 3 + 1] := MapRange(V[1], Scene.BoundingBox[0][1], Scene.BoundingBox[1][1], 0, 1);
    RadianceTransfer.Items[I * 3 + 2] := MapRange(V[2], Scene.BoundingBox[0][2], Scene.BoundingBox[1][2], 0, 1);}
    { N = scene-space normal coord
      TODO: MatrixMultDirection will not work under non-uniform scaling
      matrix correctly. }
    N := Normalized(MatrixMultDirection(Transform, Normals.Items[I]));

    RadianceTransfer.Items[I * 3    ] := N[0];
    RadianceTransfer.Items[I * 3 + 1] := N[1];
    RadianceTransfer.Items[I * 3 + 2] := N[2];
    { TODO: dummy calc now }
  end;
end;

var
  I: Integer;
  Geometry: TVRMLGeometryNode;
  State: TVRMLGraphTraverseState;
  RadianceTransfer: TDynSingleArray;
begin
  Parameters.CheckHigh(2);

  Scene := TVRMLScene.Create(LoadAsVRML(Parameters[1]), true);
  try
    for I := 0 to Scene.ShapeStates.Count - 1 do
    begin
      Geometry := Scene.ShapeStates[I].GeometryNode;
      State := Scene.ShapeStates[I].State;

      if Geometry is TNodeX3DComposedGeometryNode then
        RadianceTransfer := TNodeX3DComposedGeometryNode(Geometry).FdRadianceTransfer.Items else
      if Geometry is TNodeIndexedFaceSet_1 then
        RadianceTransfer := TNodeIndexedFaceSet_1(Geometry).FdRadianceTransfer.Items else
        RadianceTransfer := nil;

      if RadianceTransfer <> nil then
      begin
        { For PRT, we need a normal per-vertex, so always calculate
          smooth normals. Simple, and thanks to NormalsCalculator
          this works for all VRML coord-based nodes (and only for
          those RadianceTransfer is defined). }
        Normals := CreateSmoothNormalsCoordinateNode(Geometry, State, true);
        try
          ComputeTransfer(RadianceTransfer, Geometry.Coordinates(State).Items,
            State.Transform);
        finally FreeAndNil(Normals) end;
      end;
    end;

    SaveToVRMLFile(Scene.RootNode, Parameters[2],
      'radianceTransfer computed by precompute_radiance_transfer');
  finally FreeAndNil(Scene) end;
end.
