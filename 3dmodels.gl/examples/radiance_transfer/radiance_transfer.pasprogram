{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple Precomputed Radiance Transfer implementation.
  Self-shadowing with diffuse lighting.
}

program radiance_transfer;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  KambiFilesUtils, VRMLErrors;

var
  Scene: TVRMLGLScene;
  CameraRadius: Single;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);
  Scene.Render(nil, tgAll);
end;

procedure Init(Glwin: TGLWindow);
begin
//  glEnable(GL_LIGHTING);
//  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox, CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function DoRadianceTransfer(Node: TVRMLGeometryNode;
      RadianceTransfer: PSingle;
      const RadianceTransferCount: Cardinal): TVector3Single;
  end;

function THelper.DoRadianceTransfer(Node: TVRMLGeometryNode;
  RadianceTransfer: PSingle;
  const RadianceTransferCount: Cardinal): TVector3Single;
begin
  { TODO: this is a dummy impl, just to test OnRadianceTransfer
    and radianceTransfer fields work. }
  Assert(RadianceTransferCount > 0);
  Result := Vector3Single(
    RadianceTransfer[0] / (2*Pi),
    RadianceTransfer[0] / (2*Pi),
    RadianceTransfer[0] / (2*Pi));
end;

begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roNone);
    Scene.Attributes.OnRadianceTransfer := @THelper(nil).DoRadianceTransfer;

    Glw.Navigator := Scene.CreateNavigator(CameraRadius);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
