{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple Precomputed Radiance Transfer implementation.
  Self-shadowing with diffuse lighting.
}

program radiance_transfer;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  KambiFilesUtils, VRMLErrors, SphericalHarmonics;

var
  Scene: TVRMLGLScene;
  CameraRadius: Single;
  ShowSimpleOcclusion: boolean;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);
  Scene.Render(nil, tgAll);
end;

procedure Init(Glwin: TGLWindow);
begin
//  glEnable(GL_LIGHTING);
//  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox, CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function DoRadianceTransfer(Node: TVRMLGeometryNode;
      RadianceTransfer: PSingle;
      const RadianceTransferCount: Cardinal): TVector3Single;
  end;

function THelper.DoRadianceTransfer(Node: TVRMLGeometryNode;
  RadianceTransfer: PSingle;
  const RadianceTransferCount: Cardinal): TVector3Single;
var
  F: Float;
begin
  if {TODO}{ShowSimpleOcclusion}true then
  begin
    Assert(RadianceTransferCount > 0);
    F := RadianceTransfer[0] / (SHBasis0 * 2 * Pi);
    Result := Vector3Single(F, F, F);
  end else
  begin
    { TODO }
  end;
end;

procedure MenuCommand(glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: ShowSimpleOcclusion := not ShowSimpleOcclusion;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

var
  M: TMenu;
begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roNone);
    Scene.Attributes.OnRadianceTransfer := @THelper(nil).DoRadianceTransfer;

    Glw.MainMenu := TMenu.Create('Main menu');
    M := TMenu.Create('_Program');
      M.Append(TMenuItemChecked.Create('_Show simple occlusion (useful when --sh-basis-count=1)', 10,
        ShowSimpleOcclusion, true));
      Glw.MainMenu.Append(M);

    Glw.Navigator := Scene.CreateNavigator(CameraRadius);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
