{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple Precomputed Radiance Transfer implementation.
  Self-shadowing with diffuse lighting.

  Navigate with mouse of keyboard (like view3dscene in Examine mode).
  AWSD, Q, Shift+Q move the light.
  R, Shift+R change light radius.
}

program radiance_transfer;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation, Keys,
  KambiFilesUtils, VRMLErrors, SphericalHarmonics, Math, Images, GLImages;

var
  Scene: TVRMLGLScene;
  CameraRadius: Single;
  ShowSimpleOcclusion: boolean = true { TODO - temporarily, since the LighSHBasis cals is not done now };
  LightRadius: Single;
  LightPos: TVector3Single;

const
  { This is currently not synched with actual SHBasisCount used to generate
    the Scene. We just always prepare LightSHBasisCount components,
    eventually some of them will not be used in DoRadianceTransfer.

    While this is not optimal, this also may allow to use different SHBasis
    for different shapes within the Scene in the future. }

  LightSHBasisCount = 25;

var
  LightSHBasis: array [0..LightSHBasisCount - 1] of Single;

procedure Draw(Glwin: TGLWindow);

  procedure DrawLight(ForMap: boolean);
  begin
    glPushMatrix;
      glTranslatev(LightPos);

      if not ForMap then
      begin
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_BLEND);
        glColor4f(1, 1, 0, 0.1);
      end else
        glColor3f(1, 1, 1);

      KamGluSphere(LightRadius, 10, 10);

      if not ForMap then
        glDisable(GL_BLEND);
    glPopMatrix;
  end;

const
  LightMapSize = 16;

  procedure DrawLightMap(const MapX, MapY, DirX, DirY, DirZ,
    UpX, UpY, UpZ: Integer);
  var
    P: TVector3Single;
    Map: TGrayscaleImage;
    I, SHBasis: Integer;
  begin
    { We have to clear the buffer first. Clearing with glClear is fast,
      but it must be clipped with scissor (glViewport does not clip glClear).
      Later: actually, clearing is not needed now, since we call DrawLightMap
      at the beginning, right after clearing the whole screen.

    glScissor(MapX, MapY, LightMapSize, LightMapSize);
    glEnable(GL_SCISSOR_TEST);
      glClear(GL_COLOR_BUFFER_BIT);
    glDisable(GL_SCISSOR_TEST);
    }

    glViewport(MapX, MapY, LightMapSize, LightMapSize);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix;
      glLoadIdentity;
      gluPerspective(90, 1, 0.01, 100);
      glMatrixMode(GL_MODELVIEW);

      glPushMatrix;

        glLoadIdentity;
        P := Box3dMiddle(Scene.BoundingBox);
        gluLookDirv(P, Vector3Single(DirX, DirY, DirZ), Vector3Single(UpX, UpY, UpZ));
        DrawLight(true);

      glPopMatrix;

      glMatrixMode(GL_PROJECTION);
    glPopMatrix;
    glMatrixMode(GL_MODELVIEW);

    Map := TGrayscaleImage(SaveScreen_noflush(TGrayscaleImage,
      MapX, MapY, LightMapSize, LightMapSize, GL_BACK));
    try
      for I := 0 to Sqr(LightMapSize) - 1 do
        for SHBasis := 0 to LightSHBasisCount - 1 do
          LightSHBasis[SHBasis] += (Map.GrayscalePixels[I]/255);
    finally FreeAndNil(Map) end;

    { TODO:
      Use prepared maps for SHBasis functions, make dots with them
      to calculate LightSHBasis.

      for every pixel of LightMap:
        for SHBasis := 0 to LightSHBasisCount - 1 do
          LightSHBasis[SHBasis] += LightMap[pixel] * SHBasisMap[SHBasis]
            [choose one of 6 maps for this DrawLightMap call][pixel];
    }
  end;

var
  SHBasis: Integer;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  if not IsEmptyBox3d(Scene.BoundingBox) then
  begin
    { First call all DrawLightMap. This wil draw light maps, get them,
      and calculate LightSHBasis describing the light contribution
      (this will be used then by Scene.Render, during DoRadianceTransfer). }

    for SHBasis := 0 to LightSHBasisCount - 1 do
      LightSHBasis[SHBasis] := 0;

    DrawLightMap(10                   , 100,  1,  0, 0, 0, 0, 1);
    DrawLightMap(10 +     LightMapSize, 100,  0, -1, 0, 0, 0, 1);
    DrawLightMap(10 + 2 * LightMapSize, 100, -1,  0, 0, 0, 0, 1);
    DrawLightMap(10 + 3 * LightMapSize, 100,  0,  1, 0, 0, 0, 1);

    DrawLightMap(10, 100 + LightMapSize, 0, 0,  1,  -1, 0, 0);
    DrawLightMap(10, 100 - LightMapSize, 0, 0, -1,   1, 0, 0);

    glViewport(0, 0, Glwin.Width, Glwin.Height);

    Writeln('LightSHBasis[0] ', FloatToNiceStr(LightSHBasis[0]));

    for SHBasis := 0 to LightSHBasisCount - 1 do
    begin
      { Each LightSHBasis[SHBasis] is now calculated for all sphere points.
        We want this to be integral over a sphere, so normalize now.

        We could multiply each LightSHBasis[SHBasis] in DrawLightMap
        by solid angle of given pixel
        (on cube map, pixels have different solid angles).
        Then below we would divide by 4*Pi (sphere area).

        TODO: for now, ignore solid angle, assume all pixels have the same influence.
        So just divide by number of points... }
      LightSHBasis[SHBasis] /= 6 * Sqr(LightMapSize);
    end;
  end;

  Scene.Render(nil, tgAll);
  DrawLight(false);
end;

procedure Init(Glwin: TGLWindow);
begin
//  glEnable(GL_LIGHTING);
//  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox, CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function DoRadianceTransfer(Node: TVRMLGeometryNode;
      RadianceTransfer: PSingle;
      const RadianceTransferCount: Cardinal): TVector3Single;
  end;

function THelper.DoRadianceTransfer(Node: TVRMLGeometryNode;
  RadianceTransfer: PSingle;
  const RadianceTransferCount: Cardinal): TVector3Single;
var
  F: Float;
  I: Integer;
begin
  Assert(RadianceTransferCount > 0);

  if ShowSimpleOcclusion then
  begin
    F := RadianceTransfer[0] / (SHBasis0 * 2 * Pi);
    Result := Vector3Single(F, F, F);
  end else
  begin
    Assert(RadianceTransferCount <= LightSHBasisCount);
    F := 0;
    for I := 0 to RadianceTransferCount - 1 do
      F += RadianceTransfer[I] * LightSHBasis[I];
    Result := Vector3Single(F, F, F);
  end;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: ShowSimpleOcclusion := not ShowSimpleOcclusion;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

procedure Idle(Glwin: TGLWindow);

  procedure ChangeLightPosition(Coord, Change: Integer);
  begin
    LightPos[Coord] += Change * Glwin.Fps.IdleSpeed * 50 /
      { scale by Box3dAvgSize, to get similar move on all models }
      Box3dAvgSize(Scene.BoundingBox) / 100;
    Glwin.PostRedisplay;
  end;

  procedure ChangeLightRadius(Change: Float);
  begin
    LightRadius *= Power(Change, Glwin.Fps.IdleSpeed);
    Glwin.PostRedisplay;
  end;

begin
  if Glwin.KeysDown[K_A] then ChangeLightPosition(0, -1);
  if Glwin.KeysDown[K_D] then ChangeLightPosition(0,  1);
  if Glwin.KeysDown[K_S] then ChangeLightPosition(1, -1);
  if Glwin.KeysDown[K_W] then ChangeLightPosition(1,  1);

  if Glwin.KeysDown[K_Q] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightPosition(2,  1) else
      ChangeLightPosition(2, -1);
  end;

  if Glwin.KeysDown[K_R] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightRadius(1/1.8) else
      ChangeLightRadius(1.8);
  end;
end;

var
  M: TMenu;
begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roNone);
    Scene.Attributes.OnRadianceTransfer := @THelper(nil).DoRadianceTransfer;

    if IsEmptyBox3d(Scene.BoundingBox) then
    begin
      LightRadius := 1;
      LightPos := Vector3Single(2, 0, 0);
    end else
    begin
      LightRadius := Box3dAvgSize(Scene.BoundingBox) / 3;
      LightPos := Box3dMiddle(Scene.BoundingBox);
      LightPos[0] += Scene.BoundingBox[1][0] - Scene.BoundingBox[0][0] * 2;
    end;

    Glw.MainMenu := TMenu.Create('Main menu');
    M := TMenu.Create('_Program');
      M.Append(TMenuItemChecked.Create('_Show simple occlusion (useful when --sh-basis-count=1)', 10,
        ShowSimpleOcclusion, true));
      Glw.MainMenu.Append(M);

    Glw.Navigator := Scene.CreateNavigator(CameraRadius);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnIdle := @Idle;
    Glw.OnMenuCommand := @MenuCommand;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
