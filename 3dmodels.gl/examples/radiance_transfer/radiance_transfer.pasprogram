{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple Precomputed Radiance Transfer implementation.
  Self-shadowing with diffuse lighting.

  Navigate with mouse of keyboard (like view3dscene in Examine mode).
  AWSD, Q, Shift+Q move the light.
  R, Shift+R change light radius.
}

program radiance_transfer;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation, Keys,
  KambiFilesUtils, VRMLErrors, SphericalHarmonics, Math, Images, GLImages,
  SphereSampling;

type
  TViewMode = (vmNormal, vmSimpleOcclusion, vmFull);

var
  Scene: TVRMLGLScene;
  CameraRadius: Single;
  ViewMode: TViewMode = vmSimpleOcclusion;
  LightRadius: Single;
  LightPos: TVector3Single;

const
  { This is currently not synched with actual SHBasisCount used to generate
    the Scene. We just always prepare LightSHBasisCount components,
    eventually some of them will not be used in DoRadianceTransfer.

    While this is not optimal, this also may allow to use different SHBasis
    for different shapes within the Scene in the future. }

  LightSHBasisCount = 25;

  LightMapSize = 16;

  { Intensity specific for this light.
    Only in 0..1 (as it's used as color component). }
  LightIntensity = 1.0;

  { All lights intensity (obtained by getting light maps) are scaled
    by this. }
  AllLightIntensityScale = 100.0;

var
  { This is calculated at the beginning of each Draw.
    Can be used then by DoRadianceTransfer. }
  LightSHBasis: array [0..LightSHBasisCount - 1] of Single;

type
  TEnvMapSide = 0..5;
  TEnvMapInfo = record
    Dir, Up, Side: TVector3Single;
    ScreenX, ScreenY: Integer;
  end;

const
  EnvMapInfo: array [TEnvMapSide] of TEnvMapInfo =
  ( (Dir: ( 1,  0, 0); Up: (0, 0, 1); Side: ( 0, -1, 0); ScreenX: 10                   ; ScreenY: 100),
    (Dir: ( 0, -1, 0); Up: (0, 0, 1); Side: (-1,  0, 0); ScreenX: 10 +     LightMapSize; ScreenY: 100),
    (Dir: (-1,  0, 0); Up: (0, 0, 1); Side: ( 0,  1, 0); ScreenX: 10 + 2 * LightMapSize; ScreenY: 100),
    (Dir: ( 0,  1, 0); Up: (0, 0, 1); Side: ( 1,  0, 0); ScreenX: 10 + 3 * LightMapSize; ScreenY: 100),
    (Dir: (0, 0,  1); Up: (-1, 0, 0); Side: (0, -1, 0); ScreenX: 10; ScreenY: 100 + LightMapSize),
    (Dir: (0, 0, -1); Up: ( 1, 0, 0); Side: (0, -1, 0); ScreenX: 10; ScreenY: 100 - LightMapSize)
  );

var
  { For each SHBasis function (first index of the array is LM of this function),
    a precalculated results. For each side of the cube (second index),
    and for each pixel on this side (third vertex; pixels are arranged
    same as in TGrayscaleImage, that is row-by-row from lower to higher,
    from left to right). }
  SHBasisValues: array [0..LightSHBasisCount - 1,
    TEnvMapSide,
    0 .. Sqr(LightMapSize) - 1] of Float;

procedure Draw(Glwin: TGLWindow);

  procedure DrawLight(ForMap: boolean);
  begin
    glPushMatrix;
      glTranslatev(LightPos);

      if not ForMap then
      begin
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_BLEND);
        glColor4f(1, 1, 0, 0.1);
      end else
        glColor3f(LightIntensity, LightIntensity, LightIntensity);

      KamGluSphere(LightRadius, 10, 10);

      if not ForMap then
        glDisable(GL_BLEND);
    glPopMatrix;
  end;

  procedure DrawLightMap(EnvMapSide: TEnvMapSide);
  var
    P: TVector3Single;
    Map: TGrayscaleImage;
    I, SHBasis, ScreenX, ScreenY: Integer;
  begin
    { We have to clear the buffer first. Clearing with glClear is fast,
      but it must be clipped with scissor (glViewport does not clip glClear).
      Later: actually, clearing is not needed now, since we call DrawLightMap
      at the beginning, right after clearing the whole screen.

    glScissor(ScreenX, ScreenY, LightMapSize, LightMapSize);
    glEnable(GL_SCISSOR_TEST);
      glClear(GL_COLOR_BUFFER_BIT);
    glDisable(GL_SCISSOR_TEST);
    }

    ScreenX := EnvMapInfo[EnvMapSide].ScreenX;
    ScreenY := EnvMapInfo[EnvMapSide].ScreenY;

    glViewport(ScreenX, ScreenY, LightMapSize, LightMapSize);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix;
      glLoadIdentity;
      gluPerspective(90, 1, 0.01, 100);
      glMatrixMode(GL_MODELVIEW);

      glPushMatrix;

        glLoadIdentity;
        P := Box3dMiddle(Scene.BoundingBox);
        gluLookDirv(P, EnvMapInfo[EnvMapSide].Dir, EnvMapInfo[EnvMapSide].Up);
        DrawLight(true);

      glPopMatrix;

      glMatrixMode(GL_PROJECTION);
    glPopMatrix;
    glMatrixMode(GL_MODELVIEW);

    Map := TGrayscaleImage(SaveScreen_noflush(TGrayscaleImage,
      ScreenX, ScreenY, LightMapSize, LightMapSize, GL_BACK));
    try
      { Use the Map to calculate LightSHBasis[SHBasis] (this is the actual
        purpose of drawing light). LightSHBasis[SHBasis] is just a dot product
        for all directions (for all pixels, in this case) of
        light intensity values * SH basis values. }

      for I := 0 to Sqr(LightMapSize) - 1 do
        for SHBasis := 0 to LightSHBasisCount - 1 do
          LightSHBasis[SHBasis] += (Map.GrayscalePixels[I]/255) *
            AllLightIntensityScale *
            SHBasisValues[SHBasis, EnvMapSide, I];
    finally FreeAndNil(Map) end;
  end;

var
  SHBasis: Integer;
  EnvMapSide: TEnvMapSide;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  if not IsEmptyBox3d(Scene.BoundingBox) then
  begin
    { First call all DrawLightMap. This wil draw light maps, get them,
      and calculate LightSHBasis describing the light contribution
      (this will be used then by Scene.Render, during DoRadianceTransfer). }

    for SHBasis := 0 to LightSHBasisCount - 1 do
      LightSHBasis[SHBasis] := 0;

    for EnvMapSide := 0 to 5 do
      DrawLightMap(EnvMapSide);

    for SHBasis := 0 to LightSHBasisCount - 1 do
    begin
      { Each LightSHBasis[SHBasis] is now calculated for all sphere points.
        We want this to be integral over a sphere, so normalize now.

        We could multiply each LightSHBasis[SHBasis] in DrawLightMap
        by solid angle of given pixel
        (on cube map, pixels have different solid angles).
        Then below we would divide by 4*Pi (sphere area).

        TODO: for now, ignore solid angle, assume all pixels have the same influence.
        So just divide by number of points... }
      LightSHBasis[SHBasis] /= 6 * Sqr(LightMapSize);
    end;

    glViewport(0, 0, Glwin.Width, Glwin.Height);
  end;

  Scene.Render(nil, tgAll);
  DrawLight(false);
end;

procedure UpdateViewMode; forward;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHT0);
  UpdateViewMode;
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox, CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function DoRadianceTransfer(Node: TVRMLGeometryNode;
      RadianceTransfer: PSingle;
      const RadianceTransferCount: Cardinal): TVector3Single;
  end;

function THelper.DoRadianceTransfer(Node: TVRMLGeometryNode;
  RadianceTransfer: PSingle;
  const RadianceTransferCount: Cardinal): TVector3Single;
var
  F: Float;
  I: Integer;
begin
  Assert(RadianceTransferCount > 0);

  if ViewMode = vmSimpleOcclusion then
  begin
    F := RadianceTransfer[0] / (SHBasis0 * 2 * Pi);
    Result := Vector3Single(F, F, F);
  end else
  begin
    Assert(RadianceTransferCount <= LightSHBasisCount);
    F := 0;
    for I := 0 to RadianceTransferCount - 1 do
      F += RadianceTransfer[I] * LightSHBasis[I];
    Result := Vector3Single(F, F, F);
  end;
end;

procedure UpdateViewMode;
begin
  if ViewMode = vmNormal then
  begin
    Scene.Attributes.OnRadianceTransfer := nil;
    glEnable(GL_LIGHTING);
  end else
  begin
    Scene.Attributes.OnRadianceTransfer := @THelper(nil).DoRadianceTransfer;
    glDisable(GL_LIGHTING);
  end;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: ViewMode := vmNormal;
    11: ViewMode := vmSimpleOcclusion;
    12: ViewMode := vmFull;
    else Exit;
  end;
  UpdateViewMode;
  Glw.PostRedisplay;
end;

procedure Idle(Glwin: TGLWindow);

  procedure ChangeLightPosition(Coord, Change: Integer);
  begin
    LightPos[Coord] += Change * Glwin.Fps.IdleSpeed *
      { scale by Box3dAvgSize, to get similar move on all models }
      Box3dAvgSize(Scene.BoundingBox);
    Glwin.PostRedisplay;
  end;

  procedure ChangeLightRadius(Change: Float);
  begin
    LightRadius *= Power(Change, Glwin.Fps.IdleSpeed);
    Glwin.PostRedisplay;
  end;

begin
  if Glwin.KeysDown[K_A] then ChangeLightPosition(0, -1);
  if Glwin.KeysDown[K_D] then ChangeLightPosition(0,  1);
  if Glwin.KeysDown[K_S] then ChangeLightPosition(1, -1);
  if Glwin.KeysDown[K_W] then ChangeLightPosition(1,  1);

  if Glwin.KeysDown[K_Q] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightPosition(2,  1) else
      ChangeLightPosition(2, -1);
  end;

  if Glwin.KeysDown[K_R] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightRadius(1/1.8) else
      ChangeLightRadius(1.8);
  end;
end;

procedure CalculateSHBasisValues;
var
  LM: Cardinal;
  EnvMapSide: TEnvMapSide;
  Pixel, PixelX, PixelY: Cardinal;
  PixelDir: TVector3Single;
begin
  for LM := 0 to LightSHBasisCount - 1 do
    for EnvMapSide := 0 to 5 do
      for Pixel := 0 to Sqr(LightMapSize) - 1 do
      begin
        PixelX := Pixel mod LightMapSize;
        PixelY := Pixel div LightMapSize;
        { PixelDir = exactly EnvMapInfo[EnvMapSide].Dir when
          PixelX/Y = LightMapSize/2 (pixel is on the middle of the image). }
        PixelDir :=  EnvMapInfo[EnvMapSide].Dir;
        VectorAddTo1st(PixelDir,
          VectorScale(EnvMapInfo[EnvMapSide].Side, -1 + 2 * PixelX/LightMapSize));
        VectorAddTo1st(PixelDir,
          VectorScale(EnvMapInfo[EnvMapSide].Up  , -1 + 2 * PixelY/LightMapSize));
        SHBasisValues[LM][EnvMapSide][Pixel] := SHBasis(LM, XYZToPhiTheta(PixelDir));
      end;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
  Radio: TMenuItemRadio;
  RadioGroup: TMenuItemRadioGroup;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');

    Radio := TMenuItemRadio.Create('_Normal (no PRT)', 10, ViewMode = vmNormal, true);
    RadioGroup := Radio.Group;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('_Simple Occlusion', 11, ViewMode = vmSimpleOcclusion, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('_Full Radiance Transfer', 12, ViewMode = vmFull, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    Result.Append(M);
end;

begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roNone);

    if IsEmptyBox3d(Scene.BoundingBox) then
    begin
      LightRadius := 1;
      LightPos := Vector3Single(2, 0, 0);
    end else
    begin
      LightRadius := Box3dAvgSize(Scene.BoundingBox) / 3;
      LightPos := Box3dMiddle(Scene.BoundingBox);
      LightPos[0] += Scene.BoundingBox[1][0] - Scene.BoundingBox[0][0] * 2;
    end;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.Navigator := Scene.CreateNavigator(CameraRadius);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnIdle := @Idle;

    CalculateSHBasisValues;

    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
