{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple Precomputed Radiance Transfer implementation.
  Self-shadowing with diffuse lighting.

  Navigate with mouse of keyboard (like view3dscene in Examine mode).
  AWSD, Q, Shift+Q move the light.
  R, Shift+R change light radius.
}

program radiance_transfer;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation, Keys,
  KambiFilesUtils, VRMLErrors, SphericalHarmonics, Math;

var
  Scene: TVRMLGLScene;
  CameraRadius: Single;
  ShowSimpleOcclusion: boolean;
  LightRadius: Single;
  LightPos: TVector3Single;

procedure Draw(Glwin: TGLWindow);

  procedure DrawLight(ForMap: boolean);
  begin
    glPushMatrix;
      glTranslatev(LightPos);

      if not ForMap then
      begin
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_BLEND);
        glColor4f(1, 1, 0, 0.1);
      end else
        glColor3f(1, 1, 1);

      KamGluSphere(LightRadius, 10, 10);

      if not ForMap then
        glDisable(GL_BLEND);
    glPopMatrix;
  end;

const
  LightMapSize = 16;

  procedure DrawLightMap(const MapX, MapY, DirX, DirY, DirZ,
    UpX, UpY, UpZ: Integer);
  var
    P: TVector3Single;
  begin
    { We have to clear the buffer first. Clearing with glClear is fast,
      but it must be clipped with scissor (glViewport does not clip glClear). }
    glScissor(MapX, MapY, LightMapSize, LightMapSize);
    glEnable(GL_SCISSOR_TEST);
      glClear(GL_COLOR_BUFFER_BIT);
    glDisable(GL_SCISSOR_TEST);

    glViewport(MapX, MapY, LightMapSize, LightMapSize);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix;
      glLoadIdentity;
      gluPerspective(90, 1, 0.01, 100);
      glMatrixMode(GL_MODELVIEW);

      glLoadIdentity;
      P := Box3dMiddle(Scene.BoundingBox);
      gluLookDirv(P, Vector3Single(DirX, DirY, DirZ), Vector3Single(UpX, UpY, UpZ));
      DrawLight(true);

      glMatrixMode(GL_PROJECTION);
    glPopMatrix;
    glMatrixMode(GL_MODELVIEW);
  end;

begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);
  Scene.Render(nil, tgAll);

  DrawLight(false);

  if not IsEmptyBox3d(Scene.BoundingBox) then
  begin
    DrawLightMap(10                   , 100,  1,  0, 0, 0, 0, 1);
    DrawLightMap(10 +     LightMapSize, 100,  0, -1, 0, 0, 0, 1);
    DrawLightMap(10 + 2 * LightMapSize, 100, -1,  0, 0, 0, 0, 1);
    DrawLightMap(10 + 3 * LightMapSize, 100,  0,  1, 0, 0, 0, 1);

    DrawLightMap(10, 100 + LightMapSize, 0, 0,  1,  -1, 0, 0);
    DrawLightMap(10, 100 - LightMapSize, 0, 0, -1,   1, 0, 0);

    glViewport(0, 0, Glwin.Width, Glwin.Height);
  end;
end;

procedure Init(Glwin: TGLWindow);
begin
//  glEnable(GL_LIGHTING);
//  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox, CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function DoRadianceTransfer(Node: TVRMLGeometryNode;
      RadianceTransfer: PSingle;
      const RadianceTransferCount: Cardinal): TVector3Single;
  end;

function THelper.DoRadianceTransfer(Node: TVRMLGeometryNode;
  RadianceTransfer: PSingle;
  const RadianceTransferCount: Cardinal): TVector3Single;
var
  F: Float;
begin
  if {TODO}{ShowSimpleOcclusion}true then
  begin
    Assert(RadianceTransferCount > 0);
    F := RadianceTransfer[0] / (SHBasis0 * 2 * Pi);
    Result := Vector3Single(F, F, F);
  end else
  begin
    { TODO }
  end;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: ShowSimpleOcclusion := not ShowSimpleOcclusion;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

procedure Idle(Glwin: TGLWindow);

  procedure ChangeLightPosition(Coord, Change: Integer);
  begin
    LightPos[Coord] += Change * Glwin.Fps.IdleSpeed * 50 /
      { scale by Box3dAvgSize, to get similar move on all models }
      Box3dAvgSize(Scene.BoundingBox) / 100;
    Glwin.PostRedisplay;
  end;

  procedure ChangeLightRadius(Change: Float);
  begin
    LightRadius *= Power(Change, Glwin.Fps.IdleSpeed);
    Glwin.PostRedisplay;
  end;

begin
  if Glwin.KeysDown[K_A] then ChangeLightPosition(0, -1);
  if Glwin.KeysDown[K_D] then ChangeLightPosition(0,  1);
  if Glwin.KeysDown[K_S] then ChangeLightPosition(1, -1);
  if Glwin.KeysDown[K_W] then ChangeLightPosition(1,  1);

  if Glwin.KeysDown[K_Q] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightPosition(2,  1) else
      ChangeLightPosition(2, -1);
  end;

  if Glwin.KeysDown[K_R] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightRadius(1/1.8) else
      ChangeLightRadius(1.8);
  end;
end;

var
  M: TMenu;
begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roNone);
    Scene.Attributes.OnRadianceTransfer := @THelper(nil).DoRadianceTransfer;

    if IsEmptyBox3d(Scene.BoundingBox) then
    begin
      LightRadius := 1;
      LightPos := Vector3Single(2, 0, 0);
    end else
    begin
      LightRadius := Box3dAvgSize(Scene.BoundingBox) / 3;
      LightPos := Box3dMiddle(Scene.BoundingBox);
      LightPos[0] += Scene.BoundingBox[1][0] - Scene.BoundingBox[0][0] * 2;
    end;

    Glw.MainMenu := TMenu.Create('Main menu');
    M := TMenu.Create('_Program');
      M.Append(TMenuItemChecked.Create('_Show simple occlusion (useful when --sh-basis-count=1)', 10,
        ShowSimpleOcclusion, true));
      Glw.MainMenu.Append(M);

    Glw.Navigator := Scene.CreateNavigator(CameraRadius);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnIdle := @Idle;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
