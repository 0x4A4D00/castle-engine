{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Shadow fields demo. See README.

  Navigate with mouse or keyboard (like view3dscene in Examine mode).

  Change by menu which object you're actually navigating --- by default
  you just navigate the whole scene.

  When you navigate the shadow caster
  or light source, you can only move the object
  (drag with middle or right mouse button), rotations/scaling are not used,
  since not implemented yet.
  They would require rotating/scaling before looking into shadow field,
  and rotating of SH --- this is just not implemented now). }

program shadow_fields;

uses SysUtils, GL, KambiGLUtils, VectorMath, Boxes3d,
  GLWindow, Glw_Navigated, VRMLGLScene, VRMLErrors, Navigation,
  ShadowFields, KambiUtils, CubeEnvMap, VRMLNodes,
  SphericalHarmonics;

var
  CameraRadius: Single;
  SceneCaster, SceneReceiver, SceneLocalLight: TVRMLGLScene;
  CasterOOF: TShadowField;
  LocalLightSRF: TShadowField;

  UseShadowFields: boolean = true;
  UseLighting: boolean = true;
  UseSH: boolean = true;
  UseInterpolation: TSFInterpolation = siLinearRadius;

type
  TNavigatorType = (ntAll, ntCaster, ntLocalLight, ntSFExplorer);

var
  Navigator: TNavigatorType = ntAll;
  NavigatorRadio: array [TNavigatorType] of TMenuItemRadio;
  NavigatorAll: TNavigator;
  NavigatorCaster: TExamineNavigator;
  NavigatorLocalLight: TExamineNavigator;
  NavigatorSFExplorer: TExamineNavigator;

procedure NavigatorChanged;
begin
  case Navigator of
    ntAll       : Glw.Navigator := NavigatorAll;
    ntCaster    : Glw.Navigator := NavigatorCaster;
    ntLocalLight: Glw.Navigator := NavigatorLocalLight;
    ntSFExplorer: Glw.Navigator := NavigatorSFExplorer;
    else raise EInternalError.Create('Navigator?');
  end;
  if NavigatorRadio[Navigator] <> nil then
    NavigatorRadio[Navigator].Checked := true;
end;

procedure Draw(Glwin: TGLWindow);

  procedure DrawSFExplorerMaps;
  const
    Scale = 3;

    procedure DrawOneMap(Field: TShadowField;
      const FieldMoveAmount: TVector3Single;
      const ShiftX, ShiftY: Integer);
    var
      Map: PEnvMapByte;
      Side: TEnvMapSide;
    begin
      Map := Field.EnvMapFromPoint(VectorSubtract(
        NavigatorSFExplorer.MoveAmount, FieldMoveAmount));
      if Map <> nil then
      begin
        for Side := Low(Side) to High(Side) do
        begin
          SetWindowPos(EnvMapInfo[Side].ScreenX * Scale + ShiftX,
                       EnvMapInfo[Side].ScreenY * Scale + ShiftY);
          { Since ordering of bytes in our env maps is matching OpenGL
            pixel ordering, I can just draw these like TGrayscaleImage
            by glDrawPixels. }
          glDrawPixels(EnvMapSize, EnvMapSize, GL_LUMINANCE,
            GL_UNSIGNED_BYTE, @(Map^[Side]));
        end;
      end;
    end;

  begin
    glPixelZoom(Scale, Scale);

    DrawOneMap(CasterOOF, NavigatorCaster.MoveAmount, 100, 100);
    DrawOneMap(LocalLightSRF, NavigatorLocalLight.MoveAmount, 100, 300);

    glPixelZoom(1, 1);
  end;

begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(NavigatorAll.Matrix);

  if UseLighting then glEnable(GL_LIGHTING);
  SceneReceiver.Render(nil, tgAll);

  glEnable(GL_LIGHTING); { shadow caster is always lit }
  glPushMatrix;
    glTranslatev(NavigatorCaster.MoveAmount);
    SceneCaster.Render(nil, tgAll);
  glPopMatrix;

  glPushMatrix;
    glTranslatev(NavigatorLocalLight.MoveAmount);
    SceneLocalLight.Render(nil, tgAll);
  glPopMatrix;

  glDisable(GL_LIGHTING);

  glEnable(GL_DEPTH_TEST);
    glColorv(Blue3Single);
    glBegin(GL_POINTS);
      glVertexv(NavigatorSFExplorer.MoveAmount);
    glEnd;
  glDisable(GL_DEPTH_TEST);

  DrawSFExplorerMaps;
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHT0);
  glPointSize(10);
end;

procedure Close(Glwin: TGLWindow);
begin
  SceneCaster.CloseGL;
  SceneReceiver.CloseGL;
  SceneLocalLight.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  SceneReceiver.GLProjection(Glw.Navigator, SceneReceiver.BoundingBox,
    CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function VertexColor(Node: TVRMLGeometryNode;
      State: TVRMLGraphTraverseState;
      const VertexPosition: TVector3Single): TVector3Single;
  end;

function THelper.VertexColor(Node: TVRMLGeometryNode;
  State: TVRMLGraphTraverseState;
  const VertexPosition: TVector3Single): TVector3Single;
const
  LocalLightIntensity = 50;
  { TODO: this is needed to make results with CalculateByEnvMaps
    and CalculateBySH. Why? I thought I normalized all integrals
    correctly. }
  SHLocalLightIntensity = 4*Pi;
var
  Position: TVector3Single;

  procedure CalculateByEnvMaps;
  var
    CasterMap, LocalLightMap: PEnvMapByte;
    B: LongWord;
    Side: TEnvMapSide;
    Pixel: Cardinal;
  begin
    CasterMap := CasterOOF.EnvMapFromPoint(VectorSubtract(
      Position, NavigatorCaster.MoveAmount));

    LocalLightMap := LocalLightSRF.EnvMapFromPoint(VectorSubtract(
      Position, NavigatorLocalLight.MoveAmount));

    if LocalLightMap = nil then
      { Too far from light }
      Result := Vector3Single(0, 0, 0) else
    begin
      { TODO: we completely ignore here BRDF and cos() for light equations!
        TODO: we don't really have env light now:
          - no env light intensity.
          - environ light may have non-const intensity over the sphere.
            calc it's env map, like for PRT. }

      B := 0;
      if CasterMap = nil then
      begin
        { Too far from shadow caster, so just integrate over the light }

        for Side := Low(Side) to High(Side) do
          for Pixel := 0 to Sqr(EnvMapSize) - 1 do
            B += LocalLightMap^[Side, Pixel];
      end else
      begin
        { This loop is the time bottleneck of the whole algorithm.
          This must work extra-fast.
          To do this, we calculate everything in int values.

          To multiply two bytes (that represent 0..1 floats) we can just
          multiply them normally, then divide by 256. Actually, this division
          can be done only once, after the loop.

          It's important to make sure that B can hold all these values:
          it's 6 * 16^2 of maximum High(Word) = 2^16 values.
          Since B is LongWord (max 2^32), we're Ok.
          }

        for Side := Low(Side) to High(Side) do
          for Pixel := 0 to Sqr(EnvMapSize) - 1 do
            B += Word(LocalLightMap^[Side, Pixel]) *
                          CasterMap^[Side, Pixel];

        B := B div 256;
      end;

      { normalize B, apply LocalLightIntensity }
      Result[0] := (B / 255) *
        LocalLightIntensity / (6 * Sqr(EnvMapSize));
      Result[1] := Result[0];
      Result[2] := Result[0];
    end;
  end;

  procedure CalculateBySH;
  const
    { shadow fields always have MaxSHBasis recorded.
      But you can use less here, to speed up.
      TODO: use this, compare various values. }
    SHCount = MaxSHBasis;
  var
    CasterVector, LocalLightVector: PSHVectorSingle;
    B: Single;
    LM: Cardinal;
  begin
    CasterVector := CasterOOF.SHVectorFromPoint(VectorSubtract(
      Position, NavigatorCaster.MoveAmount), UseInterpolation, SHCount);

    LocalLightVector := LocalLightSRF.SHVectorFromPoint(VectorSubtract(
      Position, NavigatorLocalLight.MoveAmount), UseInterpolation, SHCount);

    if LocalLightVector = nil then
      { Too far from light }
      Result := Vector3Single(0, 0, 0) else
    begin
      B := 0;

      if CasterVector = nil then
      begin
        { Too far from shadow caster, so just assume like caster oof
          is pure white. So make a double product with SH vector representing
          pure white environment map. See README notes at the end --- such
          vector is just zero, except for first factor which is equal to
          SHBasis0. }

        B += LocalLightVector^[0] * SHBasis0;
      end else
      begin
        for LM := 0 to SHCount - 1 do
          B += LocalLightVector^[LM] *
                   CasterVector^[LM];
      end;

      { apply LocalLightIntensity }
      Result[0] := B * LocalLightIntensity * SHLocalLightIntensity;
      Result[1] := Result[0];
      Result[2] := Result[0];
    end;
  end;

begin
  Position := MatrixMultPoint(State.Transform, VertexPosition);

  if UseSH then
    CalculateBySH else
    CalculateByEnvMaps;
end;

procedure UseShadowFieldsChanged;
begin
  if UseShadowFields then
    SceneReceiver.Attributes.OnVertexColor := @THelper(nil).VertexColor else
    SceneReceiver.Attributes.OnVertexColor := nil;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
  RadioGroup: TMenuItemRadioGroup;

  procedure AddNavigatorMenu(const Caption: string; const Nav: TNavigatorType);
  begin
    NavigatorRadio[Nav] := TMenuItemRadio.Create(Caption,
      10 + Ord(Nav), Navigator = Nav, true);
    if RadioGroup = nil then
      RadioGroup := NavigatorRadio[Nav].Group else
      NavigatorRadio[Nav].Group := RadioGroup;
    M.Append(NavigatorRadio[Nav]);
  end;

  procedure AddInterpolationMenu(const Caption: string; const I: TSFInterpolation);
  var
    Radio: TMenuItemRadio;
  begin
    Radio := TMenuItemRadio.Create(Caption,
      30 + Ord(I), UseInterpolation = I, true);
    if RadioGroup = nil then
      RadioGroup := Radio.Group else
      Radio.Group := RadioGroup;
    M.Append(Radio);
  end;

begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItemChecked.Create('_Shadow fields', 100, UseShadowFields, true));
    M.Append(TMenuItemChecked.Create('Use spherical _harmonics', 120, UseSH, true));
    M.Append(TMenuSeparator.Create);
    RadioGroup := nil;
    AddInterpolationMenu('_Interpolation none', siNone);
    AddInterpolationMenu('Interpolation linear (radius)', siLinearRadius);
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('Apply OpenGL _Lighting', 110, UseLighting, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);

  M := TMenu.Create('_Navigate');
    RadioGroup := nil;
    AddNavigatorMenu('_All', ntAll);
    AddNavigatorMenu('Shadow _caster', ntCaster);
    AddNavigatorMenu('Local _light source', ntLocalLight);
    AddNavigatorMenu('_Shadow fields explorer', ntSFExplorer);

    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Next', 20, K_Space));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10..19:
      begin
        Navigator := TNavigatorType(Item.IntData - 10);
        NavigatorChanged;
      end;

    20:
      begin
        if Navigator = High(Navigator) then
          Navigator := Low(Navigator) else
          Navigator := Succ(Navigator);
        NavigatorChanged;
      end;

    30..39: UseInterpolation := TSFInterpolation(Item.IntData - 30);

    100:
      begin
        UseShadowFields := not UseShadowFields;
        UseShadowFieldsChanged;
      end;

    110: UseLighting := not UseLighting;
    120: UseSH := not UseSH;

    200: Glwin.Close;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

var
  { TODO: allow to change this by command-line }
  ShadowCasterFileName: string = 'models/humanoid_stand.wrl';
  ShadowReceiverFileName: string = 'models/plane.wrl';
  LocalLightFileName: string = 'models/sphere.wrl';
    //'models/stretched_cube.wrl';

  Box: TBox3d;
  V: TVector3Single;
begin
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    SceneCaster := TVRMLGLScene.Create(ShadowCasterFileName, roSceneAsAWhole);
    SceneReceiver := TVRMLGLScene.Create(ShadowReceiverFileName, roNone);
    SceneLocalLight := TVRMLGLScene.Create(LocalLightFileName, roSceneAsAWhole);

    CasterOOF := TShadowField.Create;
    CasterOOF.LoadFromFile(ChangeFileExt(ShadowCasterFileName, ShadowFieldExt));

    LocalLightSRF := TShadowField.Create;
    LocalLightSRF.LoadFromFile(ChangeFileExt(LocalLightFileName, ShadowFieldExt));

    { initialize navigators }

    NavigatorAll := SceneReceiver.CreateNavigator(CameraRadius);
    NavigatorAll.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    NavigatorCaster := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    NavigatorCaster.ModelBox := SceneCaster.BoundingBox;

    NavigatorLocalLight := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    NavigatorLocalLight.ModelBox := SceneLocalLight.BoundingBox;

    { calculate starting local light position,
      and set this as NavigatorLocalLight.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      V := Vector3Single(0, 0, 1);
    end else
    begin
      V := Box3dMiddle(Box);
      V[0] := Box[0][0];
    end;
    NavigatorLocalLight.MoveAmount := V;

    NavigatorSFExplorer := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    { use SceneCaster.BoundingBox for light's box, this determines the speed
      of moving light source with mouse. }
    NavigatorSFExplorer.ModelBox := SceneCaster.BoundingBox;

    { calculate starting sf explorer position,
      and set this as NavigatorSFExplorer.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      V := Vector3Single(0, 0, 1);
    end else
    begin
      V := Box3dMiddle(Box);
      V[0] := Box[1][0];
    end;
    NavigatorSFExplorer.MoveAmount := V;

    Glw.OwnsNavigator := false;
    NavigatorChanged;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;

    { initialize UseShadowFieldsChanged }
    UseShadowFieldsChanged;

    InitializeSHBasisMap;

    Glw.InitLoop('shadow_fields', @Draw);
  finally
    FreeAndNil(SceneCaster);
    FreeAndNil(SceneReceiver);
    FreeAndNil(SceneLocalLight);
    FreeAndNil(NavigatorAll);
    FreeAndNil(NavigatorCaster);
    FreeAndNil(NavigatorLocalLight);
    FreeAndNil(NavigatorSFExplorer);
    FreeAndNil(CasterOOF);
    FreeAndNil(LocalLightSRF);
  end;
end.
