{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Shadow fields demo. See README.

  Navigate with mouse or keyboard (like view3dscene in Examine mode).

  Change by menu which object you're actually navigating --- by default
  you just navigate the whole scene.

  When you navigate the shadow caster
  or light source, you can only move the object
  (drag with middle or right mouse button), rotations/scaling are not used,
  since not implemented yet.
  They would require rotating/scaling before looking into shadow field,
  and rotating of SH --- this is just not implemented now). }

program shadow_fields;

uses SysUtils, GL, KambiGLUtils, VectorMath, Boxes3d,
  GLWindow, Glw_Navigated, VRMLGLScene, VRMLErrors, Navigation,
  ShadowFields, KambiUtils, CubeEnvMap, VRMLNodes;


var
  CameraRadius: Single;
  SceneCaster, SceneReceiver: TVRMLGLScene;
  CasterOOF: TShadowField;

  UseShadowFields: boolean = true;

type
  TNavigatorType = (ntAll, ntCaster, ntLocalLight, ntSFExplorer);

var
  Navigator: TNavigatorType = ntAll;
  NavigatorRadio: array [TNavigatorType] of TMenuItemRadio;
  NavigatorAll: TNavigator;
  NavigatorCaster: TExamineNavigator;
  NavigatorLocalLight: TExamineNavigator;
  NavigatorSFExplorer: TExamineNavigator;

procedure NavigatorChanged;
begin
  case Navigator of
    ntAll       : Glw.Navigator := NavigatorAll;
    ntCaster    : Glw.Navigator := NavigatorCaster;
    ntLocalLight: Glw.Navigator := NavigatorLocalLight;
    ntSFExplorer: Glw.Navigator := NavigatorSFExplorer;
    else raise EInternalError.Create('Navigator?');
  end;
  if NavigatorRadio[Navigator] <> nil then
    NavigatorRadio[Navigator].Checked := true;
end;

procedure Draw(Glwin: TGLWindow);

  procedure DrawSFExplorerMaps;
  const
    Scale = 3;
  var
    Map: PEnvMap;
    Side: TEnvMapSide;
  begin
    glPixelZoom(Scale, Scale);
    Map := CasterOOF.EnvMapFromPoint(VectorSubtract(
      NavigatorSFExplorer.MoveAmount,
      NavigatorCaster.MoveAmount));
    if Map <> nil then
    begin
      for Side := Low(Side) to High(Side) do
      begin
        SetWindowPos(EnvMapInfo[Side].ScreenX * Scale + 100,
                     EnvMapInfo[Side].ScreenY * Scale + 100);
        { Since ordering of bytes in our env maps is matching OpenGL
          pixel ordering, I can just draw these like TGrayscaleImage
          by glDrawPixels. }
        glDrawPixels(EnvMapSize, EnvMapSize, GL_LUMINANCE,
          GL_UNSIGNED_BYTE, @(Map^[Side]));
      end;
    end;
    glPixelZoom(1, 1);
  end;

const
  UseLighting = true;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(NavigatorAll.Matrix);

  if UseLighting then glEnable(GL_LIGHTING);
  SceneReceiver.Render(nil, tgAll);

  glEnable(GL_LIGHTING); { shadow caster is always lit }
  glPushMatrix;
    glTranslatev(NavigatorCaster.MoveAmount);
    SceneCaster.Render(nil, tgAll);
  glPopMatrix;

  glDisable(GL_LIGHTING);
  glEnable(GL_DEPTH_TEST);
    glColorv(Yellow3Single);
    glBegin(GL_POINTS);
      glVertexv(NavigatorLocalLight.MoveAmount);
    glEnd;
  glDisable(GL_DEPTH_TEST);

  glEnable(GL_DEPTH_TEST);
    glColorv(Blue3Single);
    glBegin(GL_POINTS);
      glVertexv(NavigatorSFExplorer.MoveAmount);
    glEnd;
  glDisable(GL_DEPTH_TEST);

  DrawSFExplorerMaps;
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHT0);
  glPointSize(10);
end;

procedure Close(Glwin: TGLWindow);
begin
  SceneCaster.CloseGL;
  SceneReceiver.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  SceneReceiver.GLProjection(Glw.Navigator, SceneReceiver.BoundingBox,
    CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function VertexColor(Node: TVRMLGeometryNode;
      State: TVRMLGraphTraverseState;
      const VertexPosition: TVector3Single): TVector3Single;
  end;

function THelper.VertexColor(Node: TVRMLGeometryNode;
  State: TVRMLGraphTraverseState;
  const VertexPosition: TVector3Single): TVector3Single;
var
  Map: PEnvMap;
  B: Float;
  Side: TEnvMapSide;
  Pixel: Cardinal;
begin
  Map := CasterOOF.EnvMapFromPoint(VectorSubtract(
    MatrixMultPoint(State.Transform, VertexPosition),
    NavigatorCaster.MoveAmount));
  if Map = nil then
    Result := Vector3Single(1, 1, 1) else
  begin
    B := 0;
    for Side := Low(Side) to High(Side) do
      for Pixel := 0 to Sqr(EnvMapSize) - 1 do
        B += (Map^[Side, Pixel] / 255) { TODO: * light intensity };
    { normalize B }
    B /= 6 * Sqr(EnvMapSize);
    Result[0] := B;
    Result[1] := Result[0];
    Result[2] := Result[0];
  end;
end;

procedure UseShadowFieldsChanged;
begin
  if UseShadowFields then
    SceneReceiver.Attributes.OnVertexColor := @THelper(nil).VertexColor else
    SceneReceiver.Attributes.OnVertexColor := nil;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
  NavRadioGroup: TMenuItemRadioGroup;

  procedure AddNavigatorMenu(const Caption: string; const Nav: TNavigatorType);
  begin
    NavigatorRadio[Nav] := TMenuItemRadio.Create(Caption,
      10 + Ord(Nav), Navigator = Nav, true);
    if NavRadioGroup = nil then
      NavRadioGroup := NavigatorRadio[Nav].Group else
      NavigatorRadio[Nav].Group := NavRadioGroup;
    M.Append(NavigatorRadio[Nav]);
  end;

begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItemChecked.Create('_Shadow fields', 100, UseShadowFields, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);

  M := TMenu.Create('_Navigate');
    NavRadioGroup := nil;
    AddNavigatorMenu('_All', ntAll);
    AddNavigatorMenu('Shadow _caster', ntCaster);
    AddNavigatorMenu('Local _light source', ntLocalLight);
    AddNavigatorMenu('_Shadow fields explorer', ntSFExplorer);

    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Next', 20, K_Space));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10..19:
      begin
        Navigator := TNavigatorType(Item.IntData - 10);
        NavigatorChanged;
      end;

    100:
      begin
        UseShadowFields := not UseShadowFields;
        UseShadowFieldsChanged;
      end;

    20:
      begin
        if Navigator = High(Navigator) then
          Navigator := Low(Navigator) else
          Navigator := Succ(Navigator);
        NavigatorChanged;
      end;

    200: Glwin.Close;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

var
  { TODO: allow to change this by command-line }
  ShadowCasterFileName: string = 'models/humanoid_stand.wrl';
  ShadowReceiverFileName: string = 'models/plane.wrl';
  CasterOOFFileName: string = 'models/humanoid_stand.shadow_field';

  Box: TBox3d;
  V: TVector3Single;
begin
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    SceneCaster := TVRMLGLScene.Create(ShadowCasterFileName, roSceneAsAWhole);
    SceneReceiver := TVRMLGLScene.Create(ShadowReceiverFileName, roNone);

    CasterOOF := TShadowField.Create;
    CasterOOF.LoadFromFile(CasterOOFFileName);

    { initialize navigators }

    NavigatorAll := SceneReceiver.CreateNavigator(CameraRadius);
    NavigatorAll.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    NavigatorCaster := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    NavigatorCaster.ModelBox := SceneCaster.BoundingBox;

    NavigatorLocalLight := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    { use SceneCaster.BoundingBox for light's box, this determines the speed
      of moving light source with mouse. }
    NavigatorLocalLight.ModelBox := SceneCaster.BoundingBox;

    { calculate starting local light position,
      and set this as NavigatorLocalLight.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      V := Vector3Single(0, 0, 1);
    end else
    begin
      V := Box3dMiddle(Box);
      V[0] := Box[0][0];
    end;
    NavigatorLocalLight.MoveAmount := V;

    NavigatorSFExplorer := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    { use SceneCaster.BoundingBox for light's box, this determines the speed
      of moving light source with mouse. }
    NavigatorSFExplorer.ModelBox := SceneCaster.BoundingBox;

    { calculate starting sf explorer position,
      and set this as NavigatorSFExplorer.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      V := Vector3Single(0, 0, 1);
    end else
    begin
      V := Box3dMiddle(Box);
      V[0] := Box[1][0];
    end;
    NavigatorSFExplorer.MoveAmount := V;

    Glw.OwnsNavigator := false;
    NavigatorChanged;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;

    { initialize UseShadowFieldsChanged }
    UseShadowFieldsChanged;

    Glw.InitLoop('shadow_fields', @Draw);
  finally
    FreeAndNil(SceneCaster);
    FreeAndNil(SceneReceiver);
    FreeAndNil(NavigatorAll);
    FreeAndNil(NavigatorCaster);
    FreeAndNil(NavigatorLocalLight);
    FreeAndNil(NavigatorSFExplorer);
    FreeAndNil(CasterOOF);
  end;
end.
