{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Shadow fields demo. See README.

  Navigate with mouse or keyboard (like view3dscene in Examine mode).

  Change by menu which object you're actually navigating --- by default
  you just navigate the whole scene. When you navigate the shadow caster
  or light source, you can only move the object (drag with middle or
  right mouse button), rotations/scaling are not used (since not implemented
  yet, they would require rotating/scaling before looking into shadow field,
  and rotating of SH --- this is just not implemented now). }
program shadow_fields;

uses SysUtils, GL, KambiGLUtils, VectorMath, Boxes3d,
  GLWindow, Glw_Navigated, VRMLGLScene, VRMLErrors, Navigation,
  ShadowFields;

var
  CameraRadius: Single;
  SceneCaster, SceneReceiver: TVRMLGLScene;
  CasterOOF: TShadowField;

  NavigatorAll: TNavigator;
  NavigatorCaster: TExamineNavigator;
  NavigatorLocalLight: TExamineNavigator;

procedure Draw(Glwin: TGLWindow);
const
  UseLighting = true;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(NavigatorAll.Matrix);

  if UseLighting then glEnable(GL_LIGHTING);
  SceneReceiver.Render(nil, tgAll);

  glEnable(GL_LIGHTING); { shadow caster is always lit }
  glPushMatrix;
    glTranslatev(NavigatorCaster.MoveAmount);
    SceneCaster.Render(nil, tgAll);
  glPopMatrix;

  glDisable(GL_LIGHTING);
  glEnable(GL_DEPTH_TEST);
    glColorv(Yellow3Single);
    glBegin(GL_POINTS);
      glVertexv(NavigatorLocalLight.MoveAmount);
    glEnd;
  glDisable(GL_DEPTH_TEST);
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHT0);
  glPointSize(10);
end;

procedure Close(Glwin: TGLWindow);
begin
  SceneCaster.CloseGL;
  SceneReceiver.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  SceneReceiver.GLProjection(Glw.Navigator, SceneReceiver.BoundingBox,
    CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
  Radio: TMenuItemRadio;
  RadioGroup: TMenuItemRadioGroup;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');

    Radio := TMenuItemRadio.Create('Navigate _all', 10, Glw.Navigator = NavigatorAll, true);
    RadioGroup := Radio.Group;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('Navigate shadow _caster', 11, Glw.Navigator = NavigatorCaster, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('Navigate _light source', 12, Glw.Navigator = NavigatorLocalLight, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    M.Append(TMenuSeparator.Create);

    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: Glw.Navigator := NavigatorAll;
    11: Glw.Navigator := NavigatorCaster;
    12: Glw.Navigator := NavigatorLocalLight;

    200: Glwin.Close;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

var
  { TODO: allow to change this by command-line }
  ShadowCasterFileName: string = 'models/humanoid_stand.wrl';
  ShadowReceiverFileName: string = 'models/plane.wrl';
  CasterOOFFileName: string = 'models/humanoid_stand.shadow_field';

  Box: TBox3d;
  LocalLightPos: TVector3Single;
begin
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    SceneCaster := TVRMLGLScene.Create(ShadowCasterFileName, roSceneAsAWhole);
    SceneReceiver := TVRMLGLScene.Create(ShadowReceiverFileName, roNone);

    CasterOOF := TShadowField.Create;
    CasterOOF.LoadFromFile(CasterOOFFileName);

    { initialize navigators }

    NavigatorAll := SceneReceiver.CreateNavigator(CameraRadius);
    NavigatorAll.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    NavigatorCaster := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    NavigatorCaster.ModelBox := SceneCaster.BoundingBox;

    NavigatorLocalLight := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    { use SceneCaster.BoundingBox for light's box, this determines the speed
      of moving light source with mouse. }
    NavigatorLocalLight.ModelBox := SceneCaster.BoundingBox;

    { calculate starting LocalLightPos,
      and set this as NavigatorLocalLight.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      LocalLightPos := Vector3Single(0, 0, 1);
    end else
    begin
      LocalLightPos := Box3dMiddle(Box);
      LocalLightPos[0] := Box[0][0];
    end;
    NavigatorLocalLight.MoveAmount := LocalLightPos;

    Glw.Navigator := NavigatorAll;
    Glw.OwnsNavigator := false;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;

    Glw.InitLoop('shadow_fields', @Draw);
  finally
    FreeAndNil(SceneCaster);
    FreeAndNil(SceneReceiver);
    FreeAndNil(NavigatorAll);
    FreeAndNil(NavigatorCaster);
    FreeAndNil(NavigatorLocalLight);
    FreeAndNil(CasterOOF);
  end;
end.
