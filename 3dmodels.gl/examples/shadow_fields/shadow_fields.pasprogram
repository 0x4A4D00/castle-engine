{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Shadow fields demo. See README.

  Navigate with mouse or keyboard (like view3dscene in Examine mode). }
program shadow_fields;

uses SysUtils, GL, KambiGLUtils, VectorMath, Boxes3d,
  GLWindow, Glw_Navigated, VRMLGLScene, VRMLErrors;

var
  CameraRadius: Single;
  SceneCaster, SceneReceiver: TVRMLGLScene;
  LocalLightPos: TVector3Single;

procedure Draw(Glwin: TGLWindow);
const
  UseLighting = true;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  if UseLighting then glEnable(GL_LIGHTING);
  SceneReceiver.Render(nil, tgAll);
  SceneCaster.Render(nil, tgAll);
  if UseLighting then glDisable(GL_LIGHTING);
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  SceneCaster.CloseGL;
  SceneReceiver.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  SceneReceiver.GLProjection(Glw.Navigator, SceneReceiver.BoundingBox,
    CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    200: Glwin.Close;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

var
  { TODO: allow to change this by command-line }
  ShadowCasterFileName: string = 'models/humanoid_stand.wrl';
  ShadowReceiverFileName: string = 'models/plane.wrl';
  Box: TBox3d;
begin
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    SceneCaster := TVRMLGLScene.Create(ShadowCasterFileName, roSceneAsAWhole);
    SceneReceiver := TVRMLGLScene.Create(ShadowReceiverFileName, roNone);

    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      LocalLightPos := Vector3Single(0, 0, 1);
    end else
    begin
      LocalLightPos := Box3dMiddle(Box);
      LocalLightPos[0] := Box[0][0];
    end;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.Navigator := SceneReceiver.CreateNavigator(CameraRadius);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;

    Glw.InitLoop('shadow_fields', @Draw);
  finally
    FreeAndNil(SceneCaster);
    FreeAndNil(SceneReceiver);
  end;
end.
