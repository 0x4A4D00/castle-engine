{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Shadow fields demo. See README.

  Navigate with mouse or keyboard (like view3dscene in Examine mode).

  Change by menu which object you're actually navigating --- by default
  you just navigate the whole scene.

  When you navigate the shadow caster
  or light source, you can only move the object
  (drag with middle or right mouse button), rotations/scaling are not used,
  since not implemented yet.
  They would require rotating/scaling before looking into shadow field,
  and rotating of SH --- this is just not implemented now). }

program shadow_fields;

uses SysUtils, GL, KambiGLUtils, VectorMath, Boxes3d,
  GLWindow, Glw_Navigated, VRMLGLScene, VRMLErrors, Navigation,
  ShadowFields, KambiUtils, CubeEnvMap, VRMLNodes;

var
  CameraRadius: Single;
  SceneCaster, SceneReceiver: TVRMLGLScene;
  CasterOOF: TShadowField;

  NavigatorAll: TNavigator;
  NavigatorCaster: TExamineNavigator;
  NavigatorLocalLight: TExamineNavigator;
  NavigatorSFExplorer: TExamineNavigator;

  UseShadowFields: boolean = true;

procedure Draw(Glwin: TGLWindow);

  procedure DrawSFExplorerMaps;
  const
    Scale = 3;
  var
    Map: PEnvMap;
    Side: TEnvMapSide;
  begin
    glPixelZoom(Scale, Scale);
    Map := CasterOOF.EnvMapFromPoint(VectorSubtract(
      NavigatorSFExplorer.MoveAmount,
      NavigatorCaster.MoveAmount));
    if Map <> nil then
    begin
      for Side := Low(Side) to High(Side) do
      begin
        SetWindowPos(EnvMapInfo[Side].ScreenX * Scale + 100,
                     EnvMapInfo[Side].ScreenY * Scale + 100);
        { Since ordering of bytes in our env maps is matching OpenGL
          pixel ordering, I can just draw these like TGrayscaleImage
          by glDrawPixels. }
        glDrawPixels(EnvMapSize, EnvMapSize, GL_LUMINANCE,
          GL_UNSIGNED_BYTE, @(Map^[Side]));
      end;
    end;
    glPixelZoom(1, 1);
  end;

const
  UseLighting = true;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(NavigatorAll.Matrix);

  if UseLighting then glEnable(GL_LIGHTING);
  SceneReceiver.Render(nil, tgAll);

  glEnable(GL_LIGHTING); { shadow caster is always lit }
  glPushMatrix;
    glTranslatev(NavigatorCaster.MoveAmount);
    SceneCaster.Render(nil, tgAll);
  glPopMatrix;

  glDisable(GL_LIGHTING);
  glEnable(GL_DEPTH_TEST);
    glColorv(Yellow3Single);
    glBegin(GL_POINTS);
      glVertexv(NavigatorLocalLight.MoveAmount);
    glEnd;
  glDisable(GL_DEPTH_TEST);

  glEnable(GL_DEPTH_TEST);
    glColorv(Blue3Single);
    glBegin(GL_POINTS);
      glVertexv(NavigatorSFExplorer.MoveAmount);
    glEnd;
  glDisable(GL_DEPTH_TEST);

  DrawSFExplorerMaps;
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHT0);
  glPointSize(10);
end;

procedure Close(Glwin: TGLWindow);
begin
  SceneCaster.CloseGL;
  SceneReceiver.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  SceneReceiver.GLProjection(Glw.Navigator, SceneReceiver.BoundingBox,
    CameraRadius,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

type
  THelper = class
    function VertexColor(Node: TVRMLGeometryNode;
      State: TVRMLGraphTraverseState;
      const VertexPosition: TVector3Single): TVector3Single;
  end;

function THelper.VertexColor(Node: TVRMLGeometryNode;
  State: TVRMLGraphTraverseState;
  const VertexPosition: TVector3Single): TVector3Single;
begin
  Result[0] := PointsDistance(VertexPosition,
    Box3dMiddle(SceneReceiver.BoundingBox)) /
    Box3dAvgSize(SceneReceiver.BoundingBox);
  Result[1] := Result[0];
  Result[2] := Result[0];
end;

procedure UseShadowFieldsChanged;
begin
  if UseShadowFields then
    SceneReceiver.Attributes.OnVertexColor := @THelper(nil).VertexColor else
    SceneReceiver.Attributes.OnVertexColor := nil;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
  Radio: TMenuItemRadio;
  RadioGroup: TMenuItemRadioGroup;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItemChecked.Create('_Shadow fields', 100, UseShadowFields, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);

  M := TMenu.Create('_Navigate');

    Radio := TMenuItemRadio.Create('_All', 10, Glw.Navigator = NavigatorAll, true);
    RadioGroup := Radio.Group;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('Shadow _caster', 11, Glw.Navigator = NavigatorCaster, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('Local _light source', 12, Glw.Navigator = NavigatorLocalLight, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    Radio := TMenuItemRadio.Create('_Shadow fields explorer', 13, Glw.Navigator = NavigatorSFExplorer, true);
    Radio.Group := RadioGroup;
    M.Append(Radio);

    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Next', 20, K_Space));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: Glw.Navigator := NavigatorAll;
    11: Glw.Navigator := NavigatorCaster;
    12: Glw.Navigator := NavigatorLocalLight;
    13: Glw.Navigator := NavigatorSFExplorer;

    100:
      begin
        UseShadowFields := not UseShadowFields;
        UseShadowFieldsChanged;
      end;

    20: if Glw.Navigator = NavigatorAll then Glw.Navigator := NavigatorCaster else
        if Glw.Navigator = NavigatorCaster then Glw.Navigator := NavigatorLocalLight else
        if Glw.Navigator = NavigatorLocalLight then Glw.Navigator := NavigatorSFExplorer else
        if Glw.Navigator = NavigatorSFExplorer then Glw.Navigator := NavigatorAll else
          raise EInternalError.Create('Unknown Glw.Navigator next');

    200: Glwin.Close;
    else Exit;
  end;
  Glw.PostRedisplay;
end;

var
  { TODO: allow to change this by command-line }
  ShadowCasterFileName: string = 'models/humanoid_stand.wrl';
  ShadowReceiverFileName: string = 'models/plane.wrl';
  CasterOOFFileName: string = 'models/humanoid_stand.shadow_field';

  Box: TBox3d;
  V: TVector3Single;
begin
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    SceneCaster := TVRMLGLScene.Create(ShadowCasterFileName, roSceneAsAWhole);
    SceneReceiver := TVRMLGLScene.Create(ShadowReceiverFileName, roNone);

    CasterOOF := TShadowField.Create;
    CasterOOF.LoadFromFile(CasterOOFFileName);

    { initialize navigators }

    NavigatorAll := SceneReceiver.CreateNavigator(CameraRadius);
    NavigatorAll.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    NavigatorCaster := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    NavigatorCaster.ModelBox := SceneCaster.BoundingBox;

    NavigatorLocalLight := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    { use SceneCaster.BoundingBox for light's box, this determines the speed
      of moving light source with mouse. }
    NavigatorLocalLight.ModelBox := SceneCaster.BoundingBox;

    { calculate starting local light position,
      and set this as NavigatorLocalLight.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      V := Vector3Single(0, 0, 1);
    end else
    begin
      V := Box3dMiddle(Box);
      V[0] := Box[0][0];
    end;
    NavigatorLocalLight.MoveAmount := V;

    NavigatorSFExplorer := TExamineNavigator.Create(
      @Glw.PostRedisplayOnMatrixChanged);
    { use SceneCaster.BoundingBox for light's box, this determines the speed
      of moving light source with mouse. }
    NavigatorSFExplorer.ModelBox := SceneCaster.BoundingBox;

    { calculate starting sf explorer position,
      and set this as NavigatorSFExplorer.MoveAmount }
    Box := Box3dSum(SceneCaster.BoundingBox, SceneReceiver.BoundingBox);
    if IsEmptyBox3d(Box) then
    begin
      V := Vector3Single(0, 0, 1);
    end else
    begin
      V := Box3dMiddle(Box);
      V[0] := Box[1][0];
    end;
    NavigatorSFExplorer.MoveAmount := V;

    Glw.Navigator := NavigatorAll;
    Glw.OwnsNavigator := false;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;

    { initialize UseShadowFieldsChanged }
    UseShadowFieldsChanged;

    Glw.InitLoop('shadow_fields', @Draw);
  finally
    FreeAndNil(SceneCaster);
    FreeAndNil(SceneReceiver);
    FreeAndNil(NavigatorAll);
    FreeAndNil(NavigatorCaster);
    FreeAndNil(NavigatorLocalLight);
    FreeAndNil(NavigatorSFExplorer);
    FreeAndNil(CasterOOF);
  end;
end.
