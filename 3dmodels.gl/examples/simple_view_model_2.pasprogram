{
  Copyright 2003-2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ This is the next version of simple_view_model.pasprogram.
  If you want to learn how to use my units, you should first understand
  sources of simple_view_model.pasprogram, then move to this example.

  This version adds:

  1. Collision detection
  - constructing octrees, by "Scene.Spatial := ..."
  - doing collision detection using OctreeCollisions, see MoveAllowed procedure

  2. Rendering with frustum culling
  - scene is loaded with Optimization roSeparateShapes instead of roSceneAsAWhole
  - initializing Glw.Navigator.ProjectionMatrix (this is needed to get
    Glw.Navigator.Frustum)
  - using Glw.Navigator.Frustum and OctreeRendering to render the scene,
    see line "Scene.RenderFrustum"

  3. Tries to get default camera settings from VRML file
  - see Scene.GetPerspectiveViewpoint call

  (Note that in general, we could avoid Scene.GetPerspectiveViewpoint and
  Glw.WalkNav.Init calls and do this simpler by
    Glw.Navigator := Scene.CreateNavigator(CameraRadius);
  However, CreateNavigator may initialize Examine navigation.
  (depends on NavigationInfo node inside VRML model;
  if not existing (or is not a VRML model, like 3DS)
  this creates Examine always). So I wanted to show here how to do it
  more manually, always forcing Walk navigation.)

  4. Makes FPS timings right after starting the program correct:
  - uses Glw.OnBeforeDraw and Scene.PrepareRender(false)

  5. Allows the scene to use it's own lights:
  - see Scene.Attributes.UseLights line
}

program simple_view_model_2;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  ProgressUnit, ProgressConsole, KambiFilesUtils, VRMLTriangleOctree,
  VRMLErrors;

var
  Scene: TVRMLGLScene;
  { CameraRadius is needed for collision detection }
  CameraRadius: Single;

procedure BeforeDraw(Glwin: TGLWindow);
begin
  Scene.PrepareRender([tgAll], [prBoundingBox]);
end;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);
  Scene.RenderFrustum(Glw.Navigator.Frustum, tgAll);
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);

  procedure UpdateNavigatorProjectionMatrix;
  var
    ProjectionMatrix: TMatrix4f;
  begin
    glGetFloatv(GL_PROJECTION_MATRIX, @ProjectionMatrix);
    Glw.Navigator.ProjectionMatrix := ProjectionMatrix;
  end;

begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(45.0, glwin.Width/glwin.Height,
    CameraRadius * 0.6,
    Box3dMaxSize(Scene.BoundingBox) * 3.0);

  UpdateNavigatorProjectionMatrix;
end;

type
  THelperObj = class
    class function MoveAllowed(Navigator: TWalkNavigator;
      const ProposedNewPos: TVector3Single; out NewPos: TVector3Single;
      const BecauseOfGravity: boolean): boolean;
  end;

class function THelperObj.MoveAllowed(Navigator: TWalkNavigator;
  const ProposedNewPos: TVector3Single; out NewPos: TVector3Single;
  const BecauseOfGravity: boolean): boolean;
begin
  Result := Scene.OctreeCollisions.MoveAllowed(
    Navigator.CameraPos, ProposedNewPos, NewPos, CameraRadius,
    BecauseOfGravity);
end;

var
  //i: Integer;
  CamPos, CamDir, CamUp, GravityUp: TVector3Single;
begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1],
      {roSceneAsAWhole} roSeparateShapes);

    Writeln(Scene.Info(true, true, false));

    { Uncomment this to get some info about scene nodes:
    for i := 0 to Scene.Shapes.Count-1 do
      with Scene.Shapes[i] do
      begin
       Writeln(Format('Shape name ''%10s'' (''%20s'') : LocalBBox = %50s, BBox = %50s',
         [GeometryNode.NodeName, GeometryNode.NodeTypeName,
          Box3dToNiceStr(LocalBoundingBox), Box3dToNiceStr(BoundingBox)]));
      end;}

    { build octrees }
    Progress.UserInterface := ProgressConsoleInterface;
    Scene.TriangleOctreeProgressTitle := 'Building triangle octree';
    Scene.ShapeOctreeProgressTitle := 'Building Shape octree';
    Scene.Spatial := [ssRendering, ssDynamicCollisions];

    Scene.GetPerspectiveViewpoint(CamPos, CamDir, CamUp, GravityUp);

    { init Glw.Navigator }
    Glw.Navigator := TWalkNavigator.Create(@Glw.PostRedisplayOnMatrixChanged);
    Glw.WalkNav.Init(CamPos,
      VectorAdjustToLength(CamDir, Box3dAvgSize(Scene.BoundingBox) * 0.01*0.4),
      CamUp, GravityUp,
      0.0, 0.0 { unused, we don't use Gravity here });

    { init collision detection }
    if IsEmptyBox3d(Scene.BoundingBox) then
     CameraRadius := 1.0 { any non-zero dummy value } else
     CameraRadius := Box3dAvgSize(Scene.BoundingBox) * 0.01;
    Glw.WalkNav.OnMoveAllowed := @THelperObj(nil).MoveAllowed;

    { allow the scene to use it's own lights }
    Scene.Attributes.UseLights := true;
    Scene.Attributes.FirstGLFreeLight := 1;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnBeforeDraw := @BeforeDraw;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
