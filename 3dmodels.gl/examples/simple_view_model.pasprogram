{
  Copyright 2003-2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ This an example how to write the simplest VRML, 3DS and OBJ viewer
  using my units. (for a current list of supported 3d models' formats,
  see view3dscene documentation)

  It loads a model from a filename given as command-line parameter.

  It allows user to walk in the scene using keys Up/Down (forward/back),
  Right/Left (rotate), PageUp/PageDown (raise/bow your head) etc.
  -- for a complete list of keys available see documentation
  of @link(TWalkNavigator) class or view3dscene documentation
  (look for "keys available in Walk navigation method").

  Thanks to using GLW_Navigated unit (that exposes Glw of class
  TGLWindowNavgated that descends from TGLWindowDemo),
  this program automatically handles keys Escape (Quit)
  and Ctrl+F (Swap fullscreen) and displays FPS on window's Caption.

  Note that this example exposes some shortcomings that are not fixed here
  for the sake of simplicity of this example.
  They are all fixed in a more sophisticated version of this example
  in file simple_view_model_2.pasprogram.
  - In this program starting camera position is *not* read from file.
    Camera always starts positioned at the middle of 3d model,
    looking in (1, 0, 0) direction with up vector (0, 1, 0).
  - Collision detection is *not* done.
  - Also, scene is rendered using roSceneAsAWhole optimization.
    No frustum culling, or anything like that.
  - If you will load large VRML scene, then right after program start
    you may notice for a very short time that your camera moves too fast.
  - Scene lights (written in VRML file) are not used.
}

program simple_view_model;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  KambiFilesUtils, VRMLErrors;

var
  Scene: TVRMLGLScene;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);
  Scene.Render(nil, tgAll);
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(45.0, glwin.Width/glwin.Height,
    Box3dMaxSize(Scene.BoundingBox) * 0.05,
    Box3dMaxSize(Scene.BoundingBox) * 3.0);
end;

begin
  Parameters.CheckHigh(1);
  try
    VRMLWarning := @VRMLWarning_Write;

    Scene := TVRMLGLScene.Create(Parameters[1], roSceneAsAWhole);

    Writeln(Scene.Info(true, true, false));

    { Uncomment this to get some info about scene nodes:
    for i := 0 to Scene.Shapes.Count-1 do
      with Scene.Shapes[i] do
      begin
       Writeln(Format('Shape name ''%10s'' (''%20s'') : LocalBBox = %50s, BBox = %50s',
         [Geometry.NodeName, Geometry.NodeTypeName,
          Box3dToNiceStr(LocalBoundingBox), Box3dToNiceStr(BoundingBox)]));
      end;}

    { init Glw.Navigator }
    Glw.Navigator := TWalkNavigator.Create(Glw);
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;
    Glw.WalkNav.Init(Box3dMiddle(scene.BoundingBox),
        VectorAdjustToLength(Vector3Single(1, 0, 0),
          Box3dAvgSize(Scene.BoundingBox) * 0.01*0.4),
        Vector3Single(0, 1, 0),
        Vector3Single(0, 1, 0), 0.0, 0.0);

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
