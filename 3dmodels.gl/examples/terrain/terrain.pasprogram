{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Display, walk over the terrain.

  Terrain data may be obtained from various sources:

  1. There's terrain data reader from a very simple SRTM-3 *.hgt file
     (pass $1 a filename of .hgt file).

     See http://www2.jpl.nasa.gov/srtm/, see (linked there)
     http://dds.cr.usgs.gov/srtm/ for sample data for whole Earth.
     In you speak Polish, nice overview is also on
     http://netgis.geo.uw.edu.pl/srtm/.
     Sample files for Poland are on http://netgis.geo.uw.edu.pl/srtm/Poland/,
     for Europe http://netgis.geo.uw.edu.pl/srtm/Europe/.

     You can run the program with command-line parameter to pass filename
     of such .hgt file to load on start.

  2. You can also define terrain as an explicit function using KambiScript
     expression syntax, [http://vrmlengine.sourceforge.net/kambi_script.php].
     Try e.g. function like
     - sin(x*10) + sin(y*10)
     - (sin(x*10) + sin(x*20) / 2 + sin(x*40) / 4)  *
       (sin(y*10) + sin(y*20) / 2 + sin(y*40) / 4)
       (sum sinusoides of various frequencies and amplitudes).

  3. You can also (and this was actually the primary reason for this program
     in the 1st place) generate random terrain.

  TODO: UI to
  - gen random terrain.
    Control params:
    - starting amplitude, freqeuency (these simply scale the terrain),
    - persistence (this is the interesting factor),
    - starting NoiseIndex (this allows us to "seed" the terrain, instead
      of getting just one and the same always).
    - interpolation method.
      TODO: impl some, of course.

  - switch view terrain:
    1. current view - "Examine the [0..1, 0..1] range of the terrain"
    2. new new - "Walk over the infinite terrain":
       Walk mode,
       optionally keeping avatar over the ground,
       optionally with fog (since terrain is infinite in this case),
       and using the algorithm that renders infinite terrain with LOD.
       Optionally with sky displayed, just for effect.

  TODO: current sliders usage of mouse and keys interacts strangely
  with our normal navigator: Some keys are handled by both (up, down etc.).
  Mouse presses and dragging are handled by both too.
  - it would be needed to introduce the concept of focus,
    to allow selecting and deselecting menu.
    Or maybe just drop the idea of selected menu item for this?
    Poor, but avoids problems with focus (it would not be intuitive
    --- how to tell user when/how to make focus on the main navigator?).
  - it would be needed to allow injecting menu somehow that it intercepts
    all interesting events. Also, such that it intercepts mouse down / etc.
    events (but how well will it work for mouse dragging? some fake
    mouse down/ups will be needed?)

  TODO: sliders:
  - also controls for initial NoiseIndex (to choose different seed).
  - controls for shifting noise (and calculated kam script) terrain.
  - Allow octaves to be float? --- like blender does, just last eventual octave
    in frac(octaves).

  TODO: add calculating and using normals.
}
program terrain;

uses SysUtils, Classes, Boxes3d,
  KambiUtils, GLWindow, GLW_Navigated, GL, KambiGLUtils,
  Navigation, VectorMath, KambiFilesUtils, Elevations, GLWinMessages,
  KambiStringUtils, GLMenu;

var
  Elevation: TElevation;
  Wireframe: boolean;

const
  ScaleSize = 100.0;
  ScaleHeight = 0.01;

type
  TTerrainControls = class(TGLMenu)
  public
    constructor Create;

    OctavesSlider: TGLMenuIntegerSlider;
    AmplitudeSlider: TGLMenuFloatSlider;
    FrequencySlider: TGLMenuFloatSlider;

    procedure CurrentItemAccessoryValueChanged; override;
  end;

var
  GLControls: TGLMenu;

procedure ElevationVertex(const X, Y, H: Single);
begin
  { Colors strategy from http://www.ii.uni.wroc.pl/~anl/dyd/PGK/pracownia.html }
  if      (H < 0  )  then glColor3f(0,       0,         1) { blue }
  else if (H < 500)  then glColor3f(0,       H/500,     0) { green }
  else if (H < 1000) then glColor3f(H/500-1, 1,         0) { yellow }
  else if (H < 1500) then glColor3f(1,       H/500-2.0, 0) { red }
  else glColor3f(1, 1, 1);                                 { white }

  glVertex3f(
    ScaleSize * X,
    ScaleSize * Y,
    ScaleHeight * H);
end;

{ Generic drawing of any TElevation, uses Height method }
procedure DrawElevation(Elevation: TElevation);

  procedure Vertex(const I, J: Single);
  begin
    { TODO: * 1000 + 500 needed to hit interesting colors (otherwise
      it's all black around 0. Make it nicer: detect min/max height,
      adjust color range (and ScaleHeight, to see it) to it. }
    ElevationVertex(I, J, Elevation.Height(I, J) * 1000 + 500);
  end;

const
  CountSteps = 100;
var
  I, J: Cardinal;
begin
  for I := 1 to CountSteps - 1 do
  begin
    glBegin(GL_QUAD_STRIP);
      for J := 0 to CountSteps - 1 do
      begin
        Vertex((I - 1) / CountSteps, J / CountSteps);
        Vertex( I      / CountSteps, J / CountSteps);
      end;
    glEnd();
  end;
end;

{ Specialized drawing for TElevationGrid, that displays only the
  precise grid points. }
procedure DrawGrid(Grid: TElevationGrid);

  procedure Vertex(I, J: Cardinal);
  begin
    ElevationVertex(
      I / Grid.GridSizeX,
      J / Grid.GridSizeY,
      Grid.GridHeight(I, J));
  end;

const
  Step = 10;
var
  I, J: Cardinal;
begin
  I := Step;
  while I < Grid.GridSizeX do
  begin
    glBegin(GL_QUAD_STRIP);
      J := 0;
      while J < Grid.GridSizeY do
      begin
        Vertex(I - Step, J);
        Vertex(I       , J);
        Inc(J, Step);
      end;
    glEnd();
    Inc(I, Step);
  end;
end;

procedure Draw2d(Draw2DData: Pointer);
begin
  if Elevation is TElevationNoise then
  begin
    glLoadIdentity;
    glRasterPos2i(0, 0);
    GLControls.Draw;
  end;
end;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  if Wireframe then
  begin
    glPushAttrib(GL_POLYGON_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  end else
  begin
    glPushAttrib(GL_ENABLE_BIT);
    glEnable(GL_DEPTH_TEST);
  end;

    if Elevation is TElevationGrid then
      DrawGrid(TElevationGrid(Elevation)) else
      DrawElevation(Elevation);

  glPopAttrib;

  glPushAttrib(GL_ENABLE_BIT);
    glDisable(GL_LIGHTING);
    glProjectionPushPopOrtho2D(@Draw2d, nil, 0, Glwin.Width, 0, Glwin.Height);
  glPopAttrib;
end;

procedure Resize(Glwin: TGLWindow);
begin
  glViewport(0, 0, Glwin.Width, Glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height, ScaleSize / 100, ScaleSize * 3);
  GLControls.FixItemsAreas(Glwin.Width, Glwin.Height);
end;

constructor TTerrainControls.Create;
begin
  inherited;

  OctavesSlider := TGLMenuIntegerSlider.Create(0, 20, 4);
  AmplitudeSlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  FrequencySlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);

  Items.AddObject('Octaves', OctavesSlider);
  Items.AddObject('Amplitude (scales height)', AmplitudeSlider);
  Items.AddObject('Frequency (scales size)', FrequencySlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);
end;

procedure TTerrainControls.CurrentItemAccessoryValueChanged;
begin
  if not (Elevation is TElevationNoise) then Exit;
  case CurrentItem of
    0: (Elevation as TElevationNoise).Octaves := OctavesSlider.Value;
    1: (Elevation as TElevationNoise).Amplitude := AmplitudeSlider.Value;
    2: (Elevation as TElevationNoise).Frequency := FrequencySlider.Value;
  end;
end;

procedure Init(Glwin: TGLWindow);
begin
  GLControls := TTerrainControls.Create;
  { First GLControls.FixItemsAreas will be called from Resize. }
end;

procedure Close(Glwin: TGLWindow);
begin
  FreeAndNil(GLControls);
  GLMenuCloseGL;
end;

procedure KeyDown(glwin: TGLWindow; key: TKey; c: char);
begin
  GLControls.KeyDown(Key, C);
end;

procedure MouseMove(Glwin: TGLWindow; NewX, NewY: Integer);
begin
  GLControls.MouseMove(NewX, Glwin.Height - NewY,  Glwin.MousePressed);
end;

procedure MouseDown(Glwin: TGLWindow; Button: TMouseButton);
begin
  GLControls.MouseDown(Glwin.MouseX, Glwin.Height - Glwin.MouseY, Button,
    Glwin.MousePressed);
end;

procedure MouseUp(Glwin: TGLWindow; Button: TMouseButton);
begin
  GLControls.MouseUp(Glwin.MouseX, Glwin.Height - Glwin.MouseY, Button,
    Glwin.MousePressed);
end;

procedure Idle(Glwin: TGLWindow);
begin
  GLControls.Idle(Glwin.Fps.IdleSpeed);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
var
  FileName: string;
  Expression: string;
  NewElevation: TElevation;
begin
  case Item.IntData of
    10: Wireframe := not Wireframe;
    50: begin
          FileName := '';
          if Glwin.FileDialog('Open SRTM (.hgt) terrain file', FileName, true,
            'All Files|*|' +
            '*SRTM (*.hgt) terrain|*.hgt') then
          begin
            try
              NewElevation := TElevationSRTM.CreateFromFile(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading file "%s" as terrain: %s',
                  [FileName, E.Message]));
                Exit;
              end;
            end;

            FreeAndNil(Elevation);
            Elevation := NewElevation;
          end;
        end;
    60: begin
          Expression := '';
          if MessageInputQuery(Glwin, 'Pass KambiScript function expression, using X and Y variables, and calculating height of the terrain at given point.' + nl + nl +
            '(For example, try "sin(x*10) + sin(x*20)").', Expression, taLeft) then
          begin
            try
              NewElevation := TElevationKamScript.Create(Expression);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when interpreting expression: %s',
                  [E.Message]));
                Exit;
              end;
            end;

            FreeAndNil(Elevation);
            Elevation := NewElevation;
          end;
        end;
    100: Glwin.Close;
  end;
  Glwin.PostRedisplay;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load terrain from SRTM (.hgt) file ...', 50, CtrlO));
    M.Append(TMenuItem.Create('Define terrain by KambiScript expression ...', 60));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Wireframe', 10, 'w', Wireframe, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 100));
    Result.Append(M);
end;

begin
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHighAtMost(1);

  if Parameters.High = 1 then
    Elevation := TElevationSRTM.CreateFromFile(Parameters[1]) else
    { some default elevation }
    Elevation := TElevationNoise.Create;
//    TElevationKamScript.Create('sin(x*10) * sin(y*10)');

  try
    Glw.Navigator := TExamineNavigator.Create(@Glw.PostRedisplayOnMatrixChanged);
    Glw.ExamineNav.Init(Box3d(
      Vector3Single(        0,         0, -ScaleHeight),
      Vector3Single(ScaleSize, ScaleSize,  ScaleHeight)));

    (*
    Glw.WalkNav.Init(Vector3Single(
      ScaleSize * 0.5,
      ScaleSize * 0.5,
      ScaleHeight * Elevation.Height(0.5, 0.5)) { pos },
      Vector3Single(0, 1, 0) { dir },
      Vector3Single(0, 0, 1) { up },
      Vector3Single(0, 0, 1), 0.0, 0.0 { unused, we don't use Gravity here });
    *)

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnKeyDown := @KeyDown;
    Glw.OnMouseMove := @MouseMove;
    Glw.OnMouseDown := @MouseDown;
    Glw.OnMouseUp := @MouseUp;
    Glw.OnIdle := @Idle;
    Glw.InitLoop(ProgramName, @Draw);
  finally FreeAndNil(Elevation) end;
end.
