{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Simple walk over the terrain.
  For now: reads terrain data from a very simple SRTM-3 *.hgt file
  (pass $1 a filename of .hgt file).

  See http://www2.jpl.nasa.gov/srtm/, see (linked there)
  http://dds.cr.usgs.gov/srtm/ for sample data for whole Earth.
  In you speak Polish, nice overview is also on
  http://netgis.geo.uw.edu.pl/srtm/.
  Sample files for Poland are on http://netgis.geo.uw.edu.pl/srtm/Poland/,
  for Europe http://netgis.geo.uw.edu.pl/srtm/Europe/.
}
program terrain;

uses SysUtils, Classes, KambiUtils, GLWindow, GLW_Navigated, GL, KambiGLUtils,
  Navigation, VectorMath, KambiFilesUtils, Elevations;

var
  Elevation: TElevationGrid;

const
  ScaleSize = 100.0;
  ScaleHeight = 0.01;

procedure Draw(Glwin: TGLWindow);

  procedure Vertex(I, J: Cardinal);
  var
    H: Single;
  begin
    H := Elevation.GridHeight(I, J);

    { Colors strategy from http://www.ii.uni.wroc.pl/~anl/dyd/PGK/pracownia.html }
    if      (H < 0  )  then glColor3f(0,       0,         1) //blue
    else if (H < 500)  then glColor3f(0,       H/500,     0) //->green
    else if (H < 1000) then glColor3f(H/500-1, 1,         0) //->yellow
    else if (H < 1500) then glColor3f(1,       H/500-2.0, 0) //->red
    else glColor3f(1, 1, 1);                                 //white

    glVertex3f(
      ScaleSize * I / Elevation.GridSizeX,
      ScaleSize * J / Elevation.GridSizeY,
      ScaleHeight * H);
  end;

const
  CoordStep = 10;
var
  I, J: Cardinal;
begin
//  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  glEnable(GL_DEPTH_TEST);
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  I := CoordStep;
  while I < Elevation.GridSizeX do
  begin
    glBegin(GL_QUAD_STRIP);
      J := 0;
      while J < Elevation.GridSizeY do
      begin
        Vertex(I - CoordStep, J);
        Vertex(I            , J);
        Inc(J, CoordStep);
      end;
    glEnd();
    Inc(I, CoordStep);
  end;
end;

procedure Resize(Glwin: TGLWindow);
begin
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height, 0.1, 100);
end;

begin
  Parameters.CheckHigh(1);

  Elevation := TElevationSRTM.CreateFromFile(Parameters[1]);
  try
    Glw.Navigator := TWalkNavigator.Create(@Glw.PostRedisplayOnMatrixChanged);
    Glw.WalkNav.Init(Vector3Single(
      ScaleSize * 0.5,
      ScaleSize * 0.5,
      ScaleHeight * Elevation.GridHeight(
        Elevation.GridSizeX div 2,
	Elevation.GridSizeY div 2)) { pos },
      Vector3Single(0, 1, 0) { dir },
      Vector3Single(0, 0, 1) { up },
      Vector3Single(0, 0, 1), 0.0, 0.0 { unused, we don't use Gravity here });

    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally FreeAndNil(Elevation) end;
end.
