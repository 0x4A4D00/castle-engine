{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Display, walk over the terrain.

  Terrain data may be obtained from various sources:

  1. There's terrain data reader from a very simple SRTM-3 *.hgt file
     (pass $1 a filename of .hgt file).

     See http://www2.jpl.nasa.gov/srtm/, see (linked there)
     http://dds.cr.usgs.gov/srtm/ for sample data for whole Earth.
     In you speak Polish, nice overview is also on
     http://netgis.geo.uw.edu.pl/srtm/.
     Sample files for Poland are on http://netgis.geo.uw.edu.pl/srtm/Poland/,
     for Europe http://netgis.geo.uw.edu.pl/srtm/Europe/.

     You can run the program with command-line parameter to pass filename
     of such .hgt file to load on start.

  2. You can also define terrain as an explicit function using KambiScript
     expression syntax, [http://vrmlengine.sourceforge.net/kambi_script.php].
     Try e.g. function like
     - sin(x*10) + sin(y*10)
     - (sin(x*10) + sin(x*20) / 2 + sin(x*40) / 4)  *
       (sin(y*10) + sin(y*20) / 2 + sin(y*40) / 4)
       (sum sinusoides of various frequencies and amplitudes).

  3. You can also (and this was actually the primary reason for this program
     in the 1st place) generate random terrain.

  TODO: UI to
    - starting NoiseIndex (this allows us to "seed" the terrain, instead
      of getting just one and the same always).
    - interpolation method.
      TODO: impl some, of course.

  - switch view terrain:
    1. current view - "Examine the [0..1, 0..1] range of the terrain"
    2. new new - "Walk over the infinite terrain":
       Walk mode,
       optionally keeping avatar over the ground,
       optionally with fog (since terrain is infinite in this case),
       and using the algorithm that renders infinite terrain with LOD.
       Optionally with sky displayed, just for effect.
  Multitexture elevation, set texture mixture based on height,
  from GLSL shader.

  TODO: sliders:
  - also controls for initial NoiseIndex (to choose different seed).
  - controls for shifting noise (and calculated kam script) terrain.

  TODO: add calculating and using normals.

  TODO: mark on ui that subdivision doesn't work on grid.
  show subdivision slider also on kamscript terrain (in fact,
  any but not grid), since it works there.
}
program terrain;

uses SysUtils, Classes, Boxes3d,
  KambiUtils, GLWindow, GLW_Navigated, GL, KambiGLUtils,
  Navigation, VectorMath, KambiFilesUtils, Elevations, GLWinMessages,
  KambiStringUtils, GLMenu;

var
  Elevation: TElevation;
  Wireframe: boolean;
  Subdivision: Cardinal = 6;

const
  ScaleSize = 100.0;
  ScaleHeight = 0.01;

type
  TTerrainControls = class(TGLMenu)
  public
    constructor Create(AOwner: TComponent); override;

    OctavesSlider: TGLMenuFloatSlider;
    AmplitudeSlider: TGLMenuFloatSlider;
    FrequencySlider: TGLMenuFloatSlider;
    SmoothnessSlider: TGLMenuFloatSlider;

    SubdivisionSlider: TGLMenuIntegerSlider;

    procedure CurrentItemAccessoryValueChanged; override;
  end;

var
  GLControls: TTerrainControls;

procedure ElevationVertex(const X, Y, H: Single);
begin
  { Colors strategy from http://www.ii.uni.wroc.pl/~anl/dyd/PGK/pracownia.html }
  if      (H < 0  )  then glColor3f(0,       0,         1) { blue }
  else if (H < 500)  then glColor3f(0,       H/500,     0) { green }
  else if (H < 1000) then glColor3f(H/500-1, 1,         0) { yellow }
  else if (H < 1500) then glColor3f(1,       H/500-2.0, 0) { red }
  else glColor3f(1, 1, 1);                                 { white }

  glVertex3f(
    ScaleSize * X,
    ScaleSize * Y,
    ScaleHeight * H);
end;

{ Generic drawing of any TElevation, uses Height method }
procedure DrawElevation(Elevation: TElevation);

  procedure Vertex(const I, J: Single);
  begin
    { TODO: * 1000 + 500 needed to hit interesting colors (otherwise
      it's all black around 0. Make it nicer: detect min/max height,
      adjust color range (and ScaleHeight, to see it) to it. }
    ElevationVertex(I, J, Elevation.Height(I, J) * 1000 + 500);
  end;

var
  I, J, CountSteps: Cardinal;
begin
  CountSteps := 1 shl Subdivision;
  for I := 1 to CountSteps - 1 do
  begin
    glBegin(GL_QUAD_STRIP);
      for J := 0 to CountSteps - 1 do
      begin
        Vertex((I - 1) / CountSteps, J / CountSteps);
        Vertex( I      / CountSteps, J / CountSteps);
      end;
    glEnd();
  end;
end;

{ Specialized drawing for TElevationGrid, that displays only the
  precise grid points. }
procedure DrawGrid(Grid: TElevationGrid);

  procedure Vertex(I, J: Cardinal);
  begin
    ElevationVertex(
      I / Grid.GridSizeX,
      J / Grid.GridSizeY,
      Grid.GridHeight(I, J));
  end;

const
  Step = 10;
var
  I, J: Cardinal;
begin
  I := Step;
  while I < Grid.GridSizeX do
  begin
    glBegin(GL_QUAD_STRIP);
      J := 0;
      while J < Grid.GridSizeY do
      begin
        Vertex(I - Step, J);
        Vertex(I       , J);
        Inc(J, Step);
      end;
    glEnd();
    Inc(I, Step);
  end;
end;

procedure SetElevation(Value: TElevation);
var
  GLControlsVisible: boolean;
begin
  if Elevation <> Value then
  begin
    FreeAndNil(Elevation);
    Elevation := Value;
    GLControlsVisible := Elevation is TElevationNoise;

    if GLControlsVisible then
      Glw.Controls.MakeSingle(TGLMenu, GLControls, true { before navigator }) else
      Glw.Controls.Remove(GLControls);
  end;
end;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(Glw.Navigator.Matrix);

  if Wireframe then
  begin
    glPushAttrib(GL_POLYGON_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  end else
  begin
    glPushAttrib(GL_ENABLE_BIT);
    glEnable(GL_DEPTH_TEST);
  end;

    if Elevation is TElevationGrid then
      DrawGrid(TElevationGrid(Elevation)) else
      DrawElevation(Elevation);

  glPopAttrib;
end;

procedure Resize(Glwin: TGLWindow);
begin
  glViewport(0, 0, Glwin.Width, Glwin.Height);
  ProjectionGLPerspective(30, Glwin.Width / Glwin.Height, ScaleSize / 100, ScaleSize * 3);
  GLControls.FixItemsAreas(Glwin.Width, Glwin.Height);
end;

constructor TTerrainControls.Create(AOwner: TComponent);
begin
  inherited;

  OctavesSlider := TGLMenuFloatSlider.Create(0.0, 20.0, 4.0);
  AmplitudeSlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  FrequencySlider := TGLMenuFloatSlider.Create(0.5, 10.0, 1.0);
  SmoothnessSlider := TGLMenuFloatSlider.Create(1.0, 10.0, 2.0);
  SubdivisionSlider := TGLMenuIntegerSlider.Create(4, 10, Subdivision);

  Items.AddObject('Octaves', OctavesSlider);
  Items.AddObject('Amplitude (scales height)', AmplitudeSlider);
  Items.AddObject('Frequency (scales size)', FrequencySlider);
  Items.AddObject('Smoothness', SmoothnessSlider);
  Items.AddObject('Subdivision (render details)', SubdivisionSlider);
  PositionRelativeScreenX := prLowerBorder;
  PositionRelativeScreenY := prLowerBorder;
  PositionRelativeMenuX := prLowerBorder;
  PositionRelativeMenuY := prLowerBorder;
  Position.Init(10.00, 10.00);

  { First GLControls.FixItemsAreas will be called from Resize. }
end;

procedure TTerrainControls.CurrentItemAccessoryValueChanged;
begin
  if not (Elevation is TElevationNoise) then Exit;
  case CurrentItem of
    0: (Elevation as TElevationNoise).Octaves := OctavesSlider.Value;
    1: (Elevation as TElevationNoise).Amplitude := AmplitudeSlider.Value;
    2: (Elevation as TElevationNoise).Frequency := FrequencySlider.Value;
    3: (Elevation as TElevationNoise).Smoothness := SmoothnessSlider.Value;
    4: Subdivision := SubdivisionSlider.Value;
  end;
  inherited;
end;

procedure Init(Glwin: TGLWindow);
begin
  GLControls := TTerrainControls.Create(nil);
  Glw.Controls.Insert(0, GLControls); { add at the beginning, before navigator }

  if Elevation = nil then
  begin
    if Parameters.High = 1 then
      SetElevation(TElevationSRTM.CreateFromFile(Parameters[1])) else
      { some default elevation }
      SetElevation(TElevationNoise.Create);
  //    SetElevation(TElevationKamScript.Create('sin(x*10) * sin(y*10)'));
  end;
end;

procedure Close(Glwin: TGLWindow);
begin
  Glw.Controls.Remove(GLControls);
  FreeAndNil(GLControls);
  GLMenuCloseGL;
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
var
  FileName: string;
  Expression: string;
  NewElevation: TElevation;
begin
  case Item.IntData of
    10: Wireframe := not Wireframe;
    50: begin
          FileName := '';
          if Glwin.FileDialog('Open SRTM (.hgt) terrain file', FileName, true,
            'All Files|*|' +
            '*SRTM (*.hgt) terrain|*.hgt') then
          begin
            try
              NewElevation := TElevationSRTM.CreateFromFile(FileName);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when loading file "%s" as terrain: %s',
                  [FileName, E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    60: begin
          Expression := '';
          if MessageInputQuery(Glwin, 'Pass KambiScript function expression, using X and Y variables, and calculating height of the terrain at given point.' + nl + nl +
            '(For example, try "sin(x*10) + sin(x*20)").', Expression, taLeft) then
          begin
            try
              NewElevation := TElevationKamScript.Create(Expression);
            except
              on E: Exception do
              begin
                MessageOk(Glwin, Format('Error when interpreting expression: %s',
                  [E.Message]));
                Exit;
              end;
            end;

            SetElevation(NewElevation);
          end;
        end;
    70: begin
          SetElevation(TElevationNoise.Create);
          (Elevation as TElevationNoise).Octaves := GLControls.OctavesSlider.Value;
          (Elevation as TElevationNoise).Amplitude := GLControls.AmplitudeSlider.Value;
          (Elevation as TElevationNoise).Frequency := GLControls.FrequencySlider.Value;
          (Elevation as TElevationNoise).Smoothness := GLControls.SmoothnessSlider.Value;
        end;
    100: Glwin.Close;
  end;
  Glwin.PostRedisplay;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItem.Create('Load terrain from SRTM (.hgt) file ...', 50, CtrlO));
    M.Append(TMenuItem.Create('Define terrain by KambiScript expression ...', 60));
    M.Append(TMenuItem.Create('Generate random terrain', 70));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItemChecked.Create('_Wireframe', 10, 'w', Wireframe, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 100));
    Result.Append(M);
end;

begin
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHighAtMost(1);

  try
    Glw.Navigator := TExamineNavigator.Create(Glw);
    Glw.ExamineNav.Init(Box3d(
      Vector3Single(        0,         0, -ScaleHeight),
      Vector3Single(ScaleSize, ScaleSize,  ScaleHeight)));

    (*
    Glw.WalkNav.Init(Vector3Single(
      ScaleSize * 0.5,
      ScaleSize * 0.5,
      ScaleHeight * ...notset.Height(0.5, 0.5)) { pos },
      Vector3Single(0, 1, 0) { dir },
      Vector3Single(0, 0, 1) { up },
      Vector3Single(0, 0, 1), 0.0, 0.0 { unused, we don't use Gravity here });
    *)

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally FreeAndNil(Elevation) end;
end.
