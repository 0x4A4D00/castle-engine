{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Sample implementation of "Dynamic ambient occlusion".

  See GPU Gems 2 chapter 14, online on
  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter14.html
  (PDF version on
  http://http.download.nvidia.com/developer/GPU_Gems_2/GPU_Gems2_ch14.pdf).
}
program dynamic_ambient_occlusion;

uses VectorMath, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  KambiFilesUtils, KambiStringUtils, VRMLErrors, GLShaders, VRMLShape,
  VRMLFields, Images, Boxes3d, GLImages, GLWinMessages;

var
  Scene: TVRMLGLScene;
  GLSLProgram: TGLSLProgram;
  ShowElements: boolean;

{ Storing and calculating "elements" for algorithm --------------------------- }

type
  TAOElement = record
    Area: Single;
    { Position and Normal are in *world* coordinates (not local!) }
    Position, Normal: TVector3Single;
  end;
  PAOElement = ^TAOElement;

  TDynArrayItem_1 = TAOElement;
  PDynArrayItem_1 = PAOElement;
  {$define DYNARRAY_1_IS_STRUCT}
  {$define read_interface}
  {$define read_implementation}
  {$I dynarray_1.inc}
type
  TDynAOElementArray = TDynArray_1;

var
  Elements: TDynAOElementArray;

type
  TElementsCalculator = class
  public
    CoordIndex: TDynLongIntArray;
    Coord: TDynVector3SingleArray;
    ShapeElements: PAOElement;

    procedure Polygon(const Indexes: array of Cardinal);
  end;

procedure TElementsCalculator.Polygon(
  const Indexes: array of Cardinal);
var
  FaceNormal: TVector3Single;
  { DirectIndexes is LongInt, not Cardinal array, since we cannot
    guarantee that CoordIndex items are >= 0. }
  DirectIndexes: array of LongInt;
  I: Integer;
  FaceArea: Single;
begin
  SetLength(DirectIndexes, Length(Indexes));
  if CoordIndex <> nil then
  begin
    for I := 0 to Length(Indexes) - 1 do
      DirectIndexes[I] := CoordIndex.Items[Indexes[I]];
  end else
  begin
    for I := 0 to Length(Indexes) - 1 do
      DirectIndexes[I] := Indexes[I];
  end;

  FaceNormal := IndexedPolygonNormal(
    PArray_LongInt(DirectIndexes), Length(DirectIndexes),
    { I pass ShapeElements, not Coord.ItemsArray, pointer here,
      to calculate normals in world-coordinates (that are
      in ShapeElements[*].Position). }
    PVector3Single(@(ShapeElements[0].Position)), Coord.Count, SizeOf(TAOElement),
    Vector3Single(0, 0, 0));

  { We assume here that polygon is convex, while in fact it doesn't
    have to be. But this will be a good approximation anyway, usually. }

  FaceArea := IndexedConvexPolygonArea(
    PArray_LongInt(DirectIndexes), Length(DirectIndexes),
    { I pass ShapeElements, not Coord.ItemsArray, pointer here,
      to calculate area in world-coordinates (that are
      in ShapeElements[*].Position). }
    PVector3Single(@(ShapeElements[0].Position)), Coord.Count, SizeOf(TAOElement));

  { Split FaceArea into the number of polygon corners. }
  FaceArea /= Length(Indexes);

  for I := 0 to Length(Indexes) - 1 do
    if DirectIndexes[I] >= 0 then
    begin
      VectorAddTo1st(ShapeElements[DirectIndexes[I]].Normal, FaceNormal);
      { Split FaceArea into the number of polygon corners. }
      ShapeElements[DirectIndexes[I]].Area += FaceArea;
    end;
end;

procedure CalculateElements;

  procedure AddShapeElements(Shape: TVRMLShape);
  var
    Coord: TMFVec3f;
    Calculator: TElementsCalculator;
    ShapeElementIndex: Cardinal;
    ShapeElements: PAOElement;
    I: Integer;
  begin
    if Shape.GeometryNode.Coord(Shape.State, Coord) and (Coord <> nil) then
    begin
      { Grow Elements array }
      ShapeElementIndex := Elements.Count;
      Elements.Count := Elements.Count + Coord.Count;
      ShapeElements := Elements.Pointers[ShapeElementIndex];

      { This does a modified and tweaked version of normal calculation
        from CreateSmoothNormalsCoordinateNode from NormalsCalculator.
        We want to additionally store Position and calculate Area for
        each element (= just vertex). }

      { Initialize: set position,
        clear normals and area at the beginning, we will sum to them. }
      for I := 0 to Coord.Count - 1 do
      begin
        ShapeElements[I].Position :=
          MatrixMultPoint(Shape.State.Transform, Coord.Items.Items[I]);
        ShapeElements[I].Normal := ZeroVector3Single;
        ShapeElements[I].Area := 0;
      end;

      { Iterate over polygons, adding normals and areas of new elements }
      Calculator := TElementsCalculator.Create;
      try
        Calculator.Coord := Coord.Items;
        if Shape.GeometryNode.CoordIndex <> nil then
          Calculator.CoordIndex := Shape.GeometryNode.CoordIndex.Items else
          Calculator.CoordIndex := nil;
        Calculator.ShapeElements := ShapeElements;
        Shape.GeometryNode.CoordPolygons(Shape.State, @Calculator.Polygon);
      finally FreeAndNil(Calculator) end;

      { Normalize all new normals }
      for I := 0 to Coord.Count - 1 do
        NormalizeTo1st(ShapeElements[I].Normal);
    end;
  end;

var
  SI: TVRMLShapeTreeIterator;
  I, GoodElementsCount: Integer;
begin
  Elements.Count := 0;
  SI := TVRMLShapeTreeIterator.Create(Scene.Shapes, true, true, false);
  try
    while SI.GetNext do
      AddShapeElements(SI.Current);
  finally FreeAndNil(SI) end;

  { Remove Elements with zero normal vector.

    This means that vertex isn't neighbor to any other vertex,
    which means e.g. that IndexedFaceSet has no coordIndex (or maybe
    just doesn't use this particular vertex), or maybe we have IndexedLineSet
    (that has coordinates, but no polygons).

    In any case, we want to remove them, as they are invalid (zero normal,
    zero area, besides unused vertexes may be outside of Scene.BoundingBox
    (as calculating Scene.BoundingBox may conserve bbox to not contain
    unused vertexes) --- so unused vertexes would fail to be "squeezed"
    inside texture component correctly. }

  GoodElementsCount := 0;
  for I := 0 to Elements.Count - 1 do
  begin
    if not PerfectlyZeroVector(Elements.Items[I].Normal) then
    begin
      { Then Element I should be on position GoodElementsCount. }
      if GoodElementsCount <> I then
        Elements.Items[GoodElementsCount] := Elements.Items[I];
      Inc(GoodElementsCount);
    end;
  end;

  Writeln('Bad elements (vertexes with no neighbors) removed: ',
    Elements.Count - GoodElementsCount, ', remaining good elements: ',
    GoodElementsCount);
  Elements.Count := GoodElementsCount;

{ Tests:

  Writeln('Elements: ', Elements.Count);
  for I := 0 to Elements.Count - 1 do
  begin
    Writeln('pos ', VectorToNiceStr(Elements.Items[I].Position),
            ' nor ', VectorToNiceStr(Elements.Items[I].Normal),
            ' area ', Elements.Items[I].Area:1:10);
  end;}
end;

var
  ElementsPositionAreaTex: TRGBAlphaImage;
  ElementsNormalTex: TRGBImage;
  { All Elements*Tex are square and have the same size:
    ElementsTexSize x ElementsTexSize. }
  ElementsTexSize: Cardinal;

  GLElementsPositionAreaTex: TGLuint;
  GLElementsNormalTex: TGLuint;

  { We will pack position (with arbitrary 3 float) and areas (with arbitrary
    float >= 0) and normal components (with floats in -1..1 range)
    into the texture components, which are limited to 0..1 range.

    "Scale" and "shift" are used on CPU to squeeze value into texture,
    such that
      tex_value := value / scale - shift;
    Then GPU can do
      value := (tex_value + shift) * scale;
    (as you see, we do the more costly division on CPU, to allow GPU
    to run with maximum speed).

    For normal vector components, scale = 2, shift = -0.5.
    For area, shift = 0, scale = calculated using max area.
    For positions, both scale and shift are calculated, using bounding box
    of points. }
  PositionScale, PositionShift: TVector3Single;
  AreaScale: Single;

procedure CalculateElementsTex;

  { Trivially convert Value in 0..1 range to a byte.
    By the way, checks is the Value really in 0..1 range (eventually,
    slightly off due to fp errors). This way it checks if our scale/shift
    variables are not too large. }
  function ClampedCheck(const Value: Single): Byte;
  var
    ResultInt: Integer;
  begin
    ResultInt := Round(Value * High(Byte));

    { I check ResultInt below with 25 margin, which is 25/255 ~= 0.1 error
      tolerance. That's pretty large tolerance, values really should fit
      within. }
    Assert(ResultInt >= -25, 'Value squeezed into texture is < 0');
    Assert(ResultInt <= High(Byte)+25, 'Value squeezed into texture is > 1');

    if ResultInt < 0 then
      Result := 0 else
    if ResultInt > High(Byte) then
      Result := High(Byte) else
      Result := ResultInt;
  end;

var
  TexSizeExponent: Cardinal;
  I: Integer;
  PositionArea: PVector4Byte;
  Normal: PVector3Byte;
  Element: PAOElement;
begin
  TexSizeExponent := Smallest2Exponent(Elements.Count);
  if TexSizeExponent mod 2 = 0 then
    TexSizeExponent := TexSizeExponent div 2 else
    TexSizeExponent := TexSizeExponent div 2 + 1;
  ElementsTexSize := 1 shl TexSizeExponent;

  Assert(Sqr(ElementsTexSize) >= Elements.Count);
  Writeln('For elements ', Elements.Count,
    ' we use texture size ', ElementsTexSize, '^2 = ', Sqr(ElementsTexSize), ' pixels');

  { calculate maximum area, which is just AreaScale }
  AreaScale := 0;
  for I := 0 to Elements.Count - 1 do
    MaxTo1st(AreaScale, Elements.Items[I].Area);

  { calculate PositionScale, PositionShift.
    We have min/max in Scene.BoundingBox. }
  PositionScale := Box3dSizes(Scene.BoundingBox);
  for I := 0 to 2 do
    PositionShift[I] := Scene.BoundingBox[0][I] / PositionScale[I];

  Writeln('To squeeze area into texture we use area_scale = ', AreaScale:1:10);
  Writeln('To squeeze positions into texture we use scale = ',
    VectorToNiceStr(PositionScale), ' and shift ',
    VectorToNiceStr(PositionShift), ' (bbox is ',
    Box3dToNiceStr(Scene.BoundingBox), ')');

  { initialize textures }
  FreeAndNil(ElementsPositionAreaTex);
  FreeAndNil(ElementsNormalTex);

  ElementsPositionAreaTex := TRGBAlphaImage.Create(ElementsTexSize, ElementsTexSize);
  ElementsNormalTex := TRGBImage.Create(ElementsTexSize, ElementsTexSize);

  { fill textures }
  PositionArea := ElementsPositionAreaTex.AlphaPixels;
  Normal := ElementsNormalTex.RGBPixels;
  Element := PAOElement(Elements.ItemsArray);
  for I := 0 to Elements.Count - 1 do
  begin
    PositionArea^[0] := ClampedCheck(Element^.Position[0] / PositionScale[0] - PositionShift[0]);
    PositionArea^[1] := ClampedCheck(Element^.Position[1] / PositionScale[1] - PositionShift[1]);
    PositionArea^[2] := ClampedCheck(Element^.Position[2] / PositionScale[2] - PositionShift[2]);
    PositionArea^[3] := ClampedCheck(Element^.Area / AreaScale);
    Normal^[0] := ClampedCheck(Element^.Normal[0] / 2 + 0.5);
    Normal^[1] := ClampedCheck(Element^.Normal[1] / 2 + 0.5);
    Normal^[2] := ClampedCheck(Element^.Normal[2] / 2 + 0.5);
    Inc(Element);
    Inc(PositionArea);
    Inc(Normal);
  end;

  GLElementsPositionAreaTex := LoadGLTexture(ElementsPositionAreaTex,
    GL_NEAREST, GL_NEAREST);
  GLElementsNormalTex := LoadGLTexture(ElementsNormalTex,
    GL_NEAREST, GL_NEAREST);
end;

{ GLWindow callbacks --------------------------------------------------------- }

procedure Draw(Glwin: TGLWindow);

  procedure DoShowElements;
  var
    I: Integer;
    Q: PGLUQuadric;
    NewX, NewY, NewZ: TVector3Single;
    Radius: Float;
  begin
    glEnable(GL_DEPTH_TEST);
    glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(1, 1, 0, 1));
    glMaterialv(GL_FRONT_AND_BACK, GL_SPECULAR, Vector4Single(0, 0, 0, 1));

    Q := NewGLUQuadric(GL_FALSE, GLU_FLAT, GLU_OUTSIDE, GLU_FILL);

    for I := 0 to Elements.Count - 1 do
    begin
      glPushMatrix;
        NewZ := Elements.Items[I].Normal;
        NewX := AnyPerpVector(NewZ);
        NewY := VectorProduct(NewZ, NewX);
        glMultMatrix(TransformToCoordsMatrix(Elements.Items[I].Position,
          NewX, NewY, NewZ));

        { Area = Pi * Radius^2, so Radius := Sqrt(Area/Pi) }
        Radius := Sqrt(Elements.Items[I].Area/Pi);
        gluDisk(Q, 0, Radius, 8, 2);

      glPopMatrix;
    end;

    gluDeleteQuadric(Q);
  end;

begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);

  if ShowElements then
    DoShowElements else
  begin
    if GLSLProgram.Support <> gsNone then
    begin
      glActiveTextureARB(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, GLElementsPositionAreaTex);

      glActiveTextureARB(GL_TEXTURE1);
      glBindTexture(GL_TEXTURE_2D, GLElementsNormalTex);

      GLSLProgram.Enable;

      GLSLProgram.SetUniform('tex_elements_position_area', 0);
      GLSLProgram.SetUniform('tex_elements_normal', 1);

      GLSLProgram.SetUniform('tex_elements_size', ElementsTexSize);
      GLSLProgram.SetUniform('area_scale', AreaScale);
      GLSLProgram.SetUniform('position_scale', PositionScale);
      GLSLProgram.SetUniform('position_shift', PositionShift);
      GLSLProgram.SetUniform('elements_count', Elements.Count);

      GLSLProgram.SetUniform('zero_5', 0.5);
      GLSLProgram.SetUniform('pi', Pi);
    end;

    Scene.Render(nil, tgAll);

    if GLSLProgram.Support <> gsNone then
      GLSLProgram.Disable;
  end;
end;

type
  THelper = class
    procedure BeforeShapeRender(Shape: TVRMLShape);
  end;

procedure THelper.BeforeShapeRender(Shape: TVRMLShape);
begin
  GLSLProgram.SetUniform('transform_to_world', Shape.State.Transform);
end;

procedure Init(Glwin: TGLWindow);
const
  GLSLProgramBaseName = 'dynamic_ambient_occlusion';
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);

  if (Elements.Count = 0) or
     IsEmptyBox3d(Scene.BoundingBox) then
  begin
    Glwin.OnDraw := nil;
    MessageOk(Glwin, 'No elements, or empty bounding box --- we cannot do dyn ambient occlusion. Exiting.', taLeft);
    Glwin.Close;
    Exit;
  end;

  { initialize GLSL program }
  GLSLProgram := TGLSLProgram.Create;
  GLSLProgram.AttachVertexShader(FileToString(GLSLProgramBaseName + '.vs'));
//  GLSLProgram.AttachFragmentShader(FileToString(GLSLProgramBaseName + '.fs'));
  { For this test program, we eventually allow shader to run in software.
    We display debug info, so user should know what's going on. }
  GLSLProgram.Link(false);
  Writeln(GLSLProgram.DebugInfo);

  CalculateElementsTex;
end;

procedure Close(Glwin: TGLWindow);
begin
  { Scene may be @nil e.g. if Draw raised an exception, then we will
    free scene before the window will get closed. }
  if Scene <> nil then
    Scene.CloseGL;

  FreeAndNil(GLSLProgram);
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

{ menu ----------------------------------------------------------------------- }

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_Program');
    M.Append(TMenuItemChecked.Create('_Show Elements', 100, ShowElements, true));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit', 200));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    100: ShowElements := not ShowElements;
    200: Glwin.Close;
    else Exit;
  end;

  Glw.PostRedisplay;
end;

begin
  Elements := TDynAOElementArray.Create;

  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], {}{roSceneAsAWhole}roNone);
    Scene.Attributes.OnBeforeShapeRender := @THelper(nil).BeforeShapeRender;
    CalculateElements;

    { init Glw.Navigator }
    Glw.Navigator := Scene.CreateNavigator;
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally
    FreeAndNil(Scene);
    FreeAndNil(Elements);
    FreeAndNil(ElementsPositionAreaTex);
    FreeAndNil(ElementsNormalTex);
  end;
end.
