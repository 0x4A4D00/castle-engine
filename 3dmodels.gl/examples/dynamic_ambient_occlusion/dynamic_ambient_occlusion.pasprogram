{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Sample implementation of "Dynamic ambient occlusion".

  See GPU Gems 2 chapter 14, online on
  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter14.html
  (PDF version on
  http://http.download.nvidia.com/developer/GPU_Gems_2/GPU_Gems2_ch14.pdf).
}
program dynamic_ambient_occlusion;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  KambiFilesUtils, KambiStringUtils, VRMLErrors, GLShaders;

var
  Scene: TVRMLGLScene;
  GLSLProgram: TGLSLProgram;

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);

  if GLSLProgram.Support <> gsNone then
    GLSLProgram.Enable;

  Scene.Render(nil, tgAll);

  if GLSLProgram.Support <> gsNone then
    GLSLProgram.Disable;
end;

procedure Init(Glwin: TGLWindow);
const
  GLSLProgramBaseName = 'dynamic_ambient_occlusion';
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);

  { initialize GLSL program }
  GLSLProgram := TGLSLProgram.Create;
  GLSLProgram.AttachVertexShader(FileToString(GLSLProgramBaseName + '.vs'));
//  GLSLProgram.AttachFragmentShader(FileToString(GLSLProgramBaseName + '.fs'));
  { For this test program, we eventually allow shader to run in software.
    We display debug info, so user should know what's going on. }
  GLSLProgram.Link(false);
  Writeln(GLSLProgram.DebugInfo);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
  FreeAndNil(GLSLProgram);
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

begin
  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roSceneAsAWhole);

    { init Glw.Navigator }
    Glw.Navigator := Scene.CreateNavigator;
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
