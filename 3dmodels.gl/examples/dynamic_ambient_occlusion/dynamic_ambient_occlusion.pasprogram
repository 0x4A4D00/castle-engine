{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Sample implementation of "Dynamic ambient occlusion".

  See GPU Gems 2 chapter 14, online on
  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter14.html
  (PDF version on
  http://http.download.nvidia.com/developer/GPU_Gems_2/GPU_Gems2_ch14.pdf).

  TODO: make model animated, just call CalculateElements on each geometry
  change (or, better: optimized version of it).
}
program dynamic_ambient_occlusion;

uses VectorMath, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLScene, VRMLGLScene, Navigation,
  KambiFilesUtils, KambiStringUtils, VRMLErrors, GLShaders, VRMLShape,
  VRMLFields;

var
  Scene: TVRMLGLScene;
  GLSLProgram: TGLSLProgram;

{ Storing and calculating "elements" for algorithm --------------------------- }

type
  TAOElement = record
    Area: Single;
    { Position and Normal are in *world* coordinates (not local!) }
    Position, Normal: TVector3Single;
  end;
  PAOElement = ^TAOElement;

  TDynArrayItem_1 = TAOElement;
  PDynArrayItem_1 = PAOElement;
  {$define DYNARRAY_1_IS_STRUCT}
  {$define read_interface}
  {$define read_implementation}
  {$I dynarray_1.inc}
type
  TDynAOElementArray = TDynArray_1;

var
  Elements: TDynAOElementArray;

type
  TElementsCalculator = class
  public
    CoordIndex: TDynLongIntArray;
    Coord: TDynVector3SingleArray;
    ShapeElements: PAOElement;

    procedure Polygon(const Indexes: array of Cardinal);
  end;

procedure TElementsCalculator.Polygon(
  const Indexes: array of Cardinal);
var
  FaceNormal: TVector3Single;
  { DirectIndexes is LongInt, not Cardinal array, since we cannot
    guarantee that CoordIndex items are >= 0. }
  DirectIndexes: array of LongInt;
  I: Integer;
begin
  SetLength(DirectIndexes, Length(Indexes));
  if CoordIndex <> nil then
  begin
    for I := 0 to Length(Indexes) - 1 do
      DirectIndexes[I] := CoordIndex.Items[Indexes[I]];
  end else
  begin
    for I := 0 to Length(Indexes) - 1 do
      DirectIndexes[I] := Indexes[I];
  end;

  FaceNormal := IndexedPolygonNormal(
    PArray_LongInt(DirectIndexes), Length(DirectIndexes),
    { I pass ShapeElements, not Coord.ItemsArray, pointer here,
      to calculate normals in world-coordinates (that are
      in ShapeElements[*].Position). }
    PVector3Single(@(ShapeElements[0].Position)), Coord.Count, SizeOf(TAOElement),
    Vector3Single(0, 0, 0));

  for I := 0 to Length(Indexes) - 1 do
    if DirectIndexes[I] >= 0 then
      VectorAddTo1st(ShapeElements[DirectIndexes[I]].Normal, FaceNormal);
end;

procedure CalculateElements;

  procedure AddShapeElements(Shape: TVRMLShape);
  var
    Coord: TMFVec3f;
    Calculator: TElementsCalculator;
    ShapeElementIndex: Cardinal;
    ShapeElements: PAOElement;
    I: Integer;
  begin
    if Shape.GeometryNode.Coord(Shape.State, Coord) and (Coord <> nil) then
    begin
      { Grow Elements array }
      ShapeElementIndex := Elements.Count;
      Elements.Count := Elements.Count + Coord.Count;
      ShapeElements := Elements.Pointers[ShapeElementIndex];

      { This does a modified and tweaked version of normal calculation
        from CreateSmoothNormalsCoordinateNode from NormalsCalculator.
        We want to additionally store Position and calculate Area for
        each element (= just vertex). }

      { Initialize: set position,
        clear normals and area at the beginning, we will sum to them. }
      for I := 0 to Coord.Count - 1 do
      begin
        ShapeElements[I].Position :=
          MatrixMultPoint(Shape.State.Transform, Coord.Items.Items[I]);
        ShapeElements[I].Normal := ZeroVector3Single;
        ShapeElements[I].Area := 0;
      end;

      { Iterate over polygons, adding normals and areas of new elements }
      Calculator := TElementsCalculator.Create;
      try
        Calculator.Coord := Coord.Items;
        if Shape.GeometryNode.CoordIndex <> nil then
          Calculator.CoordIndex := Shape.GeometryNode.CoordIndex.Items else
          Calculator.CoordIndex := nil;
        Calculator.ShapeElements := ShapeElements;
        Shape.GeometryNode.CoordPolygons(Shape.State, @Calculator.Polygon);
      finally FreeAndNil(Calculator) end;

      { Normalize all new normals }
      for I := 0 to Coord.Count - 1 do
        NormalizeTo1st(ShapeElements[I].Normal);
    end;
  end;

var
  SI: TVRMLShapeTreeIterator;
  I: Integer;
begin
  Elements.Count := 0;
  SI := TVRMLShapeTreeIterator.Create(Scene.Shapes, true, true, false);
  try
    while SI.GetNext do
      AddShapeElements(SI.Current);
  finally FreeAndNil(SI) end;

  Writeln('Elements: ', Elements.Count);
  for I := 0 to Elements.Count - 1 do
  begin
    Writeln('pos ', VectorToNiceStr(Elements.Items[I].Position),
            ' nor ', VectorToNiceStr(Elements.Items[I].Normal),
            ' area ', VectorToNiceStr(Elements.Items[I].Area));
  end;
end;

{ GLWindow callbacks --------------------------------------------------------- }

procedure Draw(Glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);

  if GLSLProgram.Support <> gsNone then
    GLSLProgram.Enable;

  Scene.Render(nil, tgAll);

  if GLSLProgram.Support <> gsNone then
    GLSLProgram.Disable;
end;

procedure Init(Glwin: TGLWindow);
const
  GLSLProgramBaseName = 'dynamic_ambient_occlusion';
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);

  { initialize GLSL program }
  GLSLProgram := TGLSLProgram.Create;
  GLSLProgram.AttachVertexShader(FileToString(GLSLProgramBaseName + '.vs'));
//  GLSLProgram.AttachFragmentShader(FileToString(GLSLProgramBaseName + '.fs'));
  { For this test program, we eventually allow shader to run in software.
    We display debug info, so user should know what's going on. }
  GLSLProgram.Link(false);
  Writeln(GLSLProgram.DebugInfo);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
  FreeAndNil(GLSLProgram);
end;

procedure Resize(Glwin: TGLWindow);
var
  AngleOfViewX, AngleOfViewY: Single;
begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  Scene.GLProjection(Glw.Navigator, Scene.BoundingBox,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY);
end;

begin
  Elements := TDynAOElementArray.Create;

  Parameters.CheckHigh(1);
  try
    VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

    Scene := TVRMLGLScene.Create(Parameters[1], roSceneAsAWhole);
    CalculateElements;

    { init Glw.Navigator }
    Glw.Navigator := Scene.CreateNavigator;
    Glw.Navigator.OnMatrixChanged := @Glw.PostRedisplayOnMatrixChanged;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.InitLoop(ProgramName, @Draw);
  finally
    FreeAndNil(Scene);
    FreeAndNil(Elements);
  end;
end.
