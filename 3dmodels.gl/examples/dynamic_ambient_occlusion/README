Dynamic ambient occlusion, based on GPU Gems 2 chapter 14, online on
http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter14.html
(PDF version on
http://http.download.nvidia.com/developer/GPU_Gems_2/GPU_Gems2_ch14.pdf).

Idea:

- Crude assumption: model is actually a number of elements, each element
  corresponding to a vertex of orig model, with normal and area correctly
  calculated.
  See menu "Program -> Show Elements".

- Encode elements info into the texture.

- On each vertex do (in vertex shader): calculate AO using elements info.

Practice:

- First of all, this AO will have to much shadow (multiple shadows
  on the same item). So calculate 2nd time, multiplying.

- Note that you cannot actually do this in vertex shader: with arch 3,
  texture2D calls in vertex shader are not allowed or
  very very horribly-terribly slow. And you want to read texture a lot
  to get all element infos.

  (I tried to do the 1st testing implementation
  of one pass on vertex shader, it simply doesn't work when tested on older
  NVidia and works with 1 frame / couple seconds (even with 1 element count!!!)
  on fglrx.)

- So do this on fragment shader. Also, render such that 1 screen pixel =
  one element, and simply write result back to buffer. To be read back
  to texture, or even possibly grabbed by CPU.

- More shader notes:

  - Remember to expand constant variables for the shader, instead
    of making them uniforms. This is important, not only for speed,
    also for correctness: older GPUs need to unroll "for" loop
    (to elements_count) at compilation.

    (I didn't expand all possible vars, because fglrx doesn't tolerate
    floats with fractional part in GLSL code; so to be safe for fglrx too,
    only ints can be expanded such.)

  - Above unrolling also means that this may just get too difficult
    for older GPUs for larger models: too many instructions after unrolling.
    E.g. my NVidia GPU (kocury) "GeForce FX 5200/AGP/SSE2/3DNOW!" handles
    smaller models (simplico), but fails with
    "error: too many instructions" on larger ones (peach, chinchilla).
    More tests show that the border is somewhere between
    48 (Ok) and 72 (not Ok) verts (for this GPU, of course;
    much newer Radeon on MacBookPro can handle at least 20k (although
    naive implementation gets really slow then).

TODO: our current method of generating elements works only for nodes
with explicit vertexes, so will not work for VRML primitives (sphere,
cone and and such).

TODO: make model animated, just call CalculateElements on each geometry
change (or, better: optimized version of it).
