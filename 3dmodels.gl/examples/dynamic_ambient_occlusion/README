Dynamic ambient occlusion, based on GPU Gems 2 chapter 14, online on
http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter14.html
(PDF version on
http://http.download.nvidia.com/developer/GPU_Gems_2/GPU_Gems2_ch14.pdf).

Idea:

- Crude assumption: model is actually a number of elements, each element
  corresponding to a vertex of orig model, with normal and area correctly
  calculated.
  See menu "Program -> Show Elements".

- Encode elements info into the texture.

- On each vertex do (in vertex shader): calculate AO using elements info.

Practice:

- First of all, this AO will have to much shadow (multiple shadows
  on the same item). So calculate 2nd time, multiplying.

- Note that you cannot actually do this in vertex shader: with arch 3,
  texture2D calls in vertex shader are not allowed or
  very very horribly-terribly slow. And you want to read texture a lot
  to get all element infos.

  (I tried to do the 1st testing implementation
  of one pass on vertex shader, it simply doesn't work when tested on older
  NVidia and works with 1 frame / couple seconds (even with 1 element count!!!)
  on fglrx.)

- So do this on fragment shader. Also, render such that 1 screen pixel =
  one element, and simply write result back to buffer. To be read back
  to texture, or even possibly grabbed by CPU.

TODO: our current method of generating elements works only for nodes
with explicit vertexes, so will not work for VRML primitives (sphere,
cone and and such).

TODO: make model animated, just call CalculateElements on each geometry
change (or, better: optimized version of it).

TODO: change uniform vars into constants inside shader (they don't change
during shader execution, just set them once at frame beginning) ->
some speedup.
