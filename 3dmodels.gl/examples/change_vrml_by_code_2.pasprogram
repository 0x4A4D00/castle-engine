{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Somewhat more involved version of change_vrml_by_code.pasprogram,
  this constructs VRML graph by code and then animates it by code
  (showing a little more interesting animation, sin*cos displayed in 3D). }

{ $define LOG}

program change_vrml_by_code_2;

uses VectorMath, Boxes3d, VRMLNodes, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiUtils, SysUtils, Object3dAsVRML,
  KambiGLUtils, VRMLGLScene, Navigation,
  KambiFilesUtils, VRMLErrors, Quaternions {$ifdef LOG} ,KambiLog {$endif};

var
  Scene: TVRMLGLScene;

procedure Draw(glwin: TGLWindow);
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);
  Scene.Render(nil, tgAll);
end;

procedure Init(glwin: TGLWindow);
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
end;

procedure Close(glwin: TGLWindow);
begin
  Scene.CloseGL;
end;

procedure Resize(glwin: TGLWindow);
begin
  glViewport(0, 0, glwin.Width, glwin.Height);
  ProjectionGLPerspective(45.0, glwin.Width/glwin.Height,
    Box3dMaxSize(Scene.BoundingBox) * 0.05,
    Box3dMaxSize(Scene.BoundingBox) * 3.0);
end;

const
  XCount = 15;
  YCount = 15;

var
  Transform: array [0 .. XCount - 1, 0 .. YCount - 1] of TNodeTransform_2;

procedure Idle(glwin: TGLWindow);
var
  I, J: Integer;
begin
  { We didn't turn Scene.ProcessEvents = true, so actually
    we don't have to "feed" time changes to Scene.IncreaseWorldTime.
    But we want to keep track of current time anyway (for calculating rotations
    below), so it's natural to just use Scene.WorldTime property for this. }
  Scene.IncreaseWorldTime(Glwin.Fps.IdleSpeed);

  for I := 0 to XCount - 1 do
    for J := 0 to YCount - 1 do
    begin
      Transform[I, J].FdTranslation.Value[2] := 2 *
        Sin(I / 2  + Scene.WorldTime.Seconds) *
        Cos(J / 2 + Scene.WorldTime.Seconds);
      //Scene.ChangedField(Transform[I, J].FdTranslation);
    end;

  { For large XCount * YCount, ChangedAll may be faster than ChangedField
    after each change (as ChangedField for Transform tries to do intelligent
    analysis of what was changed by this transform, and this analysis
    is unfortunately slow when changing hundreths of transforms). }
  Scene.ChangedAll;
end;

function CreateVrmlGraph: TNodeGroup_2;
var
  Shape: TNodeShape;
  Mat: TNodeMaterial_2;
  I, J: Integer;
begin
  Result := TNodeGroup_2.Create('', '');

  Mat := TNodeMaterial_2.Create('', '');
  Mat.FdDiffuseColor.Value := Vector3Single(1, 1, 0);

  Shape := TNodeShape.Create('', '');
  Shape.FdAppearance.Value := TNodeAppearance.Create('', '');
  Shape.Appearance.FdMaterial.Value := Mat;
  Shape.FdGeometry.Value := TNodeBox.Create('', '');

  for I := 0 to XCount - 1 do
    for J := 0 to YCount - 1 do
    begin
      Transform[I, J] := TNodeTransform_2.Create('', '');
      Transform[I, J].FdTranslation.Value := Vector3Single(I * 2, J * 2, 0);
      Transform[I, J].FdChildren.AddItem(Shape);

      Result.FdChildren.AddItem(Transform[I, J]);
    end;
end;

begin
  Parameters.CheckHigh(0);
  VRMLWarning := @VRMLWarning_Write;

  { We use a lot of boxes, so make their rendering fastest. }
  Detail_RectDivisions := 0;

  Scene := TVRMLGLScene.Create(CreateVrmlGraph, true, roSeparateShapesNoTransform);
  try
    {$ifdef LOG}
    InitializeLog('1.0');
    Scene.LogChanges := true;
    {$endif}

    { init Glw.Navigator }
    Glw.Navigator := TExamineNavigator.Create(@Glw.PostRedisplayOnMatrixChanged);
    Glw.ExamineNav.Init(Scene.BoundingBox);
    { set more interesting view by default }
    Glw.ExamineNav.Rotations := QuatFromAxisAngle(
      Normalized(Vector3Single(1, 1, 0)), Pi/4);

    Glw.AutoRedisplay := true;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnIdle := @Idle;
    Glw.InitLoop(ProgramName, @Draw);
  finally Scene.Free end;
end.
