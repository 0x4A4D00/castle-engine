{
  Copyright 2007 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Pretty simple plane-projected shadow demo.

  Based on simpleViewModel.dpr. Added (trivial) code to make
  projected shadow, and allows to load model in VRML (or any other supported
  format like 3DS, MD3, Wavefront OBJ etc.) by menu.

  TODO:
  - use stenciling to reduce pixels fighting

  Keys:
    awsd change light position[x, y], qQ change light position[z]

    Navigation: like view3dscene in Examine mode,
    see http://vrmlengine.sourceforge.net/view3dscene.php.

    See menu shortcuts for other keys.

  Command-line params:
    Optional $1 is the initial 3d model filename to load.
    If not given, a simple internal cube model is loaded.

    You can later change it using "Open" menu item anyway.
    Hint: look in kambi_vrml_test_suite,
    [http://vrmlengine.sourceforge.net/kambi_vrml_test_suite.php]
    for some interesting models. See e.g. there for
    vrml_2/teapot.wrl if you want your familiar teapot :)
}
program plane_projected_shadow_demo;

uses VectorMath, Boxes3d, VRMLNodes, VRMLOpenGLRenderer, GL, GLU, GLExt, GLWindow,
  GLW_Navigated, KambiClassUtils, KambiUtils, SysUtils, Classes, Object3dAsVRML,
  KambiGLUtils, VRMLFlatScene, VRMLFlatSceneGL, MatrixNavigation,
  KambiFilesUtils, VRMLErrors, KambiStringUtils, Keys;

var
  Scene: TVRMLFlatSceneGL;
  SceneForShadow: TVRMLFlatSceneGL;

  { FileName of currently loaded Scene.
    '' means to load internal cube model. }
  SceneFileName: string;

  LightPosition: TVector4Single = (0, 0, 10, 1);

  RotationAngle: Single;

procedure Draw(Glwin: TGLWindow);

  function PlaneProjectedShadowMatrix(
    const Plane: TVector4Single;
    const LightPosition: TVector4Single): TMatrix4Single;
  var
    Dot: Single;
  begin
    Dot := VectorDotProduct(LightPosition, Plane);

    { Based on http://www.devmaster.net/articles/shadows/ }

    Result[0][0] := Dot  - LightPosition[0] * Plane[0];
    Result[1][0] :=      - LightPosition[0] * Plane[1];
    Result[2][0] :=      - LightPosition[0] * Plane[2];
    Result[3][0] :=      - LightPosition[0] * Plane[3];

    Result[0][1] :=      - LightPosition[1] * Plane[0];
    Result[1][1] := Dot  - LightPosition[1] * Plane[1];
    Result[2][1] :=      - LightPosition[1] * Plane[2];
    Result[3][1] :=      - LightPosition[1] * Plane[3];

    Result[0][2] :=      - LightPosition[2] * Plane[0];
    Result[1][2] :=      - LightPosition[2] * Plane[1];
    Result[2][2] := Dot  - LightPosition[2] * Plane[2];
    Result[3][2] :=      - LightPosition[2] * Plane[3];

    Result[0][3] :=      - LightPosition[3] * Plane[0];
    Result[1][3] :=      - LightPosition[3] * Plane[1];
    Result[2][3] :=      - LightPosition[3] * Plane[2];
    Result[3][3] := Dot  - LightPosition[3] * Plane[3];
  end;

var
  Box: TBox3d;
  BoxMaxSize: Single;
  Plane: TVector4Single;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadMatrix(glw.Navigator.Matrix);

  glLightv(GL_LIGHT0, GL_POSITION, LightPosition);

  { draw point indicating LightPosition }
  glPushAttrib(GL_ENABLE_BIT);
    glDisable(GL_LIGHTING);

    glColorv(Yellow3Single);
    glBegin(GL_POINTS);
      glVertexv(LightPosition);
    glEnd;
  glPopAttrib;

  Box := Scene.BoundingBox;
  if not IsEmptyBox3d(Box) then
  begin
    { First, render the plane where the shadow lies.
      The plane size and position is calculated to have a nice shadow receiver
      for Scene. }
    glMaterialv(GL_FRONT_AND_BACK, GL_AMBIENT, Vector4Single(0.2, 0.2, 0, 1));
    glMaterialv(GL_FRONT_AND_BACK, GL_DIFFUSE, Vector4Single(0  , 1  , 0, 1));

    BoxMaxSize := Box3dMaxSize(Box);

    DrawGLPlane(Box[0, 0] - BoxMaxSize, Box[0, 1] - BoxMaxSize,
                Box[1, 0] + BoxMaxSize, Box[1, 1] + BoxMaxSize,
                Box[0, 2] - BoxMaxSize, 2,
                0, 0, true);

    glPushMatrix();
      glRotatef(RotationAngle, 1, 1, 1);
      { Render normal Scene }
      Scene.Render(nil, tgAll);
    glPopMatrix();

    { Plane equation is Z = Box[0, 2] - BoxMaxSize, so it's
        0 * x + 0 * y + 1 * z - (Box[0, 2] - BoxMaxSize) = 0
    }
    Plane := Vector4Single(0, 0, 1, - (Box[0, 2] - BoxMaxSize));

    glPushMatrix();
      glMultMatrix(PlaneProjectedShadowMatrix(Plane, LightPosition));
      glPushAttrib(GL_ENABLE_BIT);
        glDisable(GL_LIGHTING);
        glColorv(Vector4Single(0, 0, 0, 0.5));

        glEnable(GL_POLYGON_OFFSET_FILL);
        glPolygonOffset(-10, -10);

        glPushMatrix();
          glRotatef(RotationAngle, 1, 1, 1);
          { Render scene for shadow.
            SceneForShadow is a normal VRML model and it's rendered
            almost exactly like Scene (the same set of glVertex etc.),
            but it's rendered with Attributes.PureGeometry = @true
            (we want it's color to be consistently black). }
          SceneForShadow.Render(nil, tgAll);
        glPopMatrix();
      glPopAttrib();
    glPopMatrix();
  end;
end;

procedure Init(Glwin: TGLWindow);
begin
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  { For VRML Scene rendering, this is always enabled anyway,
    but for the plane (drawn without VRML renderer) this is needed. }
  glEnable(GL_DEPTH_TEST);

  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);

  glClearColor(0.5, 0.5, 0.5, 1);

  glPointSize(10);
end;

procedure Close(Glwin: TGLWindow);
begin
  Scene.CloseGL;
  SceneForShadow.CloseGL;
end;

procedure Resize(Glwin: TGLWindow);
var
  Box: TBox3d;
  BoxMaxSize: Single;
begin
  glViewport(0, 0, Glwin.Width, Glwin.Height);

  Box := Scene.BoundingBox;
  if not IsEmptyBox3d(Box) then
    BoxMaxSize := Box3dMaxSize(Box) else
    { whatever, arbitrary number }
    BoxMaxSize := 2;

  ProjectionGLPerspective(45.0, Glwin.Width / Glwin.Height,
    BoxMaxSize * 0.01, BoxMaxSize * 10.0);
end;

procedure Idle(glwin: TGLWindow);

  procedure ChangeLightPosition(Coord, Change: Integer);
  begin
    LightPosition[Coord] += Change * Glwin.IdleCompSpeed / 10;
  end;

begin
  if Glwin.KeysDown[K_A] then ChangeLightPosition(0, -1);
  if Glwin.KeysDown[K_D] then ChangeLightPosition(0,  1);
  if Glwin.KeysDown[K_S] then ChangeLightPosition(1, -1);
  if Glwin.KeysDown[K_W] then ChangeLightPosition(1,  1);

  if Glwin.KeysDown[K_Q] then
  begin
    if mkShift in Glwin.ModifiersDown then
      ChangeLightPosition(2,  1) else
      ChangeLightPosition(2, -1);
  end;

  RotationAngle += Glwin.IdleCompSpeed / 10;
end;

{ menu ----------------------------------------------------------------------- }

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_File');
    M.Append(TMenuItem.Create('_Open ...',         10, CtrlO));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Exit',             12, CharEscape));
    Result.Append(M);
end;

procedure MenuCommand(Glwin: TGLWindow; MenuItem: TMenuItem);
var
  S: string;
begin
  case MenuItem.IntData of
    10:
      begin
        S := ExtractFilePath(SceneFileName);
        if Glwin.FileDialog('Open 3d model (VRML etc.) file', S, true) then
        begin
          Scene.RootNode.Free;
          Scene.RootNode := nil;
          Scene.RootNode := LoadAsVRML(S, false);
          Scene.ChangedAll;

          SceneForShadow.RootNode := Scene.RootNode;
          SceneForShadow.ChangedAll;

          SceneFileName := S;
          { refresh projection matrix, since Scene.BoundingBox changed }
          Glwin.EventResize;
          { reinit navigator, since Scene.BoundingBox changed }
          Glw.NavExaminer.Init(Scene.BoundingBox);
        end;
      end;
    12: Glwin.Close;
  end;
end;

{ main program --------------------------------------------------------------- }

var
  RootNode: TVRMLNode;
begin
  { parse parameters  }
  Glw.ParseParameters(StandardParseOptions);
  Parameters.CheckHighAtMost(1);
  if Parameters.High = 1 then
    SceneFileName := Parameters[1] else
    SceneFileName := '';

  VRMLNonFatalError := @VRMLNonFatalError_WarningWrite;

  { calculate RootNode }
  if SceneFileName <> '' then
    RootNode := LoadAsVRML(SceneFileName, true) else
    { use box, just to show anything }
    RootNode := ParseVRMLFileFromString('#VRML V1.0 ascii' + LineEnding +  'Cube { }', '');

  Scene := TVRMLFlatSceneGL.Create(RootNode, true, roSceneAsAWhole);
  try
    { init SceneForShadow.
      It doesn't own RootNode, and always has RootNode = Scene.RootNode }
    SceneForShadow := TVRMLFlatSceneGL.Create(RootNode, false, roSceneAsAWhole);
    SceneForShadow.Attributes.PureGeometry := true;

    { init Glw.Navigator }
    Glw.Navigator := TMatrixExaminer.Create(@Glw.PostRedisplayOnMatrixChanged);
    Glw.NavExaminer.Init(Scene.BoundingBox);

    Glw.MainMenu := CreateMainMenu;
    Glw.OnMenuCommand := @MenuCommand;

    Glw.AutoRedisplay := true;

    Glw.OnInit := @Init;
    Glw.OnClose := @Close;
    Glw.OnResize := @Resize;
    Glw.OnIdle := @Idle;
    Glw.InitLoop(ProgramName, @Draw);
  finally
    FreeAndNil(SceneForShadow);
    FreeAndNil(Scene);
  end;
end.
