{
  Copyright 2001-2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Command-line utility for various string and filename operations.
  Very useful in scripts, when simple Unix utils (like dirname or basename)
  are not enought (and when using sed seems just an awful ugly hackery).

  For a list of possible operations, run "stringoper help".

  In case of error, exit code is 1 and error message is on stderr.
  If all Ok, exit code is 0 and result is on stdout. }
program stringoper;

{$apptype CONSOLE}

uses SysUtils, KambiUtils, Classes, KambiStringUtils, KambiFilesUtils;

function FileLinesToParams(const fname: string): string;

  {sorry}
  function Quoted(const s: string): string;
  begin
   Result := '"' + s + '"';
  end;

var slist: TStringList;
    i: integer;
begin
 slist := TStringList.Create;
 try
  slist.LoadFromFile(fname);
  result := '';
  for i := 0 to slist.Count-1 do
  begin
   slist[i] := Trim(slist[i]);
   if slist[i] <> '' then result := result +Quoted(slist[i]) +' ';
  end;
  if result <> '' then SetLength(result, Length(result)-1); { remove one trailing space }
 finally slist.Free end;
end;

{ ExpandFileName, and change all backslashes to slashes.
  Paths with slashes are usable under Windows too, and they are more sanely
  handled in Makefiles etc., so this is sometimes useful. }
function ExpandPosixFileName(const S: string): string;
begin
 Result := SReplaceChars(ExpandFileName(S), '\', '/');
end;

{ help ------------------------------------------------------------------  }

const
  HelpString =
    'stringoper.' +nl+
    'Narzedzie przydatne w pisaniu skryptow powloki, wykonuje sporo' +nl+
    ' operacji na stringach. by Kambi.' +nl+
    'Aktualnie obslugiwane wywolania :' +nl+
    ' help                      StdOut <<ta pomoc' +nl+
    ' ChangeFileExt fname ext   StdOut <<ChangeFileExt(fname, ext)' +nl+
    '     Zmienia ostatnie rozszerzenie na ext. ext powinno zawierac kropke' +nl+
    ' DeleteFileExt fname       StdOut <<fname bez ostatniego rozszerzenia' +nl+
    ' ExtractFileExt fname      StdOut <<ostatnie rozszerzenie fname (z kropka)' +nl+
    ' ExtractOnlyFilename fname StdOut <<tylko nazwa pliku, ' +nl+
    '     bez dysku, katalogu i ostatniego rozszerzenia' +nl+
    ' ExtractFileName fname     StdOut <<sama nazwa pliku + rozszerzenie' +nl+
    '     czyli wycina nazwe dysku+katalogu' +nl+
    ' ExtractFileDrive fname    StdOut <<drive pliku.' +nl+
    ' ExtractFilePath fname     StdOut <<drive+katalog pliku' +nl+
    '     wycina drive i filename+extension. Wynik zawiera (back)slash.' +nl+
    ' ExtractFileDir fname      StdOut <<drive+katalog pliku' +nl+
    '     Jak FilePath ale bez (back)slasha.' +nl+
    '     Wynik (jezeli niepusty) nadaje sie do zrobienia cd $wynik itp.' +nl+
    ' InclPathDelim dirname     StdOut <<dirname z (back)slashem na koncu' +nl+
    ' ExclPathDelim dirname     StdOut <<dirname bez (back)slasha na koncu' +nl+
    '     dirname jesli go tam nie ma' +nl+
    ' FileLinesToParams fname   StdOut <<plik fname jest czytany i kazda'+nl+
    '     jego linia (za wyjatkiem linii pustych lub skladajacych sie z'+nl+
    '     samych bialych znakow) jest wypisywana w apostrofach (cudzyslowach'+nl+
    '     pod Windowsem), zamiast znakow nowej linii linie sa przy tym'+nl+
    '     oddzielane pojedyncza spacja. Przydatne do zapisywania argumentow'+nl+
    '     dowolnego programu w pliku.' +nl+
    ' SubString str start len StdOut <<wycina ze stringa STR LEN znakow, ' +nl+
    '     zaczynajac od pozycji START (pozycje sa liczone od 1). ' +nl+
    '     Jesli str jest za krotki to wynik jest obcinany (nie jest ' +nl+
    '     sygnalizowany blad ani nic).' +nl+
    '     Mozesz nie podac LEN - bedzie to oznaczalo jakby LEN bylo nieskonczone.'+nl+
    ' AppendToFileName FILENAME APPENDED-STR'+nl+
    ' ExpandFileName FILENAME'+nl+
    ' ExpandPosixFileName FILENAME'+nl+
    '     Just like ExpandFileName, but returns path with only "/".' +nl+
    '     Useful for Makefiles, that poorly handle things with "\" inside.' +nl+
    ' FnameAutoInc FNAME-PATTERN'+nl+
    ' UpperCase STR - print STR upper case. Conversion respects current locale.'+nl+
    ' LowerCase STR - print STR lower case. Conversion respects current locale.'+nl+
    ' ReplaceAll STR OLD-PATTERN NEW-PATTERN '+nl+
    '     Replace is STR all occurences of OLD-PATTERN (not-case-sens)' +nl+
    '     with NEW-PATTERN.' +nl+
    ' Trim STR - trim whitespaces at beginning and ending of STR' +nl+
    ' -- (druga grupa polecen - polecenia na ktore odp = true lub false' +nl+
    '     co sygnalizowane jest kodem wyjscia 0 (true) lub 1 (false), ' +nl+
    '     tak jak program ''test'' pod UNIXami)' +nl+
    ' IsPrefix prefix s         czy prefix jest prefixem s ? (not-case-sens)' +nl+
    ' IsSuffix suffix s         czy suffix jest sufiksem s ? (not-case-sens)' +nl+
    nl+
    ' Pod Linuxem, drive jest zawsze = empty string.' +nl+
    ' Kropka jest uwazana za czesc rozszerzenia i zwracana razem z nim.' +nl+
    ' (Back)slash jest uwazany za czesc katalogu i zwracany razem z nim.' +nl+
    ' Gdy filename nie zawiera rozszerzenia / katalogu zwracany jest pusty' +nl+
    '   string zamiast pojedynczej kropki lub (back)slasha.' +nl+
    ' Gdy filename mial kilka rozszerzen wszystkie rozszerzenia poza ostatnim' +nl+
    '   uznawane sa za czesc normalnej nazwy pliku.' +nl+
    ' Nazwy polecen sa case - insensitive.' +nl+
    nl+
    ' Przyklad :   c:      \programy\fpc\  fpc         .exe' +nl+
    '              ||      |------------|  |--|        |--|' +nl+
    '              drive   path            onlyfname   ext' +nl+
    '                            filename= onlyfname + ext';

{ Commands type and consts and funcs --------------------------------------- }

type
  TCommandResult = (crString, crBoolean);
  TCommand = record
    { must be in lowercase (according even to current locale, i.e. to "Ansi"
      string functions) ! }
    Param: string;
    { -1 aby zaznaczyc ze zaden ParCount nie jest required }
    ParCountRequired: Integer;
    CommandResult: TCommandResult;
  end;

const
  CommandsCount = 22;
  Commands: array [0..CommandsCount-1]of TCommand =
  (
    (Param:'changefileext'; ParCountRequired:2; CommandResult: crString),
    (Param:'deletefileext'; ParCountRequired:1; CommandResult: crString),
    (Param:'extractfileext'; ParCountRequired:1; CommandResult: crString),
    (Param:'extractonlyfilename'; ParCountRequired:1; CommandResult: crString),
    (Param:'extractfilename'; ParCountRequired:1; CommandResult: crString),
    (Param:'extractfiledrive'; ParCountRequired:1; CommandResult: crString),
    (Param:'extractfilepath'; ParCountRequired:1; CommandResult: crString),
    (Param:'extractfiledir'; ParCountRequired:1; CommandResult: crString),
    (Param:'inclpathdelim'; ParCountRequired:1; CommandResult: crString),
    (Param:'exclpathdelim'; ParCountRequired:1; CommandResult: crString),
    (Param:'filelinestoparams'; ParCountRequired:1; CommandResult: crString),
    (Param:'isprefix'; ParCountRequired:2; CommandResult: crBoolean),
    (Param:'issuffix'; ParCountRequired:2; CommandResult: crBoolean),
    (Param:'substring'; ParCountRequired:-1; CommandResult: crString),
    (Param:'appendtofilename'; ParCountRequired:2; CommandResult: crString),
    (Param:'expandfilename'; ParCountRequired:1; CommandResult: crString),
    (Param:'fnameautoinc'; ParCountRequired:1; CommandResult: crString),
    (Param:'uppercase'; ParCountRequired:1; CommandResult: crString),
    (Param:'lowercase'; ParCountRequired:1; CommandResult: crString),
    (Param:'expandposixfilename'; ParCountRequired:1; CommandResult: crString),
    (Param:'replaceall'; ParCountRequired:3; CommandResult: crString),
    (Param:'trim'; ParCountRequired:1; CommandResult: crString)
  );

function ParamToCommand(const Param: string): Integer;
{ zwraca liczbe z przedzialu 0..CommandsCount-1 jesli Param zgadza sie
  (case-insensitive) z Commands[result].Param. Jesli nie zgadza sie z zadnym,
  to zwraca -1. }
var ParamLower: string;
begin
 ParamLower := AnsiLowerCase(Param);
 for result := 0 to CommandsCount-1 do
  if Commands[result].Param = ParamLower then Exit;
 result := -1;
end;

{ main -------------------------------------------------------------------- }

var CommandNum: Integer;
    ResultStr: string;
    ResultBool: boolean;
begin
 BonusErrorMessg := 'Uruchom z parametrem help po pomoc.';

 Parameters.CheckHighAtLeast(1);
 if AnsiLowerCase(Parameters[1]) = 'help' then
  begin Writeln(HelpString); Exit end;

 { evaluate CommandNum. Check Commands[CommandNum].ParCountRequired. }
 CommandNum := ParamToCommand(Parameters[1]);
 if CommandNum = -1 then
  raise EInvalidParams.Create('invalid first parameter "'+Parameters[1]+'"');
 Parameters.Delete(1, 1);
 if Commands[CommandNum].ParCountRequired <> -1 then
  Parameters.CheckHigh(Commands[CommandNum].ParCountRequired);

 { evaluate Result*, czyli wykonaj komende.
   Kazda komenda moze czytac parametry Parameters[1]..ParStr(ParCount)
     (i powinna sprawdzic ze nie ma nadmiarowych ani brakujacych parametrow;
     najlatwiej mogla to zrobic dajac ParCountRequired <> -1 ale byc moze
     niektore komendy beda potrzebowaly bardziej zlozonego testu na
     poprawnosc parametrow).
   Komendy powinny ustawic jedna ze zmiennych Result*, odpowiednia dla swojego
     CommandResult - ctString to ResultStr, ctBoolean to ResultBool.
   Komenda w razie problemow moze rzucic dowolne exception.  }
 case CommandNum of
  0 : ResultStr := ChangeFileExt(Parameters[1], Parameters[2]);
  1 : ResultStr := DeleteFileExt(Parameters[1]);
  2 : ResultStr := ExtractFileExt(Parameters[1]);
  3 : ResultStr := ExtractOnlyFileName(Parameters[1]);
  4 : ResultStr := ExtractFileName(Parameters[1]);
  5 : ResultStr := ExtractFileDrive(Parameters[1]);
  6 : ResultStr := ExtractFilePath(Parameters[1]);
  7 : ResultStr := ExtractFileDir(Parameters[1]);
  8 : ResultStr := InclPathDelim(Parameters[1]);
  9 : ResultStr := ExclPathDelim(Parameters[1]);
  10: ResultStr := FileLinesToParams(Parameters[1]);
  11: ResultBool := IsPrefix(Parameters[1], Parameters[2]);
  12: ResultBool := IsSuffix(Parameters[1], Parameters[2]);
  13: case Parameters.High of
       2: ResultStr := SEnding(Parameters[1], StrToInt(Parameters[2]));
       3: ResultStr := Copy(Parameters[1], StrToInt(Parameters[2]), StrToInt(Parameters[3]));
       else raise EInvalidParams.Create('invalid params count for SubString command');
      end;
  14: ResultStr := AppendToFilename(Parameters[1], Parameters[2]);
  15: ResultStr := ExpandFileName(Parameters[1]);
  16: ResultStr := FnameAutoInc(Parameters[1]);
  17: ResultStr := AnsiUpperCase(Parameters[1]);
  18: ResultStr := AnsiLowerCase(Parameters[1]);
  19: ResultStr := ExpandPosixFileName(Parameters[1]);
  20: ResultStr := StringReplace(Parameters[1], Parameters[2], Parameters[3],
        [rfReplaceAll, rfIgnoreCase]);
  21: ResultStr := Trim(Parameters[1]);
  else raise EInternalError.Create('CommandNum not impl');
 end;

 { zwroc Result* w odpowiedni sposob }
 case Commands[CommandNum].CommandResult of
  crString: Write(ResultStr);
  crBoolean: HaltBool(ResultBool);
  else raise EInternalError.Create('CommandResult not impl');
 end;
end.
