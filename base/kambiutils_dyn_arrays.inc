{
  Copyright 2002-2005 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

(*
  TDyn*Array template:
  This file defines TDynArrayBase (base class for all TDynXxxArray)
  and uses templates to create basic TDynXxxArrays for standard Pascal types
  that I use (TDynIntegerArray, TDynStringArray etc.)

  The base idea was that each TDyn<TTT>Array class should give me
  functionality equivalent to dynamic array "array of <TTT>".
  At the beginning I started doing this to workaround the lack of
  dynamic arrays in FPC 1.0.6. But pretty soon the idea of TDyn<TTT>Array
  classes generated by templates gave me much more than just
  something equivalent to dynamic arrays, so I use this still,
  even though I stopped using FPC 1.0.x long time ago.

  The template file is named dynarray.inc, it is multiplicated
  inside templates/ directory as dynarray_1.inc,
  dynarray_2.inc etc. (see templates/Makefile).
  Multiplication is useful to be able to use the same template
  more than once in a single unit.

  To use this template:
  @orderedList(
    @item(
      In the unit's interface, when symbol read_interface is defined:
      @longCode(#
type
  TDynArrayItem_x = <TTT>;
  PDynArrayItem_x = ^TDynArrayItem_x;
  // optionally: {$define DYNARRAY_x_IS_STRUCT}
  // optionally: {$define DYNARRAY_x_IS_INIT_FINI_TYPE}
  {$I dynarray_x.inc}
  TDyn<TTT>Array = TDynArray_x;
#))
    @item(
      In the unit's implementation, when symbol read_implementation is defined:
      @longCode(#
  {$I dynarray_x.inc}
#)))

  And don't change anywhere else the state of defines DYNARRAY_x_*,
  and don't use anywhere else the names TDynArray_x, TDynArrayItem_x etc.
  For safety, use only the names intended to be visible, like <TTT>
  and TDyn<TTT>Array.
*)

{$ifdef read_interface}

type
  { }
  TDynArrayBase = class
  private
    FLength: Integer;
    FCapacity, FAllowedCapacityOverflow: Cardinal;
    ItemSize: Cardinal;

    { This is the buffer used by SwapItems, allocated for ItemSize bytes
      in constructor, freed in desctructor. This way SwapItems doesn't
      have to do any Get/FreeMem and can work fast, not dependent on the
      speed of memory manager. }
    SwapItemsBuf: Pointer;

    procedure SetAllowedCapacityOverflow(Value: Cardinal);
  protected
    { @noAutoLinkHere }
    A: pointer;

    { In this class, SetLength is just equivalent to SetLengthNoInitFini.

      In descendants, you can override SetLength to allow to Initialize
      and Finalize items. But this procedure, @name, is not virtual
      and is not intended to be overriden, so you can use this in cases
      when you're sure that you don't want to do Initialize / Finalize
      your items.

      Note that the only methods that reallocate some memory are
      SetAllowedCapacityCount and this SetLengthNoInitFini.
      These are also the only methods that can change FCapacity,
      FLength (only by SetLengthNoInitFini) and
      FAllowedCapacityOverflow (only by SetAllowedCapacityCount).
      In these methods we care about keeping assertions
        Length <= Capacity
      and
        (Capacity-Length) <= AllowedCapacityOverflow.

      Note that items with indexes Length .. Capacity-1 are never
      read/written and are never supposed to be initialized by Initialize.
      So only on items with indexes 0 .. Length-1 you can call
      Initialize / Finalize, other indexes are just our "safety bag
      of memory" and are not used by SetLength implementation in descendants
      that call Initialize / Finalize. }
    procedure SetLengthNoInitFini(NewLength: Integer);
  public
    { tak naprawde zawsze mamy zaalokowana pamiec nie na Length ale
      na Capacity elementow i oczywiscie pilnujemy zeby zawsze
      Capacity >= Length. AllowedCapacityOverflow to dopuszczalna
      roznica miedzy Capacity a Length, tzn. zawsze
      (Capacity-Length) <= AllowedCapacityOverflow.
      Zawsze przed dokonaniem realokacji pamieci (zmniejszajac lub
      zwiekszajac ilosc dostepnej pamieci) SetLengthNoInitFini
      sprawdza czy przypadkiem nowe Length nie bedzie spelnialo
      warunku NewLength <= Capacity i (Capacity-NewLength) <= AllowedCapacityOverflow.
      Jezeli oba te warunki sa spelnione to nie bedzie robiona realokacja
      pamieci. A jesli nie beda spelnione to niewykluczone ze bedzie
      realokacja pamieci ale zostawimy sobie "na zapas" AllowedCapacityOverflow
      (lub mniej) miejsca na elementy. Skutek ?
        1) raz, to ze potencjalnie marnujemy SizeOf(TDynArrayItem)*
           AllowedCapacityOverflow bajtow pamieci.
        2) dwa to ze w zamian za to oszczedzamy na ilosci wywolan ReallocMem
           ktore moga byc dosc kosztowne, zwlaszcza jesli system bedzie
           musial czesto przenosic nasze dane w inne miejsce pamieci.
      Mozesz wiec operowac AllowedCapacityOverflow aby zdecydowac
      na czym ci bardziej zalezy. Kazda zmiana AllowedCapacityOverflow
      powoduje potencjalna zmiane Capacity, tak aby warunek
      (Capacity-Length) <= AllowedCapacityOverflow byl ZAWSZE zachowany.

      (pozyteczna instrukcja jest wiec AllowedCapacityOverflow := 0;
      mozesz jej uzyc gdy juz wiesz ze tablica nie bedzie wiecej resizowana
      aby nie marnowac ani bajta pamieci.) }
    property AllowedCapacityOverflow: Cardinal read FAllowedCapacityOverflow
      write SetAllowedCapacityOverflow default 4;
    property Capacity: Cardinal read FCapacity;

    procedure SetLength(NewLength: Integer); virtual;
    procedure IncLength;
    procedure DecLength;
    procedure ChangeLength(LenChange: Integer);

    { Count = Length. High = Length-1 (always, even when Length = 0 -> High is -1)

      Note: Length, Count are declared as Integer only to avoid
      range errors on constructs like "Count - 1" (typical in for clauses),
      but actually it's always unsigned. }
    property Length: Integer read FLength write SetLength;
    property Count: Integer read FLength write SetLength;
    function High: Integer;

    procedure SwapItems(Index1, Index2: Cardinal);

    { Fill all memory in array. }
    procedure FillChar(FillValue: byte);

    { Reverse the order of items on the array. }
    procedure Reverse;

    constructor Create(ElementSize, InitialLength: Integer);

    destructor Destroy; override;
  end;

{ Declare all TDynXxxArray for standard Pascal types }

type
  {$define DYNARRAY_1_USE_EQUALITY_OP}
  {$define DYNARRAY_1_USE_PLUSMINUS_OP}
  TDynArrayItem_1  = Cardinal; PDynArrayItem_1  = PCardinal; {$I dynarray_1.inc}  {TDynCardinalArray is below}      TArray_Cardinal = TInfiniteArray_1 ; PArray_Cardinal = PInfiniteArray_1 ;

  {$define DYNARRAY_2_USE_EQUALITY_OP}
  {$define DYNARRAY_2_USE_PLUSMINUS_OP}
  TDynArrayItem_2  = Integer ; PDynArrayItem_2  = PInteger ; {$I dynarray_2.inc}  TDynIntegerArray  = TDynArray_2 ; TArray_Integer  = TInfiniteArray_2 ; PArray_Integer  = PInfiniteArray_2 ;

  {$define DYNARRAY_3_USE_EQUALITY_OP}
  {$define DYNARRAY_3_USE_PLUSMINUS_OP}
  TDynArrayItem_3  = Float   ; PDynArrayItem_3  = PFloat   ; {$I dynarray_3.inc}  {TDynFloatArray is below}         TArray_Float    = TInfiniteArray_3 ; PArray_Float    = PInfiniteArray_3 ;

  {$define DYNARRAY_4_USE_EQUALITY_OP}
  { Don't set USE_PLUSMINUS_OP here, as the sum may often not fit in the Byte }
  TDynArrayItem_4  = Byte    ; PDynArrayItem_4  = PByte    ; {$I dynarray_4.inc}  TDynByteArray     = TDynArray_4 ; TArray_Byte     = TInfiniteArray_4 ; PArray_Byte     = PInfiniteArray_4 ;

  {$define DYNARRAY_5_USE_EQUALITY_OP}
  TDynArrayItem_5  = Shortint; PDynArrayItem_5  = PShortint; {$I dynarray_5.inc}  TDynShortintArray = TDynArray_5 ; TArray_Shortint = TInfiniteArray_5 ; PArray_Shortint = PInfiniteArray_5 ;

  {$define DYNARRAY_6_USE_EQUALITY_OP}
  TDynArrayItem_6  = Smallint; PDynArrayItem_6  = PSmallint; {$I dynarray_6.inc}  TDynSmallintArray = TDynArray_6 ; TArray_Smallint = TInfiniteArray_6 ; PArray_Smallint = PInfiniteArray_6 ;

  {$define DYNARRAY_7_USE_EQUALITY_OP}
  TDynArrayItem_7  = Word    ; PDynArrayItem_7  = PWord    ; {$I dynarray_7.inc}  TDynWordArray     = TDynArray_7 ; TArray_Word     = TInfiniteArray_7 ; PArray_Word     = PInfiniteArray_7 ;

  {$define DYNARRAY_8_USE_EQUALITY_OP}
  {$define DYNARRAY_8_USE_PLUSMINUS_OP}
  TDynArrayItem_8  = Longint ; PDynArrayItem_8  = PLongint ; {$I dynarray_8.inc}  TDynLongintArray  = TDynArray_8 ; TArray_Longint  = TInfiniteArray_8 ; PArray_Longint  = PInfiniteArray_8 ;

  {$define DYNARRAY_9_USE_EQUALITY_OP}
  {$define DYNARRAY_9_USE_PLUSMINUS_OP}
  TDynArrayItem_9  = Int64   ; PDynArrayItem_9  = PInt64   ; {$I dynarray_9.inc}  TDynInt64Array    = TDynArray_9 ; TArray_Int64    = TInfiniteArray_9 ; PArray_Int64    = PInfiniteArray_9 ;

  {$define DYNARRAY_10_USE_EQUALITY_OP}
  {$define DYNARRAY_10_USE_PLUSMINUS_OP}
  TDynArrayItem_10 = Extended; PDynArrayItem_10 = PExtended; {$I dynarray_10.inc} TDynExtendedArray = TDynArray_10; TArray_Extended = TInfiniteArray_10; PArray_Extended = PInfiniteArray_10;

  {$define DYNARRAY_11_USE_EQUALITY_OP}
  {$define DYNARRAY_11_USE_PLUSMINUS_OP}
  TDynArrayItem_11 = Double  ; PDynArrayItem_11 = PDouble  ; {$I dynarray_11.inc} TDynDoubleArray   = TDynArray_11; TArray_Double   = TInfiniteArray_11; PArray_Double   = PInfiniteArray_11;

  {$define DYNARRAY_12_USE_EQUALITY_OP}
  {$define DYNARRAY_12_USE_PLUSMINUS_OP}
  TDynArrayItem_12 = Single  ; PDynArrayItem_12 = PSingle  ; {$I dynarray_12.inc} {TDynSingleArray is below}        TArray_Single   = TInfiniteArray_12; PArray_Single   = PInfiniteArray_12;

  {$define DYNARRAY_13_USE_EQUALITY_OP}
  TDynArrayItem_13 = Pointer ; PDynArrayItem_13 = PPointer ; {$I dynarray_13.inc} TDynPointerArray  = TDynArray_13; TArray_Pointer  = TInfiniteArray_13; PArray_Pointer  = PInfiniteArray_13;

  {$define DYNARRAY_14_USE_EQUALITY_OP}
  {$define DYNARRAY_14_USE_PLUSMINUS_OP}
  TDynArrayItem_14 = LongWord; PDynArrayItem_14 = PLongWord; {$I dynarray_14.inc} TDynLongWordArray = TDynArray_14; TArray_LongWord = TInfiniteArray_14; PArray_LongWord = PInfiniteArray_14;

  {$define DYNARRAY_15_USE_EQUALITY_OP}
  {$define DYNARRAY_15_IS_INIT_FINI_TYPE}
  TDynArrayItem_15 = String  ; PDynArrayItem_15 = PString  ; {$I dynarray_15.inc} TDynStringArray   = TDynArray_15; TArray_String   = TInfiniteArray_15; PArray_String   = PInfiniteArray_15;

  {$define DYNARRAY_16_USE_EQUALITY_OP}
  TDynArrayItem_16 = Boolean ; PDynArrayItem_16 = PBoolean ; {$I dynarray_16.inc} {TDynBooleanArray is below}       TArray_Boolean  = TInfiniteArray_16; PArray_Boolean  = PInfiniteArray_16;

  TDynSingleArray = class;

  TDynFloatArray = class(TDynArray_3)
    procedure AppendFloats(Floats: TDynSingleArray);
  end;

  TDynSingleArray = class(TDynArray_12)
    procedure AppendFloats(Floats: TDynFloatArray);
  end;

  TDynCardinalArray = class(TDynArray_1)
    function BigSum: Int64;
  end;

  TDynBooleanArray = class(TDynArray_16)
    { SetFalse and SetTrue are trivial methods that set appropriate
      Items[Index] to given value. They are useful methods to pass
      as callback in some situations (e.g. TVRMLFlatSceneGL.RenderFrustumOctree
      passes RenderFrustumOctree_Visible.SetTrue method as callback
      that should mark visible items). }
    procedure SetFalse(Index: Integer);
    procedure SetTrue(Index: Integer);
  end;

{$endif}

{$ifdef read_implementation}

{ TDynArrayBase ---------------------------------------- }

constructor TDynArrayBase.Create(ElementSize, InitialLength: Integer);
begin
 inherited Create;
 ItemSize := ElementSize;
 FAllowedCapacityOverflow := 4;
 SwapItemsBuf := GetMem(ItemSize);
 SetLength(InitialLength);
end;

destructor TDynArrayBase.Destroy;
begin
 { SetLength sluzy tylko temu zeby zrobic ew. Finalize na elementach tablicy.
   Dopiero FreeMemNiling gwarantuje ze pamiec zaalokowana dla A zostanie
   rzeczywiscie zwolniona. }
 SetLength(0);
 FreeMemNiling(A);
 FreeMemNiling(SwapItemsBuf);
 inherited;
end;

function TDynArrayBase.High: Integer; begin result := Length-1 end;

procedure TDynArrayBase.SetAllowedCapacityOverflow(Value: Cardinal);
var NewCapacity: Cardinal;
begin
 if Capacity - Cardinal(Length) > Value then
 begin
  NewCapacity := Cardinal(Length) + Value;
  ReallocMem(A, NewCapacity * ItemSize);
  FCapacity := NewCapacity;
 end;
 FAllowedCapacityOverflow := Value;
end;

procedure TDynArrayBase.SetLengthNoInitFini(NewLength: Integer);

  procedure ReallocCapacity(NewCapacity: Cardinal);
  begin
   ReallocMem(A, NewCapacity * ItemSize);
   FCapacity := NewCapacity;
  end;

begin
 if NewLength > Length then
 begin
  if Cardinal(NewLength) > Capacity then
   ReallocCapacity(Cardinal(NewLength) + AllowedCapacityOverflow);
   { else no need to do any memory reallocation }
 end else
 if NewLength < Length then
 begin
  if Capacity - Cardinal(NewLength) > AllowedCapacityOverflow then
   ReallocCapacity(NewLength);
 end;

 FLength := NewLength;
end;

procedure TDynArrayBase.SetLength(NewLength: Integer);
begin
 SetLengthNoInitFini(NewLength);
end;

procedure TDynArrayBase.IncLength;
begin ChangeLength(1) end;

procedure TDynArrayBase.DecLength;
begin ChangeLength(-1) end;

procedure TDynArrayBase.ChangeLength(LenChange: Integer);
begin SetLength(Length+LenChange) end;

procedure TDynArrayBase.SwapItems(Index1, Index2: Cardinal);
var p1, p2: PByte;
begin
 {$I norqcheckbegin.inc}
 PtrUInt(p1) := PtrUInt(A) + Index1 * ItemSize;
 PtrUInt(p2) := PtrUInt(A) + Index2 * ItemSize;
 {$I norqcheckend.inc}
 move(p1^, SwapItemsBuf^, ItemSize);
 move(p2^, p1^, ItemSize);
 move(SwapItemsBuf^, p2^, ItemSize);
end;

procedure TDynArrayBase.FillChar(FillValue: byte);
begin
 System.FillChar(A^, ItemSize * Cardinal(Length), FillValue);
end;

procedure TDynArrayBase.Reverse;
var i: Integer;
begin
 { musimy osobno sprawdzac przypadek Count = 0, bo (0-1) div 2 = -1 div 2 = 0
   a to spowodowaloby blad w ponzszej for, iterowalaby od 0 do 0 a nie przeciez
   elementu numer 0 gdy Count = 0. }
 if Count = 0 then Exit;
 for i := 0 to (Count-1) div 2 do SwapItems(i, Count-1-i);
end;

{ include all implementations ---------------------------------------- }

{$I dynarray_1.inc}
{$I dynarray_2.inc}
{$I dynarray_3.inc}
{$I dynarray_4.inc}
{$I dynarray_5.inc}
{$I dynarray_6.inc}
{$I dynarray_7.inc}
{$I dynarray_8.inc}
{$I dynarray_9.inc}
{$I dynarray_10.inc}
{$I dynarray_11.inc}
{$I dynarray_12.inc}
{$I dynarray_13.inc}
{$I dynarray_14.inc}
{$I dynarray_15.inc}
{$I dynarray_16.inc}

{ TDynFloatArray ------------------------------------------------------------ }

procedure TDynFloatArray.AppendFloats(Floats: TDynSingleArray);
var OldCount, i: Integer;
begin
 OldCount := Count;
 Count := Count + Floats.Count;
 for i := 0 to Floats.High do Items[OldCount+i] := Floats.Items[i];
end;

{ TDynSingleArray ------------------------------------------------------------ }

procedure TDynSingleArray.AppendFloats(Floats: TDynFloatArray);
var OldCount, i: Integer;
begin
 OldCount := Count;
 Count := Count + Floats.Count;
 for i := 0 to Floats.High do Items[OldCount+i] := Floats.Items[i];
end;

{ TDynCardinalArray ------------------------------------------------------------ }

function TDynCardinalArray.BigSum: Int64;
var i: integer;
begin
 result := 0;
 for i := 0 to Length-1 do result := result + Items[i];
end;

{ TDynBooleanArray ------------------------------------------------------------ }

procedure TDynBooleanArray.SetFalse(Index: Integer);
begin
 Items[Index] := false;
end;

procedure TDynBooleanArray.SetTrue(Index: Integer);
begin
 Items[Index] := true;
end;

{$endif}
