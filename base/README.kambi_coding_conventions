This file describes some of Michalis Kamburelis'
(aka Kambi) Pascal coding conventions.
More overall overview of my units is in "Introduction" section
of documentation, see
[http://www.camelot.homedns.org/~michalis/src/pascal/docs/html/index.html].

- *.pas files are units, *.inc are files to be included in other Pascal
  source files using $Include.

  *.dpr files are main program files.
  "Dpr" stands for DelphiProject, but I use this extension even when
  I write FPC-only programs, because 1. I like the idea that main program
  file gets different extension than units 2. It wouldn't be
  really sensible to invent another extension just because this one
  was invented by Delphi.

- Some marks in sources:

  "sorry" (in the comment or not, even inside string) means what usually
  is marked as "TODO". As you can see  (find . -type f | xargs grep sorry)
  there's a lot of "sorry" occurrences in my sources,
  but it's not a reason to worry: most often things
  marked as "sorry" are just some ideas about "what could be implemented
  in this module" or "how could I do something better here". They very
  rarely describe some unresolved problems.

  Second mark is "{}". It's a meaningless sign (empty comment) --
  -- I use it to mark sections of code that I temporarily changed for
  debugging purposes. You should not see such mark anywhere in my sources !
  If you will, then you just spotted a bug, please report this to me.

  Oh, and whenever I was modifying Pascal sources of someone else
  I was marking my modifications by word "Kambi" somewhere in comments.
  "Kambi+" means that I added something,
  "Kambi-" that I commented out something,
  "Kambi*" that I changed something.

- Reentrant routines:

  All routines in my units, just like in any other sane library
  in any programming language, try to be reentrant.
  Functions that can't be reentrant are clearly marked in documentation
  as NON-REENTRANT.

  Generally, reentrant routine is one that is safe to be called recursively
  (e.g. it's implementation may be recursive, or, if reentrant routine
  X receives a pointer to routine Y, then Y may call X without any
  problems; e.g. in TFileProc passed to EnumFiles you can call EnumFiles again)
  and it's safe to use in multi-threaded programs.

  Routine is reentrant when
  - it does not write any static (global or within a unit's implementation)
    variables and
  - it calls only other reentrant routines

- Some naming conventions:

  - If some procedure modifies it's 1st parameter then I usually
    end it's name with "To1st" ("to first", i.e. "returns result back
    to first parameter").

    Often you will be able to see the same function coming in two
    flavours:
      F(const X: <type>, ...):<type>
      FTo1st(var X: <type>,...)
    The 1st (functional-like) version is more flexible,
    but the 2nd version may be faster (especially if type <type> is large,
    or requires time-consuming initialization).

    See e.g. VectorMath and Images units.

    Although I must admit that often I don't keep this convention,
    especially when <type> is some object class.
    Well, you very seldom should write functions that take an object
    reference and modify it somehow. After all, usually you should
    rather make new constructors and destructors for this class
    in such cases.

  - If somewhere I use parameters like V: ^<type> and Stride: Integer
    then it means that these parameters define a table of <type> values.
    Address of 1st item is V, address of i-th is (V + i * Stride).
    This is a convention used by OpenGL's vertex array routines.

    Stride may be negative. Stride may also be 0, then it means
    that Stride = SizeOf(<type>).

  - If beside a variable or class' field/property I write
    comment like "{ = <value> }" then it means that this
    variable is initialized to <value> in unit initialization
    (or in class constructor, in case of class' field/property).

- Compilation symbols used:

  Besides standard FPC, GPC and Delphi ones (like WIN32, UNIX, LINUX,
  CPUI386 to differentiate between compilation platforms,
  FPC and __GPC__ to differentiate between compiler versions).

  I don't use MSWINDOWS symbol, I use WIN32 symbol everywhere.
  When I learn how to deal with 64-bit Windows some day,
  and when I make sure that Delphi >= 7 and FPC >= 2.0.0
  define it when needed, I may change this practice.
  For now I stick to WIN32 symbol.

  See also base/kambiconf.inc for some more handy symbols that I use,
  like DELPHI.

  I also use DEBUG symbol in my sources, with obvious meaning.
  See kambi.cfg for it's exact meaning. There's also RELEASE symbol,
  but I usually don't check for it's existence -- the logic says that
  $ifdef DEBUG then I'm in debug mode, else I'm in release mode.
  So there's no need to check for RELEASE symbol.

- Exceptions' messages:
  - Never start them with 'Error: ' or 'Error - ' or anything else
    that just says "we have an error". Reason: you're raising an Exception,
    this already says that this is some kind of error.
  - Don't end the Message with '!' character. Yes, I know that some
    exceptions mean that something really horrible happened,
    but screaming about this will not help -- let's keep cold blood :)
  - Don't end the Message with '.' character.
  - Usually Message should be a single sentence.
  - Message should not contain any line-breaks. Reason: this doesn't
    look good when displayed in some situations. Especially when
    one Message is embedded as part of the Message of other exception.
    But, if Message really must express line-breaks: they should be
    always expressed as KambiUtils.nl constant.
  - Message must not contain any general program information like
    ProgramName, ExeName etc. (The exception to this rule is when
    such information is really related to the error that happened,
    may help to explain this error etc.)
    In normal situation, the code that finally catched and outputs
    this exception should show such information.

- Callbacks. In the hybrid language like ObjectPascal, there's
  always a problem when I want my procedure to take a pointer to another
  procedure.
  Should I make this "a pointer to a method" or "a pointer to a procedure" ?
  (they are binary different, since "a pointer to a method"
  is actually two pointers (to object instance and to method code))
  Should I add some generic "Data" parameter ?

  Experience seems to show that generally callbacks should be not "of object",
  and should have "Data: Pointer" parameter. Advantages:
  - It's always straightforward to make a wrapper that uses the "Data"
    pointer to pass object's instance, so transforming to "of object"
    kind of callback is always possible.
  - At the same time, when you have some purely procedural code, you can always
    easily use this callback (without the need to declare some dummy class
    just to hold your callback in, or do dirty tricks to treat normal procedure
    as a method)

- Note that for now most parts of my code generally can't handle
  MBCS (multi byte character set) strings. Contributions are welcome,
  if someone needs it.

- If in some Polish comments you will see Polish ogonki -- they should
  be in ISO-8859-2 coding.

Michalis Kamburelis (aka Kambi)
<michalis@camelot.homedns.org>
http://www.camelot.homedns.org/~michalis/