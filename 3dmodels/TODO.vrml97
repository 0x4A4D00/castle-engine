VRML 97 TODO items:

plan for prototype handling:

- We need some prototype names list. Note that this list will value have to be
  push/pop on entering parsing prototype itself, as prototypes defined inside
  prototypes are valid to instantiate only within this proto.

- When found a node with name matching proto (internal OR external!) :

  for external, just create TNodeUnknown for now, but mark with TODO
  where should be fixed,

  for internal: insert VRMLNodeDeepCopy of Prototype.Node (of
  TNodePrototypeInstance class). Search within it (procedure inside
  TNodePrototypeInstance class like FillPrototypeValues) and replace
  "IS" clauses as appropriate (but don't recurse into another
  TNodePrototypeInstance --- "IS" always refers to innermost prototype;
  this is very useful, because it means that prototype can always be
  instantiated right after it's defined. Actually, this is the only sensible
  solution: if "IS" would refer to some non-innermost proto, then the proto
  couldn't be instantiated within it's direct parent --- and proto
  must *always be instantiated within it's direct parent*, not higher,
  so says the spec.

- hmmm, that's all, pretty simple actually... great !
  test everything I can find, test jaguar, mail ANL...

  test that DEF/USE scope is limited to inside proto
  test that nested protos work, and are not visible outside proto
  test that deep "IS" references are correctly replaced
  test that "IS" references are not replaced within nested prototypes,
    within nested prototype IS can reference only innermost interface fields
  test that "IS" clauses are correctly replaced, incluing MFxxx field values,
    SFNode and MFNode values
  test that externprotos are also parsed according to protos now

- save back to file prototypes (all prototypes:
    non-external: just save interface decl and node,
    external: just save interface decl and MFString URLList
    routes: all
    events: those with IsClause
    Scipt interface decl also save)

----------------------------------------
Post view3dscene 2.0 things:

- finish checking NIST tests

- Remaining places where my code temporarily cannot handle VRML 2.0 files,
  should be updated:

  - Ray-tracer: vrmlraytracer.pas: PathTracerTo1st uses only
    VRML 1.0 material node.
    Fixing this means also porting VRML extension on
    http://vrmlengine.sourceforge.net/kambi_vrml_extensions.php
    "Phong's BRDF fields for materials" to VRML 2.0 Material.

  - Conversion from other 3D formats (make 3DS -> VRML 2.0 converter):
    ./object3dasvrml.pas
    (grep for _1 where I used only VRML 1.0 nodes versions)

    Fix WWW pages on http://vrmlengine.sourceforge.net/ then
    (grep for VRML 1.0...),
    they say that convertion only to VRML 1.0 is available.
    And on freshmeat.

    Also fix appropriate section in vrml_engine_doc.

  - "The Castle":
    vrmlscenewaypoints.pas:
      now uses ParentNodes, should also include ParentFields ?
      Same for CastleLevel.
    castledebugmenu: fix to use also VRML 97 version of SpotLight_2
      (it uses beamWidth)
    make test level in VRML 2.0 for castle
    fix castle-development.php page, see TODO item there.
    planned for September 2006.

- KambiTriangulation should also be fixed just like DirectionalLight.
  Or maybe it should be made a new field of Apperance ?

- kambi_vrml_examples: do VRML 2.0 counterpart of all useful VRML 1.0 tests.
  Remaining sensible things to translate are:
  castle.wrl, house_behind_the_glass.wrl, materials.wrl.

  Start of castle is in kambi
  /win/3dmodels/vrml/kambi_vrml_examples.private/castle_vrml97_export
  looks too bad for public --- various small problems.
  For now I'll include VRML 1.0 version.

----------------------------------------
- Implement Prototypes, Event routing. Relevant spec parts:
  - 4.2.4 Prototypes
  - 4.2.5 Event routing
  - see 4.8, Prototype semantics
  - see 4.10.2, Route semantics
- 4.5.4 Scripting language protocols
----------------------------------------
- Check what nodes are allowed where:
  - Root nodes shall be children nodes (see 4.6.5, Grouping and children nodes).
----------------------------------------
- Resolving url fields (MFString, see 4.5.2, 4.5.3).
  Use Synapse or curl (probably both, by compile-time define;
  make the URL system "pluggable", by default "null" system is plugged
  so neither Synapse nor curl is used.).
  Or lnet.
  Yes, this definitely must be "pluggable" to allow various
  network libraries to plug there ..

----------------------------------------
- 4.6.7 Sensor nodes
  ...
  and further 4.x spec parts, with the exception of 4.13, 4.14
