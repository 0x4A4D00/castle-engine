{
  Copyright 2008 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Convert $1 (XML file with 3D scene + portals and sectors
  from Remigiusz Zukowski) into $2 (VRML/X3D file). }

uses SysUtils, KambiUtils, KambiXMLRead, DOM, KambiXMLUtils, VectorMath,
  VRMLNodes, Contnrs, KambiStringUtils;

function DOMGetCardinalChild(Elem: TDOMElement; const ChildName: string): Cardinal;
begin
  Result := StrToInt(DOMGetTextChild(Elem, ChildName));
end;

function DOMGetVector3(VElem: TDOMElement): TVector3Single;
begin
  Result[0] := StrToFloat(DOMGetTextChild(VElem, 'x'));
  Result[1] := StrToFloat(DOMGetTextChild(VElem, 'y'));
  Result[2] := StrToFloat(DOMGetTextChild(VElem, 'z'));
end;

function DOMGetVector3Child(Elem: TDOMElement; const ChildName: string): TVector3Single;
begin
  Result := DOMGetVector3(DOMGetChildElement(Elem, ChildName, true));
end;

function DOMGetVector2Child(Elem: TDOMElement; const ChildName: string): TVector2Single;
var
  VElem: TDOMElement;
begin
  VElem := DOMGetChildElement(Elem, ChildName, true);
  Result[0] := StrToFloat(DOMGetTextChild(VElem, 'x'));
  Result[1] := StrToFloat(DOMGetTextChild(VElem, 'y'));
end;

var
  { List of <px> elements with object_id="...." (put when first serializing
    an element). This is crucial for later resolving of objects with
    object_id_reference="...." (put when serializing the same object
    instance another time). }
  Px: TObjectList;

procedure CalculatePx(E: TDOMElement);
var
  I: TXMLElementIterator;
  NextId: Integer;
begin
  if (E.TagName = 'px') and
     (E.AttribStrings['object_id'] <> '') then
  begin
    { We actively use here the fact that object_id read this way
      will be successive. This makes CalculatePx implementation
      (and using Px) much simpler, since you know that all indexes
      from 0 to Px.Count - 1 are successively filled. }
    NextId := StrToInt(SEnding(E.AttribStrings['object_id'], 2));
    Check(NextId = Px.Count, 'object_id not successive');
    Px.Count := Px.Count + 1;
    Px.Items[Px.Count - 1] := E;
  end;

  I := TXMLElementIterator.Create(E);
  try
    while I.GetNext do CalculatePx(I.Current);
  finally FreeAndNil(I) end;
end;

var
  MeshPx: TDOMElement;
  OutputRoot: TNodeGroup_2;

procedure ReadGeometry;
var
  MVertices, MTriangles: TDOMElement;
  I: TXMLElementIterator;

  Shape: TNodeShape;
  IFS: TNodeIndexedFaceSet_2;
  CoordIndex: TDynLongIntArray;
  Coord: TDynVector3SingleArray;
  Normal:TDynVector3SingleArray;
  TexCoord: TDynVector2SingleArray;

  VerticesCount, TrianglesCount: Cardinal;
begin
  { Prepare XML input }
  MVertices := DOMGetChildElement(DOMGetChildElement(
    MeshPx, 'm_vertexContainer', true), 'm_vertices', true);
  VerticesCount := DOMGetCardinalChild(MVertices, 'count');
  Writeln('Vertices: ', VerticesCount);

  MTriangles := DOMGetChildElement(MeshPx, 'm_triangles', true);
  TrianglesCount := DOMGetCardinalChild(MTriangles, 'count');
  Writeln('Triangles: ', TrianglesCount);

  { Prepare VRML output }
  Shape := TNodeShape.Create('', '');
  Shape.FdAppearance.Value := TNodeAppearance.Create('', '');
  TNodeAppearance(Shape.FdAppearance.Value).FdMaterial.Value :=
    TNodeMaterial_2.Create('', '');
  OutputRoot.SmartAddChild(Shape);

  IFS := TNodeIndexedFaceSet_2.Create('', '');
  Shape.FdGeometry.Value := IFS;
  IFS.FdSolid.Value := false;

  IFS.FdCoord.Value := TNodeCoordinate.Create('', '');
  Coord := TNodeCoordinate(IFS.FdCoord.Value).FdPoint.Items;
  Coord.AllowedCapacityOverflow := VerticesCount;

  IFS.FdNormal.Value := TNodeNormal.Create('', '');
  Normal := TNodeNormal(IFS.FdNormal.Value).FdVector.Items;
  Normal.AllowedCapacityOverflow := VerticesCount;

  IFS.FdNormalPerVertex.Value := true;

  IFS.FdTexCoord.Value := TNodeTextureCoordinate.Create('', '');
  TexCoord := TNodeTextureCoordinate(IFS.FdTexCoord.Value).FdPoint.Items;
  TexCoord.AllowedCapacityOverflow := VerticesCount;

  { Actually read XML data to VRML }
  I := TXMLElementIterator.Create(MVertices);
  try
    while I.GetNext do
      if I.Current.TagName = 'item' then
      begin
        Coord.AppendItem(DOMGetVector3Child(I.Current, 'position'));
        Normal.AppendItem(DOMGetVector3Child(I.Current, 'normal'));
        TexCoord.AppendItem(DOMGetVector2Child(I.Current, 'texCoord'));
      end;
  finally FreeAndNil(I) end;

  CoordIndex := IFS.FdCoordIndex.Items;
  CoordIndex.AllowedCapacityOverflow := TrianglesCount * 4;

  I := TXMLElementIterator.Create(MTriangles);
  try
    while I.GetNext do
      if I.Current.TagName = 'item' then
      begin
        CoordIndex.AppendItem(DOMGetCardinalChild(I.Current, 'm_v0'));
        CoordIndex.AppendItem(DOMGetCardinalChild(I.Current, 'm_v1'));
        CoordIndex.AppendItem(DOMGetCardinalChild(I.Current, 'm_v2'));
        CoordIndex.AppendItem(-1);
      end;
  finally FreeAndNil(I) end;
end;

procedure ReadPortals;
var
  CoordIndex: TDynLongIntArray;
  Coord: TDynVector3SingleArray;

  procedure OutputPortal(PortalPx: TDOMElement);
  var
    MVertices: TDOMElement;
    {VerticesCount: Cardinal; not needed}
    I: TXMLElementIterator;
  begin
    MVertices := DOMGetChildElement(DOMGetChildElement(
      PortalPx, 'm_poly', true), 'm_vertities', true);
    {VerticesCount := DOMGetCardinalChild(MVertices, 'count'); not needed}

    I := TXMLElementIterator.Create(MVertices);
    try
      while I.GetNext do
        if I.Current.TagName = 'item' then
        begin
          Coord.AppendItem(DOMGetVector3(I.Current));
          CoordIndex.AppendItem(Coord.High);
        end;
    finally FreeAndNil(I) end;

    CoordIndex.AppendItem(-1);
  end;

var
  PortalPx: TDOMElement;
  MPortals: TDOMElement;
  PortalsCount: Cardinal;
  I: TXMLElementIterator;
  PortalPxId: Integer;

  Shape: TNodeShape;
  IFS: TNodeIndexedFaceSet_2;
  PortalsAppearance: TNodeAppearance;
  PortalsMaterial: TNodeMaterial_2;
begin
  { Prepare XML input }
  MPortals := DOMGetChildElement(MeshPx, 'm_portals', true);
  PortalsCount := DOMGetCardinalChild(MPortals, 'count');
  Writeln('Portals: ', PortalsCount);

  { Prepare VRML output }
  Shape := TNodeShape.Create('', '');
  OutputRoot.SmartAddChild(Shape);

  PortalsAppearance := TNodeAppearance.Create('PortalsAppearance', '');

  PortalsMaterial := TNodeMaterial_2.Create('PortalsMaterial', '');
  PortalsAppearance.FdMaterial.Value := PortalsMaterial;
  PortalsMaterial.FdDiffuseColor.Value := Vector3Single(1, 1, 0);
  PortalsMaterial.FdTransparency.Value := 0.9;

  Shape.FdAppearance.Value := PortalsAppearance;

  IFS := TNodeIndexedFaceSet_2.Create('Portals', '');
  Shape.FdGeometry.Value := IFS;
  IFS.FdSolid.Value := false;

  IFS.FdCoord.Value := TNodeCoordinate.Create('', '');
  Coord := TNodeCoordinate(IFS.FdCoord.Value).FdPoint.Items;
  Coord.AllowedCapacityOverflow := 1000;

  CoordIndex := IFS.FdCoordIndex.Items;
  CoordIndex.AllowedCapacityOverflow := 1000;

  I := TXMLElementIterator.Create(MPortals);
  try
    while I.GetNext do
      if I.Current.TagName = 'item' then
      begin
        PortalPx := DOMGetChildElement(I.Current, 'px', true);

        { So this is a reference - resolve using object_id_reference
          and our Px table. }
        if PortalPx.AttribStrings['object_id'] = '' then
        begin
          PortalPxId := StrToInt(
            SEnding(PortalPx.AttribStrings['object_id_reference'], 2));
          PortalPx := TDOMElement(Px.Items[PortalPxId]);
        end;

        OutputPortal(PortalPx);
      end;
  finally FreeAndNil(I) end;
end;

var
  Doc: TXMLDocument;
begin
  Parameters.CheckHigh(2);

  ReadXMLFile(Doc, Parameters[1]);
  try
    Check(Doc.DocumentElement.TagName = 'boost_serialization',
      'Root node must be <boost_serialization>');

    Px := TObjectList.Create(false);
    CalculatePx(Doc.DocumentElement);

    MeshPx := DOMGetChildElement(DOMGetChildElement(
      Doc.DocumentElement, 'm_pMesh', true), 'px', true);

    OutputRoot := TNodeGroup_2.Create('', '');
    try
      ReadGeometry;
      ReadPortals;

      SaveToVRMLFile(OutputRoot, Parameters[2],
        'By xmlportals_to_x3d, from ' + ExtractFileName(Parameters[1]));
    finally FreeAndNil(OutputRoot) end;
  finally
    FreeAndNil(Doc);
    FreeAndNil(Px)
  end;
end.
