{%MainUnit castlefonts.pas}
{
  Copyright 2001-2021 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{$ifdef read_interface}

type
  { Font loaded from a font file, like ttf or otf.
    This class is typically used for outline (scalable, vector) fonts in ttf or otf formats.
    But it can really deal with any font supported by
    the @url(https://www.freetype.org/ FreeType library), even bitmap fonts,
    see @url(https://www.freetype.org/freetype2/docs/ft2faq.html#general-what the summary of font formats supported by FreeType).

    This can load a font file, or it can use ready data in TTextureFontData.
    The latter allows to use this for fonts embedded in a Pascal source code,
    since our texture-font-to-pascal can convert a font file to a unit that defines
    ready TTextureFontData instance. }
  TCastleFont = class(TCastleAbstractFont)
  strict private
    FFont: TTextureFontData;
    FOwnsFont: boolean;
    DrawableImage: TDrawableImage;
    GlyphsScreenRects, GlyphsImageRects: TFloatRectangleList;
    function GetSmoothScaling: boolean;
    function GetScale: Single;
    procedure SetScale(const AValue: Single);
  strict protected
    procedure SetSize(const Value: Single); override;
    procedure GLContextClose; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    constructor Create(const URL: string;
      const ASize: Integer; const AnAntiAliased: boolean;
      const ACharacters: TUnicodeCharList = nil); reintroduce; deprecated 'use Create(Owner: TComponent), then Load';
    constructor Create(const URL: string;
      const ASize: Integer; const AnAntiAliased: boolean;
      const ACharacters: TSetOfChars); deprecated 'use Create(Owner: TComponent), then Load';

    { Load by reading a FreeType font file, like ttf.

      Providing charaters list as @nil means that we only create glyphs
      for SimpleAsciiCharacters, which includes only the basic ASCII characters.
      The ACharacters instance @italic(does not) become owned by this object,
      so remember to free it after calling this constructor.

      Loading a font data also changes @link(Size) to the underlying
      (optimal to render) font data size. }
    procedure Load(const URL: string;
      const ASize: Integer; const AnAntiAliased: boolean;
      const ACharacters: TUnicodeCharList = nil);

    { Load from a ready TTextureFontData instance.
      @param(Data TTextureFontData instance containing loaded image
        and glyphs parameters.)
      @param(OwnsData If @true, the Data instance becomes owned
        by this class (will be freed in our constructor).
        Usually you @italic(do not) want this, since usually you pass Data
        from a unit generated by texture-font-to-pascal. In this case,
        the finalization of CastleTextureFont_Xxx unit will already free
        the TTextureFontData instance.) }
    procedure Load(const Data: TTextureFontData;
      const OwnsData: boolean = false);

    procedure PrepareResources; override;
    procedure Print(const X, Y: Single; const Color: TCastleColor;
      const S: string); override;
    function TextWidth(const S: string): Single; override;
    function TextHeight(const S: string): Single; override;
    function TextHeightBase(const S: string): Single; override;
    function TextMove(const S: string): TVector2; override;

    { Underlying font data. }
    property FontData: TTextureFontData read FFont;

    { Scale applied to the rendered font, compared to @link(FontData).Size.
      Changing this is equivalent to changing the Size property. }
    property Scale: Single read GetScale write SetScale;
  end;

  TGLBitmapFont = TCastleFont deprecated 'use TCastleFont';
  TTextureFont = TCastleFont deprecated 'use TCastleFont';

{$endif read_interface}

{$ifdef read_implementation}

{ TCastleFont --------------------------------------------------------------- }

constructor TCastleFont.Create(AOwner: TComponent);
begin
  inherited;
  GlyphsScreenRects := TFloatRectangleList.Create;
  GlyphsImageRects  := TFloatRectangleList.Create;
end;

destructor TCastleFont.Destroy;
begin
  Load(nil); // free previous FFont data
  FreeAndNil(GlyphsScreenRects);
  FreeAndNil(GlyphsImageRects);
  inherited;
end;

constructor TCastleFont.Create(const URL: string;
  const ASize: Integer; const AnAntiAliased: boolean;
  const ACharacters: TUnicodeCharList);
begin
  Create(nil);
  Load(URL, ASize, AnAntiAliased, ACharacters);
end;

procedure TCastleFont.Load(const URL: string;
  const ASize: Integer; const AnAntiAliased: boolean;
  const ACharacters: TUnicodeCharList);
begin
  Load(TTextureFontData.Create(URL, ASize, AnAntiAliased, ACharacters), true);
end;

constructor TCastleFont.Create(const URL: string;
  const ASize: Integer; const AnAntiAliased: boolean;
  const ACharacters: TSetOfChars);
var
  Chars: TUnicodeCharList;
  C: char;
begin
  Chars := TUnicodeCharList.Create;
  try
    for C in ACharacters do
      Chars.Add(Ord(C));
    {$warnings off} // calling deprecated from deprecated
    Create(URL, ASize, AnAntiAliased, Chars);
    {$warnings on}
  finally FreeAndNil(Chars) end;
end;

procedure TCastleFont.Load(const Data: TTextureFontData; const OwnsData: boolean);
begin
  GLContextClose;

  if FOwnsFont then
    FreeAndNil(FFont)
  else
    FFont := nil;

  FOwnsFont := OwnsData;
  FFont := Data;

  if FFont <> nil then
    Size := FFont.Size;
  { Load(nil) is called by our own code.
    Leave Size as it was then, it should not matter. }
end;

function TCastleFont.GetScale: Single;
begin
  Result := Size / FFont.Size;
end;

procedure TCastleFont.SetScale(const AValue: Single);
begin
  Size := FFont.Size * AValue;
end;

procedure TCastleFont.SetSize(const Value: Single);
begin
  inherited SetSize(Value);

  Assert(FFont.Size <> 0);
  Assert(not IsInfinite(Value));

  if DrawableImage <> nil then
    DrawableImage.SmoothScaling := GetSmoothScaling;
end;

function TCastleFont.GetSmoothScaling: boolean;
begin
  Result := Size <> FFont.Size;
end;

procedure TCastleFont.PrepareResources;
begin
  inherited;
  if DrawableImage = nil then
    DrawableImage := TDrawableImage.Create(FFont.Image, GetSmoothScaling, false);
end;

procedure TCastleFont.GLContextClose;
begin
  FreeAndNil(DrawableImage);
  inherited;
end;

procedure TCastleFont.Print(const X, Y: Single; const Color: TCastleColor;
  const S: string);
var
  ScreenX, ScreenY: Single;
  G: TTextureFontData.TGlyph;
  GlyphsToRender: Integer;

  procedure GlyphDraw(const OutlineMoveX, OutlineMoveY: Integer);
  var
    ScreenRect, ImageRect: PFloatRectangle;
  begin
    if TargetImage <> nil then
    begin
      TargetImage.DrawFrom(FFont.Image,
        Round(ScreenX - G.X * Scale + OutlineMoveX * Outline),
        Round(ScreenY - G.Y * Scale + OutlineMoveY * Outline),
        G.ImageX,
        G.ImageY,
        G.Width,
        G.Height);
    end else
    begin
      Assert(GlyphsToRender < GlyphsScreenRects.Count);

      ScreenRect := GlyphsScreenRects.Ptr(GlyphsToRender);
      ScreenRect^.Left   := ScreenX - G.X * Scale + OutlineMoveX * Outline;
      ScreenRect^.Bottom := ScreenY - G.Y * Scale + OutlineMoveY * Outline;
      ScreenRect^.Width  := G.Width  * Scale;
      ScreenRect^.Height := G.Height * Scale;

      ImageRect := GlyphsImageRects.Ptr(GlyphsToRender);
      ImageRect^.Left   := G.ImageX;
      ImageRect^.Bottom := G.ImageY;
      ImageRect^.Width  := G.Width;
      ImageRect^.Height := G.Height;

      Inc(GlyphsToRender);
    end;
  end;

var
  C: TUnicodeChar;
  TextPtr: PChar;
  CharLen, GlyphsPerChar: Integer;
begin
  if TargetImage = nil then
  begin
    PrepareResources;

    { allocate the necessary glyphs at start.
      This allows to quickly fill them later.
      Note that we possibly allocate too much, because Length(S) may be > UTF8Length(S)
      (because of multi-byte characters), and also because some characters do not have glyphs.
      That's OK, we'll calculate real GlyphsToRender when iterating. }
    if Outline = 0 then
      GlyphsPerChar := 1 else
    if OutlineHighQuality then
      GlyphsPerChar := 8 else
      GlyphsPerChar := 4;
    GlyphsScreenRects.Count := Max(MinimumGlyphsAllocated, GlyphsPerChar * Length(S));
    GlyphsImageRects .Count := Max(MinimumGlyphsAllocated, GlyphsPerChar * Length(S));
  end;

  { first pass, to render Outline.

    This could be done better by being done together with non-outline pass,
    by filling the alternative place in Glyph arrays, such that outline and non-outline data
    don't collide.
    It would be 1. faster (don't iterate over S two times), 2. less code duplication. }
  if Outline <> 0 then
  begin
    GlyphsToRender := 0;
    { While Round() below is not needed, it improves the quality of rendered
      text. Compare e.g. view3dscene button captions. }
    ScreenX := Round(X);
    ScreenY := Round(Y);
    if TargetImage <> nil then
      FFont.Image.ColorWhenTreatedAsAlpha := Vector3Byte(OutlineColor.XYZ); // ignore OutlineColor[3] for now

    TextPtr := PChar(S);
    C := UTF8CharacterToUnicode(TextPtr, CharLen);
    while (C > 0) and (CharLen > 0) do
    begin
      Inc(TextPtr, CharLen);

      G := FFont.Glyph(C);
      if G <> nil then
      begin
        if (G.Width <> 0) and (G.Height <> 0) then
        begin
          GlyphDraw(0, 0);
          GlyphDraw(0, 2);
          GlyphDraw(2, 2);
          GlyphDraw(2, 0);

          if OutlineHighQuality then
          begin
            GlyphDraw(1, 0);
            GlyphDraw(1, 2);
            GlyphDraw(0, 1);
            GlyphDraw(2, 1);
          end;
        end;
        ScreenX += G.AdvanceX * Scale + Outline * 2;
        ScreenY += G.AdvanceY * Scale;
      end;

      C := UTF8CharacterToUnicode(TextPtr, CharLen);
    end;

    if TargetImage = nil then
    begin
      DrawableImage.Color := OutlineColor;
      DrawableImage.Draw(
        PFloatRectangleArray(GlyphsScreenRects.List),
        PFloatRectangleArray(GlyphsImageRects.List), GlyphsToRender);
    end;
  end;

  GlyphsToRender := 0;
  { While Round() below is not needed, it improves the quality of rendered
    text. }
  ScreenX := Round(X);
  ScreenY := Round(Y);
  if TargetImage <> nil then
    FFont.Image.ColorWhenTreatedAsAlpha := Vector3Byte(Color.XYZ); // ignore Color[3] for now

  TextPtr := PChar(S);
  C := UTF8CharacterToUnicode(TextPtr, CharLen);
  while (C > 0) and (CharLen > 0) do
  begin
    Inc(TextPtr, CharLen);

    G := FFont.Glyph(C);
    if G <> nil then
    begin
      if (G.Width <> 0) and (G.Height <> 0) then
        if Outline <> 0 then
          GlyphDraw(1, 1) else
          GlyphDraw(0, 0);
      ScreenX += G.AdvanceX * Scale + Outline * 2;
      ScreenY += G.AdvanceY * Scale;
    end;

    C := UTF8CharacterToUnicode(TextPtr, CharLen);
  end;

  if TargetImage = nil then
  begin
    DrawableImage.Color := Color;
    DrawableImage.Draw(
      PFloatRectangleArray(GlyphsScreenRects.List),
      PFloatRectangleArray(GlyphsImageRects.List), GlyphsToRender);
  end;
end;

function TCastleFont.TextWidth(const S: string): Single;
begin
  Result := FFont.TextWidth(S) * Scale;
  if Outline <> 0 then
    Result += Outline * 2 * UTF8Length(S);
end;

function TCastleFont.TextHeight(const S: string): Single;
begin
  Result := FFont.TextHeight(S) * Scale + Outline * 2;
end;

function TCastleFont.TextHeightBase(const S: string): Single;
begin
  Result := FFont.TextHeightBase(S) * Scale + Outline * 2;
end;

function TCastleFont.TextMove(const S: string): TVector2;
var
  M: TVector2Integer;
begin
  M := FFont.TextMove(S);
  Result := Vector2(M.X, M.Y);
  Result.Data[0] := Result.Data[0] * Scale;
  if Outline <> 0 then
    Result.Data[0] += Outline * 2 * UTF8Length(S);
  Result.Data[1] := Result.Data[1] * Scale;
end;

{$endif read_implementation}
