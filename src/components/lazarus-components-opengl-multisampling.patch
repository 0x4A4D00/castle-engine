Index: glcarbonaglcontext.pas
===================================================================
--- glcarbonaglcontext.pas	(revision 37259)
+++ glcarbonaglcontext.pas	(working copy)
@@ -32,7 +32,7 @@
 procedure LOpenGLClip(Handle: HWND);
 function LOpenGLCreateContext(AWinControl: TWinControl;
               {%H-}WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-              DoubleBuffered, RGBA: boolean;
+              DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
               const {%H-}AParams: TCreateParams): HWND;
 procedure LOpenGLDestroyContextInfo(AWinControl: TWinControl);
 function CreateOpenGLContextAttrList(DoubleBuffered: boolean;
@@ -162,7 +162,7 @@
 
 function LOpenGLCreateContext(AWinControl: TWinControl;
   WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-  DoubleBuffered, RGBA: boolean;
+  DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
   const AParams: TCreateParams): HWND;
 var
   disp: GDHandle;
Index: glwin32wglcontext.pas
===================================================================
--- glwin32wglcontext.pas	(revision 37259)
+++ glwin32wglcontext.pas	(working copy)
@@ -28,7 +28,7 @@
 function LOpenGLMakeCurrent(Handle: HWND): boolean;
 function LOpenGLCreateContext(AWinControl: TWinControl;
                     WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-                    DoubleBuffered, RGBA: boolean;
+                    DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
                     const AParams: TCreateParams): HWND;
 procedure LOpenGLDestroyContextInfo(AWinControl: TWinControl);
 
@@ -276,13 +276,138 @@
   end;
 end;
 
+var
+  Temp_h_GLRc: HGLRC;
+  Temp_h_Dc: HDC;
+  Temp_h_Wnd: HWND;
+
+procedure LGlMsDestroyTemporaryWindow; forward;
+
+procedure LGlMsCreateTemporaryWindow;
+var
+  PixelFormat: LongInt;
+  pfd: PIXELFORMATDESCRIPTOR;
+begin
+  Temp_h_Wnd := 0;
+  Temp_h_Dc := 0;
+  Temp_h_GLRc := 0;
+
+  try
+    { create Temp_H_wnd }
+    Temp_H_wnd := CreateWindowEx(WS_EX_APPWINDOW or WS_EX_WINDOWEDGE,
+      PChar('STATIC'),
+      PChar('temporary window for wgl'),
+      WS_OVERLAPPEDWINDOW or WS_CLIPSIBLINGS or WS_CLIPCHILDREN,
+      0, 0, 100, 100,
+      0 { no parent window }, 0 { no menu }, hInstance,
+      nil);
+
+    { create Temp_h_Dc }
+    Temp_h_Dc := GetDC(Temp_h_Wnd);
+
+    { create and set PixelFormat (must support OpenGL to be able to
+      later do wglCreateContext) }
+    FillChar(pfd, SizeOf(pfd), 0);
+    with pfd do
+    begin
+      nSize := SizeOf(PIXELFORMATDESCRIPTOR);
+      nVersion := 1;
+      dwFlags := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL;
+      iPixelType := PFD_TYPE_RGBA;
+      iLayerType := PFD_MAIN_PLANE;
+    end;
+    PixelFormat := ChoosePixelFormat(Temp_h_Dc, @pfd);
+    SetPixelFormat(Temp_h_Dc, PixelFormat, @pfd);
+
+    { create and make current Temp_h_GLRc }
+    Temp_h_GLRc := wglCreateContext(Temp_h_Dc);
+    wglMakeCurrent(Temp_h_Dc, Temp_h_GLRc);
+  except
+    { make sure to finalize all partially initialized window parts }
+    LGlMsDestroyTemporaryWindow;
+    raise;
+  end;
+end;
+
+procedure LGlMsDestroyTemporaryWindow;
+begin
+  if Temp_h_GLRc <> 0 then
+  begin
+    wglMakeCurrent(Temp_h_Dc, 0);
+    wglDeleteContext(Temp_h_GLRc);
+    Temp_h_GLRc := 0;
+  end;
+
+  if Temp_h_Dc <> 0 then
+  begin
+    ReleaseDC(Temp_h_Wnd, Temp_h_Dc);
+    Temp_h_Dc := 0;
+  end;
+
+  if Temp_h_Wnd <> 0 then
+  begin
+    DestroyWindow(Temp_h_Wnd);
+    Temp_h_Wnd := 0;
+  end;
+end;
+
+function LGlMsCreateOpenGLContextAttrList(DoubleBuffered: boolean; RGBA: boolean; MultiSample: integer
+  ): PInteger;
+var
+  p: integer;
+
+  procedure Add(i: integer);
+  begin
+    if Result<>nil then
+      Result[p]:=i;
+    inc(p);
+  end;
+
+  procedure CreateList;
+  begin
+    Add(WGL_DRAW_TO_WINDOW_ARB); Add(GL_TRUE);
+    Add(WGL_SUPPORT_OPENGL_ARB); Add(GL_TRUE);
+    Add(WGL_ACCELERATION_ARB); Add(WGL_FULL_ACCELERATION_ARB);
+    if DoubleBuffered then
+      begin Add(WGL_DOUBLE_BUFFER_ARB); Add(GL_TRUE); end;
+    Add(WGL_PIXEL_TYPE_ARB);
+    if RGBA then
+      Add(WGL_TYPE_RGBA_ARB)
+    else
+      Add(WGL_TYPE_COLORINDEX_ARB);
+
+    Add(WGL_COLOR_BITS_ARB);  Add(24);
+    Add(WGL_DEPTH_BITS_ARB);  Add(16);
+    if MultiSample > 0 then
+    begin
+      Add(WGL_SAMPLE_BUFFERS_ARB); Add(1);
+      Add(WGL_SAMPLES_ARB);        Add(MultiSample);
+    end;
+    Add(0); Add(0);
+  end;
+
+begin
+  Result:=nil;
+  p:=0;
+  CreateList;
+  GetMem(Result,SizeOf(integer)*p);
+  p:=0;
+  CreateList;
+end;
+
 function LOpenGLCreateContext(AWinControl: TWinControl;
   WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-  DoubleBuffered, RGBA: boolean; const AParams: TCreateParams): HWND;
+  DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
+  const AParams: TCreateParams): HWND;
 var
   Params: TCreateWindowExParams;
   pfd: PIXELFORMATDESCRIPTOR;
   Info: PWGLControlInfo;
+
+  ReturnedFormats: UINT;
+  VisualAttrList: PInteger;
+  VisualAttrFloat: array [0..1] of Single;
+  MsInitSuccess: WINBOOL;
 begin
   InitWGL;
   //InitOpenGLContextGLWindowClass;
@@ -323,15 +448,35 @@
     cDepthBits:=16; // Z-Buffer
     iLayerType:=PFD_MAIN_PLANE;
   end;
-  
-  Info^.PixelFormat:=ChoosePixelFormat(Info^.DC,@pfd);
-  if Info^.PixelFormat=0 then
-    raise Exception.Create('LOpenGLCreateContext ChoosePixelFormat failed');
 
-  // set pixel format in device context
-  if not SetPixelFormat(Info^.DC,Info^.PixelFormat,@pfd) then
-    raise Exception.Create('LOpenGLCreateContext SetPixelFormat failed');
+  MsInitSuccess := false;
+  if (MultiSampling > 1) and WGL_ARB_multisample and WGL_ARB_pixel_format
+    and Assigned(wglChoosePixelFormatARB) then
+  begin
+    VisualAttrList := LGlMsCreateOpenGLContextAttrList(DoubleBuffered, RGBA, MultiSampling);
+    try
+      FillChar(VisualAttrFloat, SizeOf(VisualAttrFloat), 0);
+      MsInitSuccess := wglChoosePixelFormatARB(Info^.DC, PGLint(VisualAttrList),
+                         @VisualAttrFloat[0], 1, @Info^.PixelFormat, @ReturnedFormats);
+    finally FreeMem(VisualAttrList) end;
 
+    if MsInitSuccess and (ReturnedFormats >= 1) then
+       SetPixelFormat(Info^.DC, Info^.PixelFormat, nil)
+    else
+       MsInitSuccess := false;
+  end;
+
+  if not MsInitSuccess then
+  begin
+    Info^.PixelFormat:=ChoosePixelFormat(Info^.DC,@pfd);
+    if Info^.PixelFormat=0 then
+      raise Exception.Create('LOpenGLCreateContext ChoosePixelFormat failed');
+
+    // set pixel format in device context
+    if not SetPixelFormat(Info^.DC,Info^.PixelFormat,@pfd) then
+      raise Exception.Create('LOpenGLCreateContext SetPixelFormat failed');
+  end;
+
   // create WGL context
   Info^.WGLContext:=wglCreateContext(Info^.DC);
   if Info^.WGLContext=0 then
@@ -370,6 +515,11 @@
   WGLInitialized:=true;
 
   try
+    { to successfully use wglGetExtensionsStringARB (to query e.g. ARB_multisample,
+      needed for MultiSampling), you need to have OpenGL context 
+      already initialized. We create a temporary window for this purpose. }
+    LGlMsCreateTemporaryWindow;
+
     // ARB wgl extensions
     Pointer(wglGetExtensionsStringARB) := GLGetProcAddress('wglGetExtensionsStringARB');
     Pointer(wglGetPixelFormatAttribivARB) := GLGetProcAddress('wglGetPixelFormatAttribivARB');
@@ -393,8 +543,10 @@
 
     // ARB wgl extensions
     if Assigned(wglGetExtensionsStringARB) then
-      Buffer:=wglGetExtensionsStringARB(wglGetCurrentDC)
-    else
+    begin
+      Buffer:=wglGetExtensionsStringARB(Temp_h_Dc);
+      { Writeln('WGL extensions supported: ', Buffer); }
+    end else
       Buffer:='';
     WGL_ARB_multisample:=CheckExtension('WGL_ARB_multisample');
     WGL_EXT_swap_control:=CheckExtension('WGL_EXT_swap_control');
@@ -408,6 +560,7 @@
       DebugLn('InitWGL ',E.Message);
     end;
   end;
+  LGlMsDestroyTemporaryWindow;
 end;
 
 procedure InitOpenGLContextGLWindowClass;
Index: glgtkglxcontext.pas
===================================================================
--- glgtkglxcontext.pas	(revision 37259)
+++ glgtkglxcontext.pas	(working copy)
@@ -53,38 +53,35 @@
 const
   GLXTrue = 1;
   GLXFalse = 0;
-{$ENDIF}
-// gdkgl
-const
-// enum _GDK_GL_CONFIGS
-  GDK_GL_NONE                           = 0;
-  GDK_GL_USE_GL                         = 1;
-  GDK_GL_BUFFER_SIZE                    = 2;
-  GDK_GL_LEVEL                          = 3;
-  GDK_GL_RGBA                           = 4;
-  GDK_GL_DOUBLEBUFFER                   = 5;
-  GDK_GL_STEREO                         = 6;
-  GDK_GL_AUX_BUFFERS                    = 7;
-  GDK_GL_RED_SIZE                       = 8;
-  GDK_GL_GREEN_SIZE                     = 9;
-  GDK_GL_BLUE_SIZE                      = 10;
-  GDK_GL_ALPHA_SIZE                     = 11;
-  GDK_GL_DEPTH_SIZE                     = 12;
-  GDK_GL_STENCIL_SIZE                   = 13;
-  GDK_GL_ACCUM_RED_SIZE                 = 14;
-  GDK_GL_ACCUM_GREEN_SIZE               = 15;
-  GDK_GL_ACCUM_BLUE_SIZE                = 16;
-  GDK_GL_ACCUM_ALPHA_SIZE               = 17;
+  
+  { Constants below are the same as in FPC GLX unit. }
 
-  // GLX_EXT_visual_info extension
-  GDK_GL_X_VISUAL_TYPE_EXT              = $22;
-  GDK_GL_TRANSPARENT_TYPE_EXT           = $23;
-  GDK_GL_TRANSPARENT_INDEX_VALUE_EXT    = $24;
-  GDK_GL_TRANSPARENT_RED_VALUE_EXT      = $25;
-  GDK_GL_TRANSPARENT_GREEN_VALUE_EXT    = $26;
-  GDK_GL_TRANSPARENT_BLUE_VALUE_EXT     = $27;
-  GDK_GL_TRANSPARENT_ALPHA_VALUE_EXT    = $28;
+  // GLX 1.3 and later:
+  GLX_X_RENDERABLE                = $8012;
+  
+  // Tokens for glXChooseVisual and glXGetConfig.
+  GLX_USE_GL                            = 1;
+  GLX_BUFFER_SIZE                       = 2;
+  GLX_LEVEL                             = 3;
+  GLX_RGBA                              = 4;
+  GLX_DOUBLEBUFFER                      = 5;
+  GLX_STEREO                            = 6;
+  GLX_AUX_BUFFERS                       = 7;
+  GLX_RED_SIZE                          = 8;
+  GLX_GREEN_SIZE                        = 9;
+  GLX_BLUE_SIZE                         = 10;
+  GLX_ALPHA_SIZE                        = 11;
+  GLX_DEPTH_SIZE                        = 12;
+  GLX_STENCIL_SIZE                      = 13;
+  GLX_ACCUM_RED_SIZE                    = 14;
+  GLX_ACCUM_GREEN_SIZE                  = 15;
+  GLX_ACCUM_BLUE_SIZE                   = 16;
+  GLX_ACCUM_ALPHA_SIZE                  = 17;
 
+  // GLX_ARB_multisample
+  GLX_SAMPLE_BUFFERS_ARB             = 100000;
+  GLX_SAMPLES_ARB                    = 100001;
+{$ENDIF}
 
 type
   TGdkGLContext = record end;
@@ -151,11 +148,15 @@
 function LOpenGLMakeCurrent(Handle: HWND): boolean;
 function LOpenGLCreateContext(AWinControl: TWinControl;
              WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-             DoubleBuffered, RGBA: boolean;
+             DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
              const AParams: TCreateParams): HWND;
 procedure LOpenGLDestroyContextInfo(AWinControl: TWinControl);
+
+{ Create GLX attributes list suitable for glXChooseVisual or glXChooseFBConfig.
+  Note that if MultiSampling is > 1, it is expected that caller 
+  already checked that GLX_ARB_multisample is available. }
 function CreateOpenGLContextAttrList(DoubleBuffered: boolean;
-                                     RGBA: boolean): PInteger;
+  RGBA: boolean; MultiSampling: Cardinal): PInteger;
 
 implementation
 
@@ -425,16 +426,6 @@
   FBConfig: TGLXFBConfig;
   FBConfigs: PGLXFBConfig;
   FBConfigsCount: Integer;
-
-  { Attributes to choose context with glXChooseFBConfig.
-    Similar to Attr, but not exactly compatible. }
-  AttrFB: Array[0..10] of integer = (
-    GLX_X_RENDERABLE, 1 { true },
-    GLX_RED_SIZE, 1,
-    GLX_GREEN_SIZE, 1,
-    GLX_BLUE_SIZE, 1,
-    GLX_DOUBLEBUFFER, 1 { true },
-    none);
 {$ENDIF}
 
 begin
@@ -449,7 +440,7 @@
       if GLX_version_1_3(dpy) then begin
         { use approach recommended since glX 1.3 }
         FBConfigsCount:=0;
-        FBConfigs:=glXChooseFBConfig(dpy, DefaultScreen(dpy), AttrFB, FBConfigsCount);
+        FBConfigs:=glXChooseFBConfig(dpy, DefaultScreen(dpy), @attrList[0], FBConfigsCount);
         if FBConfigsCount = 0 then
           raise Exception.Create('Could not find FB config');
 
@@ -681,7 +672,7 @@
   Size: Integer;
 begin
   Count:=0;
-  while (attrList[Count]<>GDK_GL_NONE) do inc(Count);
+  while (attrList[Count]<>0) do inc(Count);
   inc(Count);
   Size:=SizeOf(Integer)*Count;
   CopyAttrList:=nil;
@@ -834,9 +825,9 @@
 end;
 {$ENDIF}
 
-function LOpenGLCreateContext(AWinControl: TWinControl;
+function LOpenGLCreateContextCore(AWinControl: TWinControl;
   WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-  DoubleBuffered, RGBA: boolean;
+  DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
   const AParams: TCreateParams): HWND;
 var
   NewWidget: PGtkWidget;
@@ -844,7 +835,7 @@
   AttrList: PInteger;
 begin
   if WSPrivate=nil then ;
-  AttrList:=CreateOpenGLContextAttrList(DoubleBuffered,RGBA);
+  AttrList:=CreateOpenGLContextAttrList(DoubleBuffered,RGBA,MultiSampling);
   try
     if SharedControl<>nil then begin
       SharedArea:={%H-}PGtkGLArea(PtrUInt(SharedControl.Handle));
@@ -868,16 +859,44 @@
   end;
 end;
 
+function LOpenGLCreateContext(AWinControl: TWinControl;
+  WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
+  DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
+  const AParams: TCreateParams): HWND;
+begin
+  if (MultiSampling > 1) and
+     {$IFDEF UseFPGLX}
+     GLX_ARB_multisample(GetDefaultXDisplay, DefaultScreen(GetDefaultXDisplay))
+     {$ELSE}
+     false { no GLX_ARB_multisample support when UseFPGLX undefined,
+             it would be too convoluted to replicate GLX unit extension querying
+             functionality here }
+     {$ENDIF} then
+  try
+    Result := LOpenGLCreateContextCore(AWinControl, WSPrivate, SharedControl, 
+      DoubleBuffered, RGBA, MultiSampling, AParams);
+  except
+    { retry without MultiSampling }
+    Result := LOpenGLCreateContextCore(AWinControl, WSPrivate, SharedControl, 
+      DoubleBuffered, RGBA, 1, AParams);
+  end else
+    { no multi-sampling requested (or GLX_ARB_multisample not available),
+      just pass to LOpenGLCreateContextCore }
+    Result := LOpenGLCreateContextCore(AWinControl, WSPrivate, SharedControl, 
+      DoubleBuffered, RGBA, MultiSampling, AParams);
+end;
+
 procedure LOpenGLDestroyContextInfo(AWinControl: TWinControl);
 begin
   if not AWinControl.HandleAllocated then exit;
   // nothing to do
 end;
 
-function CreateOpenGLContextAttrList(DoubleBuffered: boolean; RGBA: boolean
-  ): PInteger;
+function CreateOpenGLContextAttrList(DoubleBuffered: boolean; RGBA: boolean;
+  MultiSampling: Cardinal): PInteger;
 var
   p: integer;
+  UseFBConfig: boolean;
   
   procedure Add(i: integer);
   begin
@@ -888,19 +907,35 @@
   
   procedure CreateList;
   begin
+    if UseFBConfig then begin Add(GLX_X_RENDERABLE); Add(1); end;
     if DoubleBuffered then
-      Add(GDK_GL_DOUBLEBUFFER);
+    begin
+      if UseFBConfig then 
+        begin Add(GLX_DOUBLEBUFFER); Add(1); end else
+        Add(GLX_DOUBLEBUFFER);
+    end;
     if RGBA then
-      Add(GDK_GL_RGBA);
-    Add(GDK_GL_RED_SIZE);  Add(1);
-    Add(GDK_GL_GREEN_SIZE);  Add(1);
-    Add(GDK_GL_BLUE_SIZE);  Add(1);
-    Add(GDK_GL_DEPTH_SIZE);  Add(1);
-    Add(GDK_GL_STENCIL_SIZE); Add(1);
-    Add(GDK_GL_None);
+    begin
+      if not UseFBConfig then Add(GLX_RGBA);
+      { For UseFBConfig, glXChooseFBConfig already defaults to RGBA }
+    end;
+    Add(GLX_RED_SIZE);  Add(1);
+    Add(GLX_GREEN_SIZE);  Add(1);
+    Add(GLX_BLUE_SIZE);  Add(1);
+    Add(GLX_DEPTH_SIZE);  Add(1);
+    Add(GLX_STENCIL_SIZE); Add(1);
+    
+    if MultiSampling > 1 then
+    begin
+      Add(GLX_SAMPLE_BUFFERS_ARB); Add(1);
+      Add(GLX_SAMPLES_ARB); Add(MultiSampling);
+    end;
+    
+    Add(0); { 0 = X.None (be careful: GLX_NONE is something different) }
   end;
   
 begin
+  UseFBConfig := {$IFDEF UseFPGLX} GLX_version_1_3(GetDefaultXDisplay) {$else} false {$endif};
   Result:=nil;
   p:=0;
   CreateList;
Index: openglcontext.pas
===================================================================
--- openglcontext.pas	(revision 37259)
+++ openglcontext.pas	(working copy)
@@ -109,12 +109,14 @@
     FCurrentFrameTime: integer; // in msec
     FLastFrameTime: integer; // in msec
     FRGBA: boolean;
+    FMultiSampling: Cardinal;
     FSharedOpenGLControl: TCustomOpenGLControl;
     FSharingOpenGlControls: TList;
     function GetSharingControls(Index: integer): TCustomOpenGLControl;
     procedure SetAutoResizeViewport(const AValue: boolean);
     procedure SetDoubleBuffered(const AValue: boolean);
     procedure SetRGBA(const AValue: boolean);
+    procedure SetMultiSampling(const AMultiSampling: Cardinal);
     procedure SetSharedControl(const AValue: TCustomOpenGLControl);
   protected
     procedure WMPaint(var Message: TLMPaint); message LM_PAINT;
@@ -145,6 +147,19 @@
                                          write SetAutoResizeViewport default false;
     property DoubleBuffered: boolean read FDoubleBuffered write SetDoubleBuffered default true;
     property RGBA: boolean read FRGBA write SetRGBA default true;
+
+    { Number of samples per pixel, for OpenGL multi-sampling (anti-aliasing).
+
+      Value <= 1 means that we use 1 sample per pixel, which means no anti-aliasing.
+      Higher values mean anti-aliasing. Exactly which values are supported
+      depends on GPU, common modern GPUs support values like 2 and 4.
+      
+      If this is > 1, and we will not be able to create OpenGL
+      with multi-sampling, we will fallback to normal non-multi-sampled context.
+      You can query OpenGL values GL_SAMPLE_BUFFERS_ARB and GL_SAMPLES_ARB 
+      (see ARB_multisample extension) to see how many samples have been 
+      actually allocated for your context. }
+    property MultiSampling: Cardinal read FMultiSampling write SetMultiSampling default 1;
   end;
 
   { TOpenGLControl }
@@ -156,6 +171,7 @@
     property AutoResizeViewport;
     property BorderSpacing;
     property Enabled;
+    property MultiSampling;
     property OnChangeBounds;
     property OnClick;
     property OnConstrainedResize;
@@ -241,6 +257,13 @@
   OpenGLAttributesChanged;
 end;
 
+procedure TCustomOpenGLControl.SetMultiSampling(const AMultiSampling: Cardinal);
+begin
+  if FMultiSampling=AMultiSampling then exit;
+  FMultiSampling:=AMultiSampling;
+  OpenGLAttributesChanged;
+end;
+
 procedure TCustomOpenGLControl.SetSharedControl(
   const AValue: TCustomOpenGLControl);
 begin
@@ -329,6 +352,7 @@
   inherited Create(TheOwner);
   FDoubleBuffered:=true;
   FRGBA:=true;
+  FMultiSampling:=1;
   ControlStyle:=ControlStyle-[csSetCaption];
   if (csDesigning in ComponentState) then begin
     FCanvas := TControlCanvas.Create;
@@ -470,6 +494,7 @@
     Result:=LOpenGLCreateContext(OpenGlControl,WSPrivate,
                                  OpenGlControl.SharedControl,
                                  AttrControl.DoubleBuffered,AttrControl.RGBA,
+                                 AttrControl.MultiSampling,
                                  AParams);
   end;
 end;
Index: glqtcontext.pas
===================================================================
--- glqtcontext.pas	(revision 37259)
+++ glqtcontext.pas	(working copy)
@@ -70,7 +70,7 @@
 function LOpenGLMakeCurrent(Handle: HWND): boolean;
 function LOpenGLCreateContext(AWinControl: TWinControl;
              WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
-             DoubleBuffered, RGBA: boolean;
+             DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
              const AParams: TCreateParams): HWND;
 procedure LOpenGLDestroyContextInfo(AWinControl: TWinControl);
 function CreateOpenGLContextAttrList(DoubleBuffered: boolean;
@@ -183,8 +183,9 @@
 end;
 
 function LOpenGLCreateContext(AWinControl: TWinControl;
-  WSPrivate: TWSPrivateClass; SharedControl: TWinControl; DoubleBuffered,
-  RGBA: boolean; const AParams: TCreateParams): HWND;
+  WSPrivate: TWSPrivateClass; SharedControl: TWinControl;
+  DoubleBuffered, RGBA: boolean; MultiSampling: Cardinal;
+  const AParams: TCreateParams): HWND;
 var
   AttrList: PInteger;
   NewQtWidget: TQtGLWidget;
