{
  Copyright 2002-2011 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{$ifdef read_interface}
  { }
  TNodeX3DFontStyleNode = class(TNodeX3DNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
  end;

  { Font family that can be specified by FontStyle node in family
    field. First three fields are equal (after casting by Ord) to
    three values of FSFAMILY_* constants. }
  TVRMLFontFamily = (ffSerif, ffSans, ffTypeWriter);

  { Font justification that can be specified by FontStyle in
    justify/justification field. First three fields are equal
    (after casting by Ord) to JUSTIFICATION_* constants. }
  TVRMLFontJustify = (fjBegin, fjMiddle, fjEnd);

  TNodeFontStyle_2 = class(TNodeX3DFontStyleNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdfamily: TMFString;
    public property Fdfamily: TMFString read FFdfamily;

    private FFdhorizontal: TSFBool;
    public property Fdhorizontal: TSFBool read FFdhorizontal;

    private FFdjustify: TMFString;
    public property Fdjustify: TMFString read FFdjustify;

    private FFdlanguage: TSFString;
    public property Fdlanguage: TSFString read FFdlanguage;

    private FFdleftToRight: TSFBool;
    public property FdleftToRight: TSFBool read FFdleftToRight;

    private FFdsize: TSFFloat;
    public property Fdsize: TSFFloat read FFdsize;

    private FFdspacing: TSFFloat;
    public property Fdspacing: TSFFloat read FFdspacing;

    private FFdstyle: TSFString;
    public property Fdstyle: TSFString read FFdstyle;

    private FFdtopToBottom: TSFBool;
    public property FdtopToBottom: TSFBool read FFdtopToBottom;

    class function ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
      override;

    function Family: TVRMLFontFamily;
    function Bold: boolean;
    function Italic: boolean;
    function Justify: TVRMLFontJustify;
    function TTF_Font: PTrueTypeFont;

    class function DefaultSize: Single;
    class function DefaultSpacing: Single;
    class function DefaultFamily: TVRMLFontFamily;
    class function DefaultBold: boolean;
    class function DefaultItalic: boolean;
    class function DefaultJustify: TVRMLFontJustify;
    class function DefaultTTF_Font: PTrueTypeFont;

    class function ClassTTF_Font(AFamily: TVRMLFontFamily;
      const ABold, AItalic: boolean): PTrueTypeFont;
  end;

  TNodeText = class(TNodeX3DGeometryNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdfontStyle: TSFNode;
    public property FdfontStyle: TSFNode read FFdfontStyle;

    private FFdlength: TMFFloat;
    public property Fdlength: TMFFloat read FFdlength;

    private FFdmaxExtent: TSFFloat;
    public property FdmaxExtent: TSFFloat read FFdmaxExtent;

    private FFdstring: TMFString;
    public property Fdstring: TMFString read FFdstring;

    { Event: MFVec2f, out } { }
    private FEventlineBounds: TVRMLEvent;
    public property EventlineBounds: TVRMLEvent read FEventlineBounds;

    { Event: SFVec3f, out } { }
    private FEventorigin: TVRMLEvent;
    public property Eventorigin: TVRMLEvent read FEventorigin;

    { Event: SFVec2f, out } { }
    private FEventtextBounds: TVRMLEvent;
    public property EventtextBounds: TVRMLEvent read FEventtextBounds;

    private FFdsolid: TSFBool;
    public property Fdsolid: TSFBool read FFdsolid;

    function LocalBoundingBox(State: TVRMLGraphTraverseState;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): TBox3D; override;
    function VerticesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;

    { This returns FdFontStyle.Value. Returns nil if FdFontStyle.Value
      is nil or if it's not TNodeFontStyle_2. }
    function FontStyle: TNodeFontStyle_2;
  end;

{$endif read_interface}

{$ifdef read_implementation}
constructor TNodeX3DFontStyleNode.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  DefaultContainerField := 'fontStyle';
end;

const
  TTF_Font_Results: array[TVRMLFontFamily, boolean, boolean]of PTrueTypeFont =
  (              {   [],                          [italic],                            [bold],                      [italic, bold] }
    {serif}      ( ((@TTF_BitstreamVeraSerif),   (@TTF_BitstreamVeraSerif_Italic)),    ((@TTF_BitstreamVeraSerif_Bold),    (@TTF_BitstreamVeraSerif_Bold_Italic)) ),
    {sans}       ( ((@TTF_BitstreamVeraSans),    (@TTF_BitstreamVeraSans_Italic)),     ((@TTF_BitstreamVeraSans_Bold),     (@TTF_BitstreamVeraSans_Bold_Italic)) ),
    {typewriter} ( ((@TTF_BitstreamVeraSansMono),(@TTF_BitstreamVeraSansMono_Italic)), ((@TTF_BitstreamVeraSansMono_Bold), (@TTF_BitstreamVeraSansMono_Bold_Italic)) )
  );

constructor TNodeFontStyle_2.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdfamily := TMFString.Create(Self, 'family', ['SERIF']);
   Fdfamily.Exposed := false;
   Fdfamily.ChangesAlways := [chFontStyle];
  Fields.Add(FFdfamily);

  FFdhorizontal := TSFBool.Create(Self, 'horizontal', true);
   Fdhorizontal.Exposed := false;
   Fdhorizontal.ChangesAlways := [chFontStyle];
  Fields.Add(FFdhorizontal);

  FFdjustify := TMFString.Create(Self, 'justify', ['BEGIN']);
   Fdjustify.Exposed := false;
   Fdjustify.ChangesAlways := [chFontStyle];
  Fields.Add(FFdjustify);
  { X3D specification comment: ["BEGIN","END","FIRST","MIDDLE",""] }

  FFdlanguage := TSFString.Create(Self, 'language', '');
   Fdlanguage.Exposed := false;
   Fdlanguage.ChangesAlways := [chFontStyle];
  Fields.Add(FFdlanguage);

  FFdleftToRight := TSFBool.Create(Self, 'leftToRight', true);
   FdleftToRight.Exposed := false;
   FdleftToRight.ChangesAlways := [chFontStyle];
  Fields.Add(FFdleftToRight);

  FFdsize := TSFFloat.Create(Self, 'size', DefaultSize);
   Fdsize.Exposed := false;
   Fdsize.ChangesAlways := [chFontStyle];
  Fields.Add(FFdsize);
  { X3D specification comment: (0,Inf) }

  FFdspacing := TSFFloat.Create(Self, 'spacing', DefaultSpacing);
   Fdspacing.Exposed := false;
   Fdspacing.ChangesAlways := [chFontStyle];
  Fields.Add(FFdspacing);
  { X3D specification comment: [0,Inf) }

  FFdstyle := TSFString.Create(Self, 'style', 'PLAIN');
   Fdstyle.Exposed := false;
   Fdstyle.ChangesAlways := [chFontStyle];
  Fields.Add(FFdstyle);
  { X3D specification comment: ["PLAIN"|"BOLD"|"ITALIC"|"BOLDITALIC"|""] }

  FFdtopToBottom := TSFBool.Create(Self, 'topToBottom', true);
   FdtopToBottom.Exposed := false;
   FdtopToBottom.ChangesAlways := [chFontStyle];
  Fields.Add(FFdtopToBottom);
end;

class function TNodeFontStyle_2.ClassNodeTypeName: string;
begin
  Result := 'FontStyle';
end;

function TNodeFontStyle_2.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeFontStyle_2.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

class function TNodeFontStyle_2.ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
begin
  Result := VerMajor >= 2;
end;

function TNodeFontStyle_2.TTF_Font: PTrueTypeFont;
begin
  Result := TTF_Font_Results[Family, Bold, Italic];
end;

class function TNodeFontStyle_2.ClassTTF_Font(
  AFamily: TVRMLFontFamily; const ABold, AItalic: boolean): PTrueTypeFont;
begin
  Result := TTF_Font_Results[AFamily, ABold, AItalic];
end;

function TNodeFontStyle_2.Family: TVRMLFontFamily;
var
  I: Integer;
begin
  for I := 0 to FdFamily.Items.Count - 1 do
    if FdFamily.Items[I] = 'SERIF' then
      Exit(ffSerif) else
    if FdFamily.Items[I] = 'SANS' then
      Exit(ffSans) else
    if FdFamily.Items[I] = 'TYPEWRITER' then
      Exit(ffTypeWriter) else
      VRMLWarning(vwSerious, 'Font family "' + FdFamily.Items[I] + '" not supported');

  { If no supported values on FdFamily.Items then fall back to serif }
  Result := ffSerif;
end;

const
  StyleBold = 'BOLD';
  StyleBoldItalic = 'BOLDITALIC';
  StyleItalic = 'ITALIC';
  StylePlain = 'PLAIN';

function TNodeFontStyle_2.Bold: boolean;
begin
  Result :=
    (FdStyle.Value = StyleBold) or
    (FdStyle.Value = StyleBoldItalic);

  { This is the end of calculating Result.
    But we would like to make a warning in case of invalid FdStyle
    value, so we do check below. }

  if not Result then
  begin
    if not (
      (FdStyle.Value = StyleItalic) or
      (FdStyle.Value = StylePlain) or
      (FdStyle.Value = '')) then
      VRMLWarning(vwSerious, 'Font style "' + FdStyle.Value + '" not supported');
  end;
end;

function TNodeFontStyle_2.Italic: boolean;
begin
  Result :=
    (FdStyle.Value = StyleItalic) or
    (FdStyle.Value = StyleBoldItalic);

  { This is the end of calculating Result.
    But we would like to make a warning in case of invalid FdStyle
    value, so we do check below. }

  if not Result then
  begin
    if not (
      (FdStyle.Value = StyleBold) or
      (FdStyle.Value = StylePlain) or
      (FdStyle.Value = '')) then
      VRMLWarning(vwSerious, 'Font style "' + FdStyle.Value + '" not supported');
  end;
end;

function TNodeFontStyle_2.Justify: TVRMLFontJustify;
const
  SJustifyObsolete = 'Font justify "%s" should not be used in VRML >= 2.0, use "%s" instead';
var
  J: string;
begin
  if FdJustify.Items.Count = 0 then
    Result := fjBegin else
  begin
    { Some X3D models use lowercase names, like [http://instant-reality.com/]
      test models. }
    J := UpperCase(FdJustify.Items[0]);
    if J <> FdJustify.Items[0] then
      VRMLWarning(vwSerious, Format(
        'Font justify value "%s" should be specified in uppercase',
        [ FdJustify.Items[0] ]));

    if (J = 'BEGIN') or
       (J = 'FIRST') then
      Result := fjBegin else
    if J = 'MIDDLE' then
      Result := fjMiddle else
    if J = 'END' then
      Result := fjEnd else

    { Some X3D models use old justify names, like cic.nist.gov X3D demos. }
    if J = 'LEFT' then
    begin
      VRMLWarning(vwSerious, Format(SJustifyObsolete, ['LEFT', 'BEGIN']));
      Result := fjBegin;
    end else
    if J = 'CENTER' then
    begin
      VRMLWarning(vwSerious, Format(SJustifyObsolete, ['CENTER', 'MIDDLE']));
      Result := fjMiddle;
    end else
    if J = 'RIGHT' then
    begin
      VRMLWarning(vwSerious, Format(SJustifyObsolete, ['RIGHT', 'END']));
      Result := fjEnd;
    end else

    begin
      Result := fjBegin;
      VRMLWarning(vwSerious, 'Font justify "' + FdJustify.Items[0] +
        '" not supported');
    end;
  end;
end;

class function TNodeFontStyle_2.DefaultSize: Single;
begin
  Result := 1;
end;

class function TNodeFontStyle_2.DefaultSpacing: Single;
begin
  Result := 1;
end;

class function TNodeFontStyle_2.DefaultFamily: TVRMLFontFamily;
begin
  Result := ffSerif;
end;

class function TNodeFontStyle_2.DefaultBold: boolean;
begin
  Result := false;
end;

class function TNodeFontStyle_2.DefaultItalic: boolean;
begin
  Result := false;
end;

class function TNodeFontStyle_2.DefaultJustify: TVRMLFontJustify;
begin
  Result := fjBegin;
end;

class function TNodeFontStyle_2.DefaultTTF_Font: PTrueTypeFont;
begin
  Result := TTF_Font_Results[DefaultFamily, DefaultBold, DefaultItalic];
end;

constructor TNodeText.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdfontStyle := TSFNode.Create(Self, 'fontStyle', [TNodeX3DFontStyleNode]);
   FdfontStyle.ChangesAlways := [chGeometry];
  Fields.Add(FFdfontStyle);

  FFdlength := TMFFloat.Create(Self, 'length', []);
   Fdlength.ChangesAlways := [chGeometry];
  Fields.Add(FFdlength);
  { X3D specification comment: [0,Inf) }

  FFdmaxExtent := TSFFloat.Create(Self, 'maxExtent', 0.0);
   FdmaxExtent.ChangesAlways := [chGeometry];
  Fields.Add(FFdmaxExtent);
  { X3D specification comment: [0,Inf) }

  FFdstring := TMFString.Create(Self, 'string', []);
   Fdstring.ChangesAlways := [chGeometry];
  Fields.Add(FFdstring);

  FEventlineBounds := TVRMLEvent.Create(Self, 'lineBounds', TMFVec2f, false);
  Events.Add(FEventlineBounds);

  FEventorigin := TVRMLEvent.Create(Self, 'origin', TSFVec3f, false);
  Events.Add(FEventorigin);

  FEventtextBounds := TVRMLEvent.Create(Self, 'textBounds', TSFVec2f, false);
  Events.Add(FEventtextBounds);

  FFdsolid := TSFBool.Create(Self, 'solid', false);
   Fdsolid.Exposed := false;
   Fdsolid.ChangesAlways := [chGeometry];
  Fields.Add(FFdsolid);
end;

class function TNodeText.ClassNodeTypeName: string;
begin
  Result := 'Text';
end;

function TNodeText.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeText.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeText.FontStyle: TNodeFontStyle_2;
begin
  if (FdFontStyle.Value <> nil) and
     (FdFontStyle.Value is TNodeFontStyle_2) then
    Result := TNodeFontStyle_2(FdFontStyle.Value) else
    Result := nil;
end;

procedure RegisterTextNodes;
begin
  NodesManager.RegisterNodeClasses([
    TNodeFontStyle_2,
    TNodeText
  ]);
end;

{$endif read_implementation}
