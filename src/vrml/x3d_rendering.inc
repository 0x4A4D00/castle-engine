{
  Copyright 2002-2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{$ifdef read_interface}
  { }
  TCoordRangeHandler = procedure (const RangeNumber: Cardinal;
    BeginIndex, EndIndex: Integer) of object;

  TIndexedPolygonHandler = procedure (const Indexes: array of Cardinal)
    of object;

  ENotCoordinateBasedNode = class(EVRMLError);

  { Geometry nodes are the only nodes that produces some visible results
    during rendering. Much of the VRML language is just
    a method of describing properties how geometry nodes are displayed
    (materials, transformations, lighting).

    A few things that make geometry node special :
    @unorderedList(
      @item(Only geometry nodes may have [Local]BoundingBox.)
      @item(
        Only geometry nodes define something visible "in usual way"
        during rendering (Some other nodes in VRML / X3D are visible but in an
        unusual way, like Background and Fog. These nodes must be rendered in
        a special way --- they are not affected in any usual way by the current
        transformation matrix etc.))

      @item(
        Only geometry nodes can add triangles to the scene, so the Triangulate
        method can be defined only for geometry nodes.)

      @item(
        Geometry nodes are never "grouping nodes", in particular there's
        never a geometry node that is (direct or indirect) child of another
        geometry node. So there's no need to be concerned whether geometry nodes'
        children are included in things like [Local]BoundingBox or
        Triangles/VerticesCount.)

      @item(
        Geometry nodes don't affect anything in graph traverse state.
        (This is important mostly for VRML 1.0, since in newer VRML / X3D
        "graph traverse state" is not that important.))
    )

    For X3D, this descends from TNodeX3DNode, and TNodeX3DGeometryNode
    descends from us. This way in X3D TNodeX3DGeometryNode descends
    from this, and also X3D hierarchy is preserved (X3DGeometryNode
    must descend from X3DNode). }
  TVRMLGeometryNode = class(TNodeX3DNode)
  private
    { Workaround http://bugs.freepascal.org/view.php?id=17402
      by these methods. }
    function CallProxyLocalBoundingBox(
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): TBox3D;
    function CallProxyBoundingBox(
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): TBox3D;
    function CallProxyTrianglesCount(
      OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal;
    function CallProxyVerticesCount(
      OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal;
  public
    { Constructor.

      Only sets DefaultContainerField to 'geometry', since this is valid
      for all X3D nodes descending from TVRMLGeometryNode. }
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;

    { Calculate bounding box of this geometry node.
      They require State of this node during VRML traverse state --- this
      is mainly for VRML 1.0 nodes, that depend on such state.

      LocalBoundingBox gives a bounding box ignoring current transformation
      (or, equivalently, assuming like Transform = IdentityMatrix).
      Normal BoundingBox gives a bounding box taking current transformation
      into account.

      @italic(Notes for descendants implementors:)

      The default implementations of these methods in TVRMLGeometryNode
      try to be smart and cover all common bases, so that you have to do
      as little work as possible to implement working descendant.

      @orderedList(
        @item(
          For nodes based on coordinates (when @link(Coord) returns @true),
          LocalBoundingBox and BoundingBox
          already have optimal and correct implementation in this class.
          Using Coord and CoordIndex, no other information is needed.)

        @item(
          For other nodes, we first check ProxyGeometry and ProxyState.
          If ProxyGeometry is non-nil, we assume these came from @link(Proxy)
          call and we will use them to calculate
          bounding boxes, local and not local.

          So for nodes with @link(Proxy) overridden, you don't have
          to implement bounding box calculation, instead a ProxyGeometry
          will be created and provided here by the caller.
          This will work Ok if @link(Proxy) node will
          have bounding box calculation implemented.

          You can always override these methods, if you don't want
          to use proxy (for example, maybe there exists much faster
          method to calculate bounding box, or maybe tighter
          bounding box may be calculated directly).)

        @item(
          For other nodes (not coordinate-based and without a proxy):

          The default implementation of LocalBoundingBox just calls
          BoundingBox with a specially modified State, such that
          Transform is identity.

          The default implementation of BoundingBox, in turn, just calls
          LocalBoundingBox and transforms this bounding box.

          So the default implementations call each other, and will loop
          infinitely... But if you override any one of them
          (local or not local), the other one will magically work.

          Note that the default implementation of LocalBoundingBox
          may be non-optimal as far as time is concerned,
          as we'll do useless multiplications by identity matrix.
          And the default implementation of BoundingBox may generate
          non-optimal bounding box, more direct approach (transforming
          each vertex) may give much tightier bounding box.

          So you only have to override one method --- although if you
          want the best implementation, fastest and with the best tight
          bounding boxes, you may need to override both of them for some nodes.)
      )

      @groupBegin }
    function BoundingBox(State: TVRMLGraphTraverseState;
      ProxyGeometry: TVRMLGeometryNode;
      ProxyState: TVRMLGraphTraverseState): TBox3D; virtual;
    function LocalBoundingBox(State: TVRMLGraphTraverseState;
      ProxyGeometry: TVRMLGeometryNode;
      ProxyState: TVRMLGraphTraverseState): TBox3D; virtual;
    { @groupEnd }

    { Calculate vertex and triangles count of this node.

      They require State of this node during VRML traverse state --- this
      is mainly for VRML 1.0 nodes, that depend on such state.
      OverTriangulate has the same meaning as for Triangulate.

      Vertices count calculates number of different vertexes in this node.
      That is, it doesn't eliminate doubles in cases like Coordinate node
      with multiple points the same. But if some face is known to use
      twice the same vertex index, then this counts like a single vertex.
      The idea is that this indicates rendering speed.

      For triangles count, the returned value may be different then
      actual if some faces were non-convex. Things like TriangulateFace
      may remove degenerate triangles, so actual number of triangles may
      be slightly less. So don't depend on TrianglesCount as a precise
      measure --- but it's a good fast measure of complexity of given
      node, how fast it will be rendered, used with collision detection etc.

      @italic(Notes for descendants implementors:)

      For coordinate-based nodes (when @link(Coord) returns @true),
      VerticesCount is already implemented in this class.
      Using Coord method, no other information is needed.

      For other nodes, the default implementation of
      both VerticesCount and TrianglesCount in this TVRMLGeometryNode
      class will use ProxyGeometry and ProxyState to do the work.
      You should override these methods if @link(Proxy) is not available
      (so caller will always pass ProxyGeometry = @nil)
      or some faster approach is possible.

      @groupBegin }
    function VerticesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode;
      ProxyState: TVRMLGraphTraverseState): Cardinal; virtual;
    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode;
      ProxyState: TVRMLGraphTraverseState): Cardinal; virtual;
    { @groupEnd }

    { Triangulate node, calling NewTriangleProc for each triangle this node
      defines. NewTriangleProc will be called with (Triangle, Shape, State, ...) where
      Triangle will be the new triangle, and Shape and State
      are parameters passed here.

      The difference between LocalTriangulate and Triangulate is just like
      between LocalBoundingBox and BoundingBox: "local" version ignored
      transformation (stored in State.Transform), while Triangulate not.

      Jezeli OverTriangulate = false to [Local]Triangulate generuje tylko tyle
      trojkatow zeby doskonale odzwierciedlac ksztalt node'a. W przypadku
      gdy nie jest to mozliwe (np. przy kulach, stozkach itp.)
      [Local]Triangulate uzywa State.KambiTriangulation
      aby zdecydowac sie jak dobre chcemy miec przyblizenie oryginalu.

      Jezeli OverTriangulate = true to [Local]Triangulate moze wygenerowac
      wiecej trojkatow --- w przypadku duzych powierzchni moze zdecydowac sie
      zeby je rozbic na wiecej malych trojkatow niz jest to rzeczywiscie
      potrzebne aby wyrazic te powierzchnie jako zbior trojkatow.
      Np. node Cube (szescianik) mozna wyrazic doskonale dokladnie jako
      12 trojkatow i to wlasnie zrobimy gdy OverTriangulate = false.
      ALE gdy OverTriangulate = true my rozbijemy kazda sciane szescianu
      na WIECEJ trojkatow, zgodnie z parametrem State.
      KambiTriangulation .RectDivisions.
      Do czego to sie moze przydac ? Gdy uzywasz cieniowania Gourauda (albo
      jeszcze gorzej, cieniowania plaskiego) jedynym remedium zeby renderowac
      rozblyski na srodku duzych powierzchni jest wlasnie rozbijac te powierzchnie
      na duzo trojkatow.

      @italic(Notes for descendants implementors:)

      Default implementation of LocalTriangulate in this class uses
      ProxyGeometry and ProxyState, if ProxyGeometry is non-nil.
      You have to override this if @link(Proxy) is not available
      (so ProxyGeometry will always be @nil), or if you want to plug
      some more optimal method.

      Triangulate is always implemented by simply calling LocalTriangulate
      and transforming each triangle.

      @groupBegin }
    procedure Triangulate(Shape: TObject; State: TVRMLGraphTraverseState;
      OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState);
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState;
      OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); virtual;
    { @groupEnd }

    { Return node's list of coordinates. Returns @false if node is
      not based on coordinates. Returns @true and sets ACoord
      if the node is based on coordinates. Even when returns @true,
      it can set ACoord = @nil, which means that node is based on
      coordinates but they are empty right now (so for example
      bounding box may be considered empty).

      In base TVRMLGeometryNode class this always returns @false.

      Override this for descendants that have some kind of "coord" field,
      then this should return @true and set ACoord to coord.point field,
      assuming that coord is set and specifies Coordinate node.
      Otherwise should return @true and set ACoord = @nil.

      For VRML 1.0, coord may be taken from State, that's why we have to
      pass current traverse state here. }
    function Coord(State: TVRMLGraphTraverseState;
      out ACoord: TMFVec3f): boolean; virtual;

    { Return node's list of coordinates, raising exception if node
      is not based on coordinates.

      This is just like the @link(Coord) method,
      except it simply returns the coordinates, not the boolean result.
      If virtual @link(Coord) returns @false (indicating the node
      is not coordinate-based) this raises ENotCoordinateBasedNode.

      @raises(ENotCoordinateBasedNode If node is not coordinate-based,
        that is @link(Coord) returns false.)
    }
    function Coordinates(State: TVRMLGraphTraverseState): TMFVec3f;

    { Node's list of coordinate indexes.

      In base TVRMLGeometryNode class this always returns @nil.

      Override this for descendants that have some kind of "coordIndex"
      or "index" field used to index @link(Coord) array. }
    function CoordIndex: TMFLong; virtual;

    { Returns an information how to split @link(Coord) array into ranges.

      When CoordIndex = @nil, then if the node's @link(Coord) array
      can be divided into some "ranges", we will use this information.
      This is used (and should be overridden) for X3D non-indexed nodes,
      like fanCount or stripCount or vertexCount.

      What precisely is a "range of coordinates" is not specified
      here. It may be a line stip, or one triangle strip, etc. ---
      depending on the descendant.

      Returns @true if this is available. In this case, RangeCount must
      be set to something <> nil, and the rest of returned variables
      are mainly to generate proper warnings by MakeCoordRanges. }
    function CoordRangesCounts(out RangeCount: TDynLongIntArray;
      out SRanges, SRangeName: string;
      out RangeMinimumCount: Cardinal): boolean; virtual;

    { Splits @link(Coord) array into ranges.

      If CoordIndex is assigned, then a "range of coordinates" is
      just a range of non-negative indexes within CoordIndex.
      Otherwise (when CoordIndex = @nil), CoordRangesCounts must
      return @true and we will use RangeCount to split coordinates.

      Call this only for nodes with coordinates, that is only when
      @link(Coord) returns @true. }
    procedure MakeCoordRanges(
      State: TVRMLGraphTraverseState;
      CoordRangeHandler: TCoordRangeHandler);

    { Splits coordinate-based node into polygons.
      The idea is that this can be usable for both NormalsCalculator
      (used by the renderer) and implementation of LocalTriangulate
      (and so Triangulate) methods.

      Indexes in PolygonHandler point to CoordIndex, if assigned,
      or directly to Coord. The ordering of generated polygons is correct,
      so what pointed CCW in the node field, will still point CCW
      according to generated PolygonHandler indexes.

      In this class this does nothing. Some, but not all, coordinate-based
      nodes (the ones when @link(Coord) returns @true) override this.
      So currently, whether this is implemented is coordinated with
      NormalsCalculator and LocalTriangulate internal needs. }
    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); virtual;

    { Node's texture coordinates. Returns @false if node
      cannot have texture coordinates.

      Returns @true and sets ATexCoord to a node defining texture coords.
      ATexCoord may be set to TNodeX3DTextureCoordinateNode descendant or
      to TNodeTextureCoordinate2 (latter one only for VRML <= 1.0).
      ATexCoord can also be set to @nil in this case, which means that
      this node has a field for texCoord, but it's empty right now.

      In base TVRMLGeometryNode class this looks at TexCoordField,
      eventually returns @false. }
    function TexCoord(State: TVRMLGraphTraverseState;
      out ATexCoord: TVRMLNode): boolean; virtual;

    { Node's texCoord field, or @nil if not available.
      Various nodes may have different exact rules about what is
      allowed here, but everything allows TextureCoordinateGenerator
      and ProjectedTextureCoordinate instances.

      This gives you more possibilities than the @link(TexCoord) method
      (as you can assign texCoord using this), however it may be not available
      in all cases --- for example VRML 1.0 nodes do not have texCoord field,
      but they may have a texture coordinate node (from the state). }
    function TexCoordField: TSFNode; virtual;

    { Converts this node to another node class that may be better supported.

      Typically, converts some complex geometry node (like
      Extrusion or Teapot) into more common node like IndexedFaceSet
      or IndexedTriangleSet. TVRMLShape class wraps this method into
      a more comfortable interface, that is TVRMLShape methods
      simply automatically convert geometry nodes to their proxy versions
      if needed.

      In the base TVRMLGeometryNode class, returns @nil indicating
      that no conversion is known.

      When returns non-nil, result's NodeName must be equal
      to our NodeName.

      Some Proxy implementations (especially for VRML 1.0) will have
      to create new State (TVRMLGraphTraverseState) instance along
      with a new geometry node. You should do this by copying the State
      into a new TVRMLGraphTraverseState instance, and modyfying
      the State reference. Simply speaking, do

      @longcode(#
  State := TVRMLGraphTraverseState.CreateCopy(State);)
#)

      You should @italic(not) just modify the fields
      of the provided State instance. (Reasoning: some proxy methods
      rely on getting the original State, e.g. with original MaterialBinding,
      not the transformed state, to work correctly. And some proxy methods
      need to modify the state differently, depending on OverTriangulate
      value.)

      You can modify State variable only when returning non-nil geometry. }
    function Proxy(var State: TVRMLGraphTraverseState;
      const OverTriangulate: boolean): TVRMLGeometryNode; virtual;

    { Does the @link(Proxy) method look at the OverTriangulate parameter
      at all. Default implementation in TVRMLGeometryNode returns safer @true.
      Descendants may override and return @false, to allow
      e.g. more caching in TVRMLShape. }
    function ProxyUsesOverTriangulate: boolean; virtual;

    { Returns color.point field, assuming that "color" field is set and
      specifies Color (or ColorRGBA) node. Otherwise returns @nil.

      Note that only one of Color and ColorRGBA may return non-nil,
      since "color" field may contain only one of them.

      @groupBegin }
    function Color: TMFVec3f; virtual;
    function ColorRGBA: TMFColorRGBA; virtual;
    { @groupEnd }

    { Should renderer automatically generate 3D texture coordinates,
      in case we will apply 3D texture on this geometry.

      The generated coordinates will follow the X3D specification
      at "Texturing3D" component: "Texture coordinate generation
      for primitive objects". The 3D texture space will be mapped nicely
      to the shape bounding box.

      Implementation in this class (TVRMLGeometryNode) returns always
      @false. Override it for primitives that have no texture coordinates
      to return @true. }
    function AutoGenerate3DTexCoords: boolean; virtual;

    function TransformationChange: TNodeTransformationChange; override;
  end;

  { }
  TNodeX3DGeometricPropertyNode = class(TNodeX3DNode)
  end;

  TNodeX3DGeometryNode = class(TVRMLGeometryNode)
  end;

  TNodeX3DColorNode = class(TNodeX3DGeometricPropertyNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
  end;

  TNodeX3DComposedGeometryNode = class(TNodeX3DGeometryNode)
  protected
    procedure DirectEnumerateActive(
      Func: TEnumerateChildrenFunction); override;
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;

    private FFdattrib: TMFNode;
    public property Fdattrib: TMFNode read FFdattrib;

    private FFdcolor: TSFNode;
    public property Fdcolor: TSFNode read FFdcolor;

    private FFdcoord: TSFNode;
    public property Fdcoord: TSFNode read FFdcoord;

    private FFdfogCoord: TSFNode;
    public property FdfogCoord: TSFNode read FFdfogCoord;

    private FFdnormal: TSFNode;
    public property Fdnormal: TSFNode read FFdnormal;

    private FFdtexCoord: TSFNode;
    public property FdtexCoord: TSFNode read FFdtexCoord;

    private FFdccw: TSFBool;
    public property Fdccw: TSFBool read FFdccw;

    private FFdcolorPerVertex: TSFBool;
    public property FdcolorPerVertex: TSFBool read FFdcolorPerVertex;

    private FFdnormalPerVertex: TSFBool;
    public property FdnormalPerVertex: TSFBool read FFdnormalPerVertex;

    private FFdsolid: TSFBool;
    public property Fdsolid: TSFBool read FFdsolid;

    private FFdRadianceTransfer: TMFVec3f;
    public property FdRadianceTransfer: TMFVec3f read FFdRadianceTransfer;

    function Coord(State: TVRMLGraphTraverseState;
      out ACoord: TMFVec3f): boolean; override;

    function TexCoordField: TSFNode; override;

    function Color: TMFVec3f; override;
    function ColorRGBA: TMFColorRGBA; override;

    { Returns normal.vector, assuming that "normal" field is set
      and specified Normal node. Otherwise returns @nil. }
    function Normal: TMFVec3f;

    { Returns normal.vector, assuming that "normal" field is set
      and specified Normal node, as TDynVector3Single. Otherwise returns @nil. }
    function NormalItems: TDynVector3SingleArray;
  end;

  TNodeX3DCoordinateNode = class(TNodeX3DGeometricPropertyNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;

    { Count of coordinates within. }
    function CoordCount: Cardinal; virtual; abstract;
  end;

  TNodeX3DNormalNode = class(TNodeX3DGeometricPropertyNode)
  end;

  TNodeClipPlane = class(TNodeX3DChildNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdenabled: TSFBool;
    public property Fdenabled: TSFBool read FFdenabled;

    private FFdplane: TSFVec4f;
    public property Fdplane: TSFVec4f read FFdplane;
  end;

  TNodeColor = class(TNodeX3DColorNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdcolor: TMFColor;
    public property Fdcolor: TMFColor read FFdcolor;
  end;

  TNodeColorRGBA = class(TNodeX3DColorNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdcolor: TMFColorRGBA;
    public property Fdcolor: TMFColorRGBA read FFdcolor;
  end;

  TNodeCoordinate = class(TNodeX3DCoordinateNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdpoint: TMFVec3f;
    public property Fdpoint: TMFVec3f read FFdpoint;

    function CoordCount: Cardinal; override;
  end;

  TNodeIndexedLineSet_2 = class(TNodeX3DGeometryNode)
  private
    procedure EventSet_ColorIndexReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
    procedure EventSet_CoordIndexReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    { Event: MFInt32, in } { }
    private FEventset_colorIndex: TVRMLEvent;
    public property Eventset_colorIndex: TVRMLEvent read FEventset_colorIndex;

    { Event: MFInt32, in } { }
    private FEventset_coordIndex: TVRMLEvent;
    public property Eventset_coordIndex: TVRMLEvent read FEventset_coordIndex;

    private FFdattrib: TMFNode;
    public property Fdattrib: TMFNode read FFdattrib;

    private FFdcolor: TSFNode;
    public property Fdcolor: TSFNode read FFdcolor;

    private FFdcoord: TSFNode;
    public property Fdcoord: TSFNode read FFdcoord;

    private FFdfogCoord: TSFNode;
    public property FdfogCoord: TSFNode read FFdfogCoord;

    private FFdcolorIndex: TMFInt32;
    public property FdcolorIndex: TMFInt32 read FFdcolorIndex;

    private FFdcolorPerVertex: TSFBool;
    public property FdcolorPerVertex: TSFBool read FFdcolorPerVertex;

    private FFdcoordIndex: TMFInt32;
    public property FdcoordIndex: TMFInt32 read FFdcoordIndex;

    class function ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
      override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;

    function Coord(State: TVRMLGraphTraverseState;
      out ACoord: TMFVec3f): boolean; override;
    function CoordIndex: TMFLong; override;

    function Color: TMFVec3f; override;
    function ColorRGBA: TMFColorRGBA; override;
  end;

  TNodeIndexedTriangleFanSet = class(TNodeX3DComposedGeometryNode)
  private
    procedure EventSet_IndexReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    { Event: MFInt32, in } { }
    private FEventset_index: TVRMLEvent;
    public property Eventset_index: TVRMLEvent read FEventset_index;

    private FFdindex: TMFInt32;
    public property Fdindex: TMFInt32 read FFdindex;

    function CoordIndex: TMFLong; override;

    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;

  TNodeIndexedTriangleSet = class(TNodeX3DComposedGeometryNode)
  private
    procedure EventSet_IndexReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    { Event: MFInt32, in } { }
    private FEventset_index: TVRMLEvent;
    public property Eventset_index: TVRMLEvent read FEventset_index;

    private FFdindex: TMFInt32;
    public property Fdindex: TMFInt32 read FFdindex;

    function CoordIndex: TMFLong; override;

    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;

  TNodeIndexedTriangleStripSet = class(TNodeX3DComposedGeometryNode)
  private
    procedure EventSet_IndexReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    { Event: MFInt32, in } { }
    private FEventset_index: TVRMLEvent;
    public property Eventset_index: TVRMLEvent read FEventset_index;

    private FFdindex: TMFInt32;
    public property Fdindex: TMFInt32 read FFdindex;

    function CoordIndex: TMFLong; override;

    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;

  TNodeLineSet = class(TNodeX3DGeometryNode)
  protected
    procedure DirectEnumerateActive(
      Func: TEnumerateChildrenFunction); override;
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdattrib: TMFNode;
    public property Fdattrib: TMFNode read FFdattrib;

    private FFdcolor: TSFNode;
    public property Fdcolor: TSFNode read FFdcolor;

    private FFdcoord: TSFNode;
    public property Fdcoord: TSFNode read FFdcoord;

    private FFdfogCoord: TSFNode;
    public property FdfogCoord: TSFNode read FFdfogCoord;

    private FFdvertexCount: TMFInt32;
    public property FdvertexCount: TMFInt32 read FFdvertexCount;

    function Coord(State: TVRMLGraphTraverseState;
      out ACoord: TMFVec3f): boolean; override;

    function CoordRangesCounts(out RangeCount: TDynLongIntArray;
      out SRanges, SRangeName: string;
      out RangeMinimumCount: Cardinal): boolean; override;

    function Color: TMFVec3f; override;
    function ColorRGBA: TMFColorRGBA; override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;

  TNodeNormal = class(TNodeX3DNormalNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;

    { TNodeNormal, as probably the only node in the engine right now,
      doesn't suggest any VRML version. That's because it's suitable for
      all VRML versions. }
    { function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override; }

    { }
    class function URNMatching(const URN: string): boolean; override;

    private FFdvector: TMFVec3f;
    public property Fdvector: TMFVec3f read FFdvector;
  end;

  TNodePointSet_2 = class(TNodeX3DGeometryNode)
  protected
    procedure DirectEnumerateActive(
      Func: TEnumerateChildrenFunction); override;
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdattrib: TMFNode;
    public property Fdattrib: TMFNode read FFdattrib;

    private FFdcolor: TSFNode;
    public property Fdcolor: TSFNode read FFdcolor;

    private FFdcoord: TSFNode;
    public property Fdcoord: TSFNode read FFdcoord;

    private FFdfogCoord: TSFNode;
    public property FdfogCoord: TSFNode read FFdfogCoord;

    class function ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
      override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;

    function Coord(State: TVRMLGraphTraverseState;
      out ACoord: TMFVec3f): boolean; override;

    function Color: TMFVec3f; override;
    function ColorRGBA: TMFColorRGBA; override;
  end;

  TNodeTriangleFanSet = class(TNodeX3DComposedGeometryNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdfanCount: TMFInt32;
    public property FdfanCount: TMFInt32 read FFdfanCount;

    function CoordRangesCounts(out RangeCount: TDynLongIntArray;
      out SRanges, SRangeName: string;
      out RangeMinimumCount: Cardinal): boolean; override;

    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;

  TNodeTriangleSet = class(TNodeX3DComposedGeometryNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;

  TNodeTriangleStripSet = class(TNodeX3DComposedGeometryNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdstripCount: TMFInt32;
    public property FdstripCount: TMFInt32 read FFdstripCount;

    function CoordRangesCounts(out RangeCount: TDynLongIntArray;
      out SRanges, SRangeName: string;
      out RangeMinimumCount: Cardinal): boolean; override;

    procedure CoordPolygons(
      State: TVRMLGraphTraverseState;
      PolygonHandler: TIndexedPolygonHandler); override;

    function TrianglesCount(State: TVRMLGraphTraverseState; OverTriangulate: boolean;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState): Cardinal; override;
    procedure LocalTriangulate(Shape: TObject; State: TVRMLGraphTraverseState; OverTriangulate: boolean; NewTriangleProc: TNewTriangleProc;
      ProxyGeometry: TVRMLGeometryNode; ProxyState: TVRMLGraphTraverseState); override;
  end;
{$endif read_interface}

{$ifdef read_implementation}

{ TVRMLGeometryNode ---------------------------------------------------------- }

constructor TVRMLGeometryNode.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  DefaultContainerField := 'geometry';
end;

function TVRMLGeometryNode.Coord(State: TVRMLGraphTraverseState;
  out ACoord: TMFVec3f): boolean;
begin
  Result := false;
end;

function TVRMLGeometryNode.Coordinates(State: TVRMLGraphTraverseState): TMFVec3f;
begin
  if not Coord(State, Result) then
    raise ENotCoordinateBasedNode.CreateFmt('Node %s is not a coordinate-based node',
      [NodeTypeName]);
end;

function TVRMLGeometryNode.CoordIndex: TMFLong;
begin
  Result := nil;
end;

function TVRMLGeometryNode.CoordRangesCounts(
  out RangeCount: TDynLongIntArray;
  out SRanges, SRangeName: string;
  out RangeMinimumCount: Cardinal): boolean;
begin
  Result := false;
end;

procedure TVRMLGeometryNode.MakeCoordRanges(
  State: TVRMLGraphTraverseState;
  CoordRangeHandler: TCoordRangeHandler);
var
  BeginIndex, EndIndex: Integer;
  RangeNumber: Cardinal;
  RangeCount: TDynLongIntArray;
  SRanges, SRangeName: string;
  RangeMinimumCount: Cardinal;
  C: TMFVec3f;
begin
  C := Coordinates(State);

  if C = nil then
    Exit;

  if CoordIndex <> nil then
  begin
    BeginIndex := 0;
    RangeNumber := 0;
    while BeginIndex < CoordIndex.Count do
    begin
      EndIndex := BeginIndex;
      while (EndIndex < CoordIndex.Count) and
            (CoordIndex.Items.Items[EndIndex] >= 0) do
        Inc(EndIndex);
      CoordRangeHandler(RangeNumber, BeginIndex, EndIndex);
      Inc(RangeNumber);
      BeginIndex := EndIndex + 1;
    end;
  end else
  begin
    if not CoordRangesCounts(RangeCount, SRanges, SRangeName,
      RangeMinimumCount) then
      raise EInternalError.CreateFmt('%s.MakeCoordRanges: either CoordIndex or CoordRangesCounts must be defined to split coordinates', [ClassName]);
    EndIndex := 0;
    if RangeCount.Count > 0 then
      for RangeNumber := 0 to RangeCount.Count - 1 do
      begin
        BeginIndex := EndIndex;
        EndIndex := BeginIndex + RangeCount.Items[RangeNumber];
        { Note that EndIndex *may* be equal to C.Count,
          as EndIndex is not taken into account by CoordRangeHandler. }
        if EndIndex > C.Count then
        begin
          VRMLWarning(vwSerious, Format('Too much %s (not enough coordinates) in %s',
            [SRanges, NodeTypeName]));
          Break;
        end;
        if Cardinal(EndIndex - BeginIndex) >= RangeMinimumCount then
          CoordRangeHandler(RangeNumber, BeginIndex, EndIndex) else
          VRMLWarning(vwSerious, Format('%s is less than %d in %s',
            [SRangeName, RangeMinimumCount, NodeTypeName]));
      end;
  end;
end;

procedure TVRMLGeometryNode.CoordPolygons(
  State: TVRMLGraphTraverseState;
  PolygonHandler: TIndexedPolygonHandler);
begin
  { Nothing to do in this class. }
end;

function TVRMLGeometryNode.TexCoord(State: TVRMLGraphTraverseState;
  out ATexCoord: TVRMLNode): boolean;
begin
  Result := TexCoordField <> nil;
  if Result and
     (TexCoordField.Value <> nil) and
     TexCoordField.CurrentChildAllowed then
    ATexCoord := TexCoordField.Value else
    ATexCoord := nil;
end;

function TVRMLGeometryNode.TexCoordField: TSFNode;
begin
  Result := nil;
end;

function TVRMLGeometryNode.Proxy(var State: TVRMLGraphTraverseState;
  const OverTriangulate: boolean): TVRMLGeometryNode;
begin
  Result := nil;
end;

function TVRMLGeometryNode.ProxyUsesOverTriangulate: boolean;
begin
  Result := true;
end;

function TVRMLGeometryNode.Color: TMFVec3f;
begin
  Result := nil;
end;

function TVRMLGeometryNode.ColorRGBA: TMFColorRGBA;
begin
  Result := nil;
end;

function TVRMLGeometryNode.AutoGenerate3DTexCoords: boolean;
begin
  Result := false;
end;

function TVRMLGeometryNode.TransformationChange: TNodeTransformationChange;
begin
  Result := ntcGeometry;
end;

{ Normal X3D spec nodes ------------------------------------------------------ }

constructor TNodeX3DColorNode.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  DefaultContainerField := 'color';
end;

constructor TNodeX3DComposedGeometryNode.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdattrib := TMFNode.Create(Self, 'attrib', [TNodeX3DVertexAttributeNode]);
   Fdattrib.ChangesAlways := [chGeometry];
  Fields.Add(FFdattrib);

  FFdcolor := TSFNode.Create(Self, 'color', [TNodeX3DColorNode]);
   Fdcolor.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolor);

  FFdcoord := TSFNode.Create(Self, 'coord', [TNodeX3DCoordinateNode]);
   Fdcoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdcoord);

  FFdfogCoord := TSFNode.Create(Self, 'fogCoord', [TNodeFogCoordinate]);
   FdfogCoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdfogCoord);

  FFdnormal := TSFNode.Create(Self, 'normal', [TNodeX3DNormalNode]);
   Fdnormal.ChangesAlways := [chGeometry];
  Fields.Add(FFdnormal);

  FFdtexCoord := TSFNode.Create(Self, 'texCoord', [TNodeX3DTextureCoordinateNode]);
   FdtexCoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdtexCoord);

  FFdccw := TSFBool.Create(Self, 'ccw', true);
   Fdccw.Exposed := false;
   Fdccw.ChangesAlways := [chGeometry];
  Fields.Add(FFdccw);

  FFdcolorPerVertex := TSFBool.Create(Self, 'colorPerVertex', true);
   FdcolorPerVertex.Exposed := false;
   FdcolorPerVertex.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolorPerVertex);

  FFdnormalPerVertex := TSFBool.Create(Self, 'normalPerVertex', true);
   FdnormalPerVertex.Exposed := false;
   FdnormalPerVertex.ChangesAlways := [chGeometry];
  Fields.Add(FFdnormalPerVertex);

  FFdsolid := TSFBool.Create(Self, 'solid', true);
   Fdsolid.Exposed := false;
   Fdsolid.ChangesAlways := [chGeometry];
  Fields.Add(FFdsolid);

  FFdRadianceTransfer := TMFVec3f.Create(Self, 'radianceTransfer', []);
   FdRadianceTransfer.ChangesAlways := [chGeometry];
  Fields.Add(FFdRadianceTransfer);
end;

function TNodeX3DComposedGeometryNode.Coord(State: TVRMLGraphTraverseState;
  out ACoord: TMFVec3f): boolean;
begin
  Result := true;
  if (FdCoord.Value <> nil) and
     (FdCoord.Value is TNodeCoordinate) then
    ACoord := TNodeCoordinate(FdCoord.Value).FdPoint else
    ACoord := nil;
end;

function TNodeX3DComposedGeometryNode.TexCoordField: TSFNode;
begin
  Result := FdTexCoord;
end;

function TNodeX3DComposedGeometryNode.Color: TMFVec3f;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColor) then
    Result := TNodeColor(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodeX3DComposedGeometryNode.ColorRGBA: TMFColorRGBA;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColorRGBA) then
    Result := TNodeColorRGBA(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodeX3DComposedGeometryNode.Normal: TMFVec3f;
begin
  if (FdNormal.Value <> nil) and
     (FdNormal.Value is TNodeNormal) then
    Result := TNodeNormal(FdNormal.Value).FdVector else
    Result := nil;
end;

function TNodeX3DComposedGeometryNode.NormalItems: TDynVector3SingleArray;
begin
  if (FdNormal.Value <> nil) and
     (FdNormal.Value is TNodeNormal) then
    Result := TNodeNormal(FdNormal.Value).FdVector.Items else
    Result := nil;
end;

procedure TNodeX3DComposedGeometryNode.DirectEnumerateActive(
  Func: TEnumerateChildrenFunction);
begin
  Fdattrib.EnumerateValid(Func);
  Fdcolor.EnumerateValid(Func);
  Fdcoord.EnumerateValid(Func);
  FdfogCoord.EnumerateValid(Func);
  Fdnormal.EnumerateValid(Func);
  FdtexCoord.EnumerateValid(Func);
end;

constructor TNodeX3DCoordinateNode.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  DefaultContainerField := 'coord';
end;

constructor TNodeClipPlane.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdenabled := TSFBool.Create(Self, 'enabled', true);
   Fdenabled.ChangesAlways := [chClipPlane];
  Fields.Add(FFdenabled);

  FFdplane := TSFVec4f.Create(Self, 'plane', Vector4Single(0, 1, 0, 0));
   Fdplane.ChangesAlways := [chClipPlane];
  Fields.Add(FFdplane);
  { X3D specification comment: [0,1] }

  { X3D specification (XML encoding, edition 2)
    says that containerField of this should be "color"... which doesn't
    make sense? I leave DefaultContainerField as "children"
    (inherited from X3DChilNode. }
end;

class function TNodeClipPlane.ClassNodeTypeName: string;
begin
  Result := 'ClipPlane';
end;

function TNodeClipPlane.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeClipPlane.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

constructor TNodeColor.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdcolor := TMFColor.Create(Self, 'color', []);
   Fdcolor.ChangesAlways := [chColorNode];
  Fields.Add(FFdcolor);
  { X3D specification comment: [0,1] }
end;

class function TNodeColor.ClassNodeTypeName: string;
begin
  Result := 'Color';
end;

function TNodeColor.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeColor.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

constructor TNodeColorRGBA.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdcolor := TMFColorRGBA.Create(Self, 'color', []);
   Fdcolor.ChangesAlways := [chColorNode];
  Fields.Add(FFdcolor);
  { X3D specification comment: [0,1] }
end;

class function TNodeColorRGBA.ClassNodeTypeName: string;
begin
  Result := 'ColorRGBA';
end;

function TNodeColorRGBA.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeColorRGBA.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

constructor TNodeCoordinate.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdpoint := TMFVec3f.Create(Self, 'point', []);
   Fdpoint.ChangesAlways := [chCoordinate];
  Fields.Add(FFdpoint);
  { X3D specification comment: (-Inf,Inf) }
end;

class function TNodeCoordinate.ClassNodeTypeName: string;
begin
  Result := 'Coordinate';
end;

function TNodeCoordinate.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeCoordinate.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeCoordinate.CoordCount: Cardinal;
begin
  Result := FdPoint.Items.Count;
end;

constructor TNodeIndexedLineSet_2.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FEventset_colorIndex := TVRMLEvent.Create(Self, 'set_colorIndex', TMFInt32, true);
  Events.Add(FEventset_colorIndex);
  Eventset_colorIndex.OnReceive.Add(@EventSet_ColorIndexReceive);

  FEventset_coordIndex := TVRMLEvent.Create(Self, 'set_coordIndex', TMFInt32, true);
  Events.Add(FEventset_coordIndex);
  Eventset_coordIndex.OnReceive.Add(@EventSet_CoordIndexReceive);

  FFdattrib := TMFNode.Create(Self, 'attrib', [TNodeX3DVertexAttributeNode]);
   Fdattrib.ChangesAlways := [chGeometry];
  Fields.Add(FFdattrib);

  FFdcolor := TSFNode.Create(Self, 'color', [TNodeX3DColorNode]);
   Fdcolor.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolor);

  FFdcoord := TSFNode.Create(Self, 'coord', [TNodeX3DCoordinateNode]);
   Fdcoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdcoord);

  FFdfogCoord := TSFNode.Create(Self, 'fogCoord', [TNodeFogCoordinate]);
   FdfogCoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdfogCoord);

  FFdcolorIndex := TMFInt32.Create(Self, 'colorIndex', []);
   FdcolorIndex.Exposed := false;
   FdcolorIndex.SaveToStreamLineUptoNegative := true;
   FdcolorIndex.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolorIndex);
  { X3D specification comment: [0,Inf) or -1 }

  FFdcolorPerVertex := TSFBool.Create(Self, 'colorPerVertex', true);
   FdcolorPerVertex.Exposed := false;
   FdcolorPerVertex.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolorPerVertex);

  FFdcoordIndex := TMFInt32.Create(Self, 'coordIndex', []);
   FdcoordIndex.Exposed := false;
   FdcoordIndex.SaveToStreamLineUptoNegative := true;
   FdcoordIndex.ChangesAlways := [chGeometry];
  Fields.Add(FFdcoordIndex);
  { X3D specification comment: [0,Inf) or -1 }
end;

class function TNodeIndexedLineSet_2.ClassNodeTypeName: string;
begin
  Result := 'IndexedLineSet';
end;

function TNodeIndexedLineSet_2.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeIndexedLineSet_2.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

class function TNodeIndexedLineSet_2.ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
begin
  Result := VerMajor >= 2;
end;

function TNodeIndexedLineSet_2.Coord(State: TVRMLGraphTraverseState;
  out ACoord: TMFVec3f): boolean;
begin
  Result := true;
  if (FdCoord.Value <> nil) and
     (FdCoord.Value is TNodeCoordinate) then
    ACoord := TNodeCoordinate(FdCoord.Value).FdPoint else
    ACoord := nil;
end;

function TNodeIndexedLineSet_2.Color: TMFVec3f;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColor) then
    Result := TNodeColor(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodeIndexedLineSet_2.ColorRGBA: TMFColorRGBA;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColorRGBA) then
    Result := TNodeColorRGBA(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodeIndexedLineSet_2.CoordIndex: TMFLong;
begin
  Result := FdCoordIndex;
end;

procedure TNodeIndexedLineSet_2.EventSet_ColorIndexReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  FdColorIndex.Assign(Value);
  if EventsEngine <> nil then
    EventsEngine.ChangedField(FdColorIndex);
end;

procedure TNodeIndexedLineSet_2.EventSet_CoordIndexReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  FdCoordIndex.Assign(Value);
  if EventsEngine <> nil then
    EventsEngine.ChangedField(FdCoordIndex);
end;

constructor TNodeIndexedTriangleFanSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FEventset_index := TVRMLEvent.Create(Self, 'set_index', TMFInt32, true);
  Events.Add(FEventset_index);
  Eventset_index.OnReceive.Add(@EventSet_IndexReceive);

  FFdindex := TMFInt32.Create(Self, 'index', []);
   Fdindex.Exposed := false;
   Fdindex.ChangesAlways := [chGeometry];
  Fields.Add(FFdindex);
  { X3D specification comment: [0,Inf) or -1 }
end;

class function TNodeIndexedTriangleFanSet.ClassNodeTypeName: string;
begin
  Result := 'IndexedTriangleFanSet';
end;

function TNodeIndexedTriangleFanSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeIndexedTriangleFanSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeIndexedTriangleFanSet.CoordIndex: TMFLong;
begin
  Result := FdIndex;
end;

procedure TNodeIndexedTriangleFanSet.EventSet_IndexReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  FdIndex.Assign(Value);
  if EventsEngine <> nil then
    EventsEngine.ChangedField(FdIndex);
end;

constructor TNodeIndexedTriangleSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FEventset_index := TVRMLEvent.Create(Self, 'set_index', TMFInt32, true);
  Events.Add(FEventset_index);
  Eventset_index.OnReceive.Add(@EventSet_IndexReceive);

  FFdindex := TMFInt32.Create(Self, 'index', []);
   Fdindex.Exposed := false;
   Fdindex.ChangesAlways := [chGeometry];
  Fields.Add(FFdindex);
  { X3D specification comment: [0,Inf) }
end;

class function TNodeIndexedTriangleSet.ClassNodeTypeName: string;
begin
  Result := 'IndexedTriangleSet';
end;

function TNodeIndexedTriangleSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeIndexedTriangleSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeIndexedTriangleSet.CoordIndex: TMFLong;
begin
  Result := FdIndex;
end;

procedure TNodeIndexedTriangleSet.EventSet_IndexReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  FdIndex.Assign(Value);
  if EventsEngine <> nil then
    EventsEngine.ChangedField(FdIndex);
end;

constructor TNodeIndexedTriangleStripSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FEventset_index := TVRMLEvent.Create(Self, 'set_index', TMFInt32, true);
  Events.Add(FEventset_index);
  Eventset_index.OnReceive.Add(@EventSet_IndexReceive);

  FFdindex := TMFInt32.Create(Self, 'index', []);
   Fdindex.Exposed := false;
   Fdindex.ChangesAlways := [chGeometry];
  Fields.Add(FFdindex);
  { X3D specification comment: [0,Inf) or -1 }
end;

class function TNodeIndexedTriangleStripSet.ClassNodeTypeName: string;
begin
  Result := 'IndexedTriangleStripSet';
end;

function TNodeIndexedTriangleStripSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeIndexedTriangleStripSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeIndexedTriangleStripSet.CoordIndex: TMFLong;
begin
  Result := FdIndex;
end;

procedure TNodeIndexedTriangleStripSet.EventSet_IndexReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  FdIndex.Assign(Value);
  if EventsEngine <> nil then
    EventsEngine.ChangedField(FdIndex);
end;

constructor TNodeLineSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdattrib := TMFNode.Create(Self, 'attrib', [TNodeX3DVertexAttributeNode]);
   Fdattrib.ChangesAlways := [chGeometry];
  Fields.Add(FFdattrib);

  FFdcolor := TSFNode.Create(Self, 'color', [TNodeX3DColorNode]);
   Fdcolor.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolor);

  FFdcoord := TSFNode.Create(Self, 'coord', [TNodeX3DCoordinateNode]);
   Fdcoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdcoord);

  FFdfogCoord := TSFNode.Create(Self, 'fogCoord', [TNodeFogCoordinate]);
   FdfogCoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdfogCoord);

  FFdvertexCount := TMFInt32.Create(Self, 'vertexCount', []);
   FdvertexCount.ChangesAlways := [chGeometry];
  Fields.Add(FFdvertexCount);
  { X3D specification comment: [2,Inf) }
end;

class function TNodeLineSet.ClassNodeTypeName: string;
begin
  Result := 'LineSet';
end;

function TNodeLineSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeLineSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeLineSet.Coord(State: TVRMLGraphTraverseState;
  out ACoord: TMFVec3f): boolean;
begin
  Result := true;
  if (FdCoord.Value <> nil) and
     (FdCoord.Value is TNodeCoordinate) then
    ACoord := TNodeCoordinate(FdCoord.Value).FdPoint else
    ACoord := nil;
end;

function TNodeLineSet.Color: TMFVec3f;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColor) then
    Result := TNodeColor(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodeLineSet.ColorRGBA: TMFColorRGBA;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColorRGBA) then
    Result := TNodeColorRGBA(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodeLineSet.CoordRangesCounts(
  out RangeCount: TDynLongIntArray;
  out SRanges, SRangeName: string;
  out RangeMinimumCount: Cardinal): boolean;
begin
  RangeCount := FdVertexCount.Items;
  SRanges := 'lines';
  SRangeName := 'Vertex count';
  RangeMinimumCount := 2;
  Result := true;
end;

procedure TNodeLineSet.DirectEnumerateActive(
  Func: TEnumerateChildrenFunction);
begin
  Fdattrib.EnumerateValid(Func);
  Fdcolor.EnumerateValid(Func);
  Fdcoord.EnumerateValid(Func);
  FdfogCoord.EnumerateValid(Func);
end;

constructor TNodeNormal.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdvector := TMFVec3f.Create(Self, 'vector', []);
   Fdvector.ChangesAlways := [chVisibleVRML1State];
  Fields.Add(FFdvector);
  { X3D specification comment: [-1,1] }

  DefaultContainerField := 'normal';
end;

class function TNodeNormal.ClassNodeTypeName: string;
begin
  Result := 'Normal';
end;

class function TNodeNormal.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

constructor TNodePointSet_2.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdattrib := TMFNode.Create(Self, 'attrib', [TNodeX3DVertexAttributeNode]);
   Fdattrib.ChangesAlways := [chGeometry];
  Fields.Add(FFdattrib);

  FFdcolor := TSFNode.Create(Self, 'color', [TNodeX3DColorNode]);
   Fdcolor.ChangesAlways := [chGeometry];
  Fields.Add(FFdcolor);

  FFdcoord := TSFNode.Create(Self, 'coord', [TNodeX3DCoordinateNode]);
   Fdcoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdcoord);

  FFdfogCoord := TSFNode.Create(Self, 'fogCoord', [TNodeFogCoordinate]);
   FdfogCoord.ChangesAlways := [chGeometry];
  Fields.Add(FFdfogCoord);
end;

class function TNodePointSet_2.ClassNodeTypeName: string;
begin
  Result := 'PointSet';
end;

function TNodePointSet_2.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodePointSet_2.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

class function TNodePointSet_2.ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
begin
  Result := VerMajor >= 2;
end;

function TNodePointSet_2.Coord(State: TVRMLGraphTraverseState;
  out ACoord: TMFVec3f): boolean;
begin
  Result := true;
  if (FdCoord.Value <> nil) and
     (FdCoord.Value is TNodeCoordinate) then
    ACoord := TNodeCoordinate(FdCoord.Value).FdPoint else
    ACoord := nil;
end;

function TNodePointSet_2.Color: TMFVec3f;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColor) then
    Result := TNodeColor(FdColor.Value).FdColor else
    Result := nil;
end;

function TNodePointSet_2.ColorRGBA: TMFColorRGBA;
begin
  if (FdColor.Value <> nil) and
     (FdColor.Value is TNodeColorRGBA) then
    Result := TNodeColorRGBA(FdColor.Value).FdColor else
    Result := nil;
end;

procedure TNodePointSet_2.DirectEnumerateActive(
  Func: TEnumerateChildrenFunction);
begin
  Fdattrib.EnumerateValid(Func);
  Fdcolor.EnumerateValid(Func);
  Fdcoord.EnumerateValid(Func);
  FdfogCoord.EnumerateValid(Func);
end;

constructor TNodeTriangleFanSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdfanCount := TMFInt32.Create(Self, 'fanCount', []);
   FdfanCount.ChangesAlways := [chGeometry];
  Fields.Add(FFdfanCount);
  { X3D specification comment: [3,Inf) }
end;

class function TNodeTriangleFanSet.ClassNodeTypeName: string;
begin
  Result := 'TriangleFanSet';
end;

function TNodeTriangleFanSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeTriangleFanSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeTriangleFanSet.CoordRangesCounts(
  out RangeCount: TDynLongIntArray;
  out SRanges, SRangeName: string;
  out RangeMinimumCount: Cardinal): boolean;
begin
  RangeCount := FdFanCount.Items;
  SRanges := 'fans';
  SRangeName := 'Fan count';
  RangeMinimumCount := 3;
  Result := true;
end;

constructor TNodeTriangleSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;
end;

class function TNodeTriangleSet.ClassNodeTypeName: string;
begin
  Result := 'TriangleSet';
end;

function TNodeTriangleSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeTriangleSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

constructor TNodeTriangleStripSet.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdstripCount := TMFInt32.Create(Self, 'stripCount', []);
   FdstripCount.ChangesAlways := [chGeometry];
  Fields.Add(FFdstripCount);
  { X3D specification comment: [3,Inf) }
end;

class function TNodeTriangleStripSet.ClassNodeTypeName: string;
begin
  Result := 'TriangleStripSet';
end;

function TNodeTriangleStripSet.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeTriangleStripSet.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeTriangleStripSet.CoordRangesCounts(
  out RangeCount: TDynLongIntArray;
  out SRanges, SRangeName: string;
  out RangeMinimumCount: Cardinal): boolean;
begin
  RangeCount := FdStripCount.Items;
  SRanges := 'strips';
  SRangeName := 'Strip count';
  RangeMinimumCount := 3;
  Result := true;
end;

procedure RegisterRenderingNodes;
begin
  NodesManager.RegisterNodeClasses([
    TNodeClipPlane,
    TNodeColor,
    TNodeColorRGBA,
    TNodeCoordinate,
    TNodeIndexedLineSet_2,
    TNodeIndexedTriangleFanSet,
    TNodeIndexedTriangleSet,
    TNodeIndexedTriangleStripSet,
    TNodeLineSet,
    TNodeNormal,
    TNodePointSet_2,
    TNodeTriangleFanSet,
    TNodeTriangleSet,
    TNodeTriangleStripSet
  ]);
end;

{$endif read_implementation}
