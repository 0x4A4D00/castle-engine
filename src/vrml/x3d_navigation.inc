{
  Copyright 2002-2010 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{$ifdef read_interface}
  { }
  TProjectionType = (ptOrthographic, ptPerspective);

  { A common class for both VRML 1.0 camera nodes and VRML >= 2.0 viewpoints
    nodes. }
  TVRMLViewpointNode = class(TNodeX3DBindableNode)
  private
    procedure EventSet_BindReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    function TransformationChange: TNodeTransformationChange; override;

    private FFdOrientation: TSFRotation;
    public property FdOrientation: TSFRotation read FFdOrientation;

    private FFdDirection: TMFVec3f;
    public property FdDirection: TMFVec3f read FFdDirection;

    private FFdUp: TMFVec3f;
    public property FdUp: TMFVec3f read FFdUp;

    private FFdGravityUp: TSFVec3f;
    public property FdGravityUp: TSFVec3f read FFdGravityUp;

    private FEventCameraMatrix: TVRMLEvent;
    public property EventCameraMatrix: TVRMLEvent read FEventCameraMatrix;

    private FEventCameraInverseMatrix: TVRMLEvent;
    public property EventCameraInverseMatrix: TVRMLEvent read FEventCameraInverseMatrix;

    private FEventCameraRotationMatrix: TVRMLEvent;
    public property EventCameraRotationMatrix: TVRMLEvent read FEventCameraRotationMatrix;

    private FEventCameraRotationInverseMatrix: TVRMLEvent;
    public property EventCameraRotationInverseMatrix: TVRMLEvent read FEventCameraRotationInverseMatrix;

    private FFdcameraMatrixSendAlsoOnOffscreenRendering: TSFBool;
    public property FdcameraMatrixSendAlsoOnOffscreenRendering: TSFBool read FFdcameraMatrixSendAlsoOnOffscreenRendering;

    { Position of the viewpoint.

      This is an abstract function, not a simple FdPosition, because one of
      the descendants (TNodeX3DViewpointNode) doesn't have FdPosition field.
      For now, all non-abstract descendants (for both VRML 1.0 and VRML >= 2.0)
      override this and expose their position field correctly. }
    function Position: TSFVec3f; virtual; abstract;

    class function ProjectionType: TProjectionType; virtual; abstract;

    { Calculate camera properties in the form of 3 vectors
      (position + direction + up) based on current field values of
      this node. Following VRML spec:

@preformatted(
  CamPos = FdPosition,
  CamDir = (0, 0, -1) rotated by FdOrientation,
  CamUp = (0, 1, 0) rotated by FdOrientation,
  GravityUp = (0, 1, 0) (not rotated by FdOrientation!),

  and everything is transformed by current camera transform
  (that is stored inside TVRMLViewpointNode.Transform automatically).
)
      (you should give here the actual VRML transformation at the point in file
      where camera is defined).

      Dodajemy do tego dodatki Kambiego :
      jesli FdDirection.Length > 0 to CamDirection nie jest liczone z
      FdOrientation ale jest brane wprost z FdDirection.Items[0].
      Podobnie dla FdUp.

      Zwraca zawsze znormalizowany CamDir i CamUp i GravityUp bo:
      @orderedList(
        @item(
          zeby zmusic cie do stosowania konsekwentnej zasady wyrazonej na
          poczatku VRMLNodes i nie pisania kodu ktory w jakis sposob bylby
          uzalezniony od podawanych tu CamDir. To dlatego ze
          pola FdOrientation / FdDirection / FdUp tego wezla NIE sluza do
          podawania czegokolwiek poza kierunkami, a wiec ich dlugosc jest
          niewazna. No i stosujac FdOrientation, a wiec uzywajac standardowego
          VRMLa 1.0, nie mozna nawet podac dlugosci FdDirection/FdUp innej
          niz 1.)
        @item(
          Normalizujemy tutaj bo w implementacji tej funkcji czesto wiemy
          ze nie trzeba normalizowac, np. gdy zwracamy standardowe dir/up
          kamery obrocone o orientation to nie potrzebujemy robic zadnej
          normalizacji bo wiemy ze wynik ma dlugosc 1. W ten sytuacji byloby
          nieoptymalne gdybys musial po wywolaniu tej procedury wywolac
          NormalizeTo1st(CamDir), bo przeciez czesto w ponizszej procedurze
          wiadomo ze nie trzea normalizowac (a wiec wywolanie NormalizeTo1st
          i wywolywany w jego srodku Sqrt sa zbedne).)
      ) }
    procedure GetView(out CamPos, CamDir, CamUp, GravityUp: TVector3Single);
  end;

  TVRMLViewpointClassNode = class of TVRMLViewpointNode;

  TNodeX3DViewpointNode = class(TVRMLViewpointNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;

    private FFdcenterOfRotation: TSFVec3f;
    public property FdcenterOfRotation: TSFVec3f read FFdcenterOfRotation;

    private FFddescription: TSFString;
    public property Fddescription: TSFString read FFddescription;

    private FFdjump: TSFBool;
    public property Fdjump: TSFBool read FFdjump;

    private FFdretainUserOffsets: TSFBool;
    public property FdretainUserOffsets: TSFBool read FFdretainUserOffsets;

    { Matrices for projecting texture from this viewpoint,
      for ProjectedTextureCoordinate.
      Override ProjectionMatrix for subclasses (ModelviewMatrix
      is already correctly defined here).
      @groupBegin }
    function ProjectionMatrix: TMatrix4Single; virtual;
    function ModelviewMatrix: TMatrix4Single;
    { @groupEnd }
  end;

  TNodeBillboard = class(TNodeX3DGroupingNode, INodeTransform)
  private
    FCameraPosition, FCameraDirection, FCameraUp: TVector3Single;
    FCameraViewKnown: boolean;
  protected
    procedure DirectEnumerateActive(
      Func: TEnumerateChildrenFunction); override;
    procedure ApplyTransform(State: TVRMLGraphTraverseState); override;
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    property CameraViewKnown: boolean read FCameraViewKnown;
    property CameraPosition: TVector3Single read FCameraPosition;
    property CameraDirection: TVector3Single read FCameraDirection;
    property CameraUp: TVector3Single read FCameraUp;

    procedure CameraChanged(const APosition, ADirection, AUp: TVector3Single);

    private FFdaxisOfRotation: TSFVec3f;
    public property FdaxisOfRotation: TSFVec3f read FFdaxisOfRotation;
  end;

  TNodeCollision = class(TNodeX3DGroupingNode, INodeX3DSensorNode)
  protected
    procedure DirectEnumerateActive(
      Func: TEnumerateChildrenFunction); override;
    procedure DirectEnumerateActiveForTraverse(
      Func: TEnumerateChildrenFunction;
      StateStack: TVRMLGraphTraverseStateStack); override;
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdenabled: TSFBool;
    public property Fdenabled: TSFBool read FFdenabled;

    { Event: SFTime, out } { }
    private FEventcollideTime: TVRMLEvent;
    public property EventcollideTime: TVRMLEvent read FEventcollideTime;

    { Event: SFBool, out } { }
    private FEventisActive: TVRMLEvent;
    public property EventisActive: TVRMLEvent read FEventisActive;

    private FFdproxy: TSFNode;
    public property Fdproxy: TSFNode read FFdproxy;
  end;

  { LOD node for VRML >= 2.0. This is not for VRML <= 1.0 LOD node.

    It's a common ancestor for VRML 2.0 LOD (TNodeLOD_2) and X3D LOD (TNodeLOD_3).
    Unfortunately, we cannot have a simple common class for both VRML 97
    and X3D because there would be a name clash for "level_changed" event:

    @unorderedList(
      @item(
        For VRML 2.0, main MFNode field was named "level" and so "level_changed"
        is an event reporting when MFNode changed.)

      @item(For X3D, main MFNode field is named "children", and so "children_changed"
        reports MFNode changes. "level_changed" is a new field, SFInt32,
        indicating which child is chosen.)
    )

    So level_changed has completely different meanings for VRML 97 and X3D.
    As an extension we'll add "levelIndex_changed", SFInt32, to be analogous
    to X3D "level_changed". This way both VRML 2.0 and X3D LOD nodes have
    the same capabilities, and common interface for programmer
    (programmer should use X3D event/fields names for Pascal property names),
    but for parser they will use different names.
  }
  TVRMLLODNode = class(TNodeX3DGroupingNode)
  protected
    procedure DirectEnumerateActive(
      Func: TEnumerateChildrenFunction); override;
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;

    private FFdcenter: TSFVec3f;
    public property Fdcenter: TSFVec3f read FFdcenter;

    private FFdrange: TMFFloat;
    public property Fdrange: TMFFloat read FFdrange;

    private FFdforceTransitions: TSFBool;
    public property FdforceTransitions: TSFBool read FFdforceTransitions;

    { Event: SFInt32, out } { }
    private FEventlevel_changed: TVRMLEvent;
    public property Eventlevel_changed: TVRMLEvent read FEventlevel_changed;

    function ChildrenField: TMFNode; override;
    function TransformationChange: TNodeTransformationChange; override;
  end;

  TNodeLOD_2 = class(TVRMLLODNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;

    class function ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
      override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;
  end;

  TNodeLOD_3 = class(TVRMLLODNode)
  public
    class function ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
      override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;
  end;

  TNodeNavigationInfo = class(TNodeX3DBindableNode)
  private
    procedure EventSet_BindReceive(
      Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdavatarSize: TMFFloat;
    public property FdavatarSize: TMFFloat read FFdavatarSize;

    private FFdheadlight: TSFBool;
    public property Fdheadlight: TSFBool read FFdheadlight;

    private FFdspeed: TSFFloat;
    public property Fdspeed: TSFFloat read FFdspeed;

    private FFdtransitionTime: TSFTime;
    public property FdtransitionTime: TSFTime read FFdtransitionTime;

    private FFdtransitionType: TMFString;
    public property FdtransitionType: TMFString read FFdtransitionType;

    private FFdtype: TMFString;
    public property Fdtype: TMFString read FFdtype;

    private FFdvisibilityLimit: TSFFloat;
    public property FdvisibilityLimit: TSFFloat read FFdvisibilityLimit;

    { Event: SFBool, out } { }
    private FEventtransitionComplete: TVRMLEvent;
    public property EventtransitionComplete: TVRMLEvent read FEventtransitionComplete;
  end;

  TNodeOrthoViewpoint = class(TNodeX3DViewpointNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdfieldOfView: TMFFloat;
    public property FdfieldOfView: TMFFloat read FFdfieldOfView;

    private FFdposition: TSFVec3f;
    public property Fdposition: TSFVec3f read FFdposition;

    function Position: TSFVec3f; override;
    class function ProjectionType: TProjectionType; override;
    function ProjectionMatrix: TMatrix4Single; override;

    { Fix given field of view value for window aspect ratio.
      The idea is that OrthoViewpoint.fieldOfView specifies the minimal
      extents. Depending on your window aspect ratio, you may need to make
      one extent (vertical or horizontal) larger to adjust. }
    class procedure AspectFieldOfView(
      var FieldOfView: TVector4Single;
      const WindowWidthToHeight: Single);
  end;

  TNodeViewpoint = class(TNodeX3DViewpointNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdfieldOfView: TSFFloat;
    public property FdfieldOfView: TSFFloat read FFdfieldOfView;

    private FFdposition: TSFVec3f;
    public property Fdposition: TSFVec3f read FFdposition;

    function Position: TSFVec3f; override;
    class function ProjectionType: TProjectionType; override;

    { This calculates proper angle of view for typical rectangular
      display, based on given fieldOfView field value.
      Result is in radians (just like fieldOfView VRML field).

      If you want to calculate horizontal angle of view then
      pass as ThisToOtherSizeRatio your window's width / height.
      If you want to calculate vertical angle of view then
      pass as ThisToOtherSizeRatio your window's height / width.
      For this method it doesn't really matter which is horizontal
      and which is vertical, both are treated the same.

      This works following VRML spec. So the angle of view for
      smaller window size is set to fieldOfViee. The other angle
      can always be calculated by AdjustViewAngleRadToAspectRatio
      (this implements the same equation that is mentioned in VRML spec).
      The larger angle cannot be larger than Pi, and may force the
      smaller angle to be smaller than fieldOfView. }
    function AngleOfView(const ThisToOtherSizeRatio: Single): Single;

    { This is like AngleOfView, but it allows you to specify
      FieldOfView as a parameter. }
    class function ViewpointAngleOfView(
      FieldOfView: Single;
      const ThisToOtherSizeRatio: Single): Single;
    function ProjectionMatrix: TMatrix4Single; override;
  end;

  TNodeViewpointGroup = class(TNodeX3DChildNode)
  public
    constructor Create(const ANodeName: string; const AWWWBasePath: string); override;
    class function ClassNodeTypeName: string; override;
    function SuggestedVRMLVersion(
      out VerMajor, VerMinor, SuggestionPriority: Integer): boolean; override;
    class function URNMatching(const URN: string): boolean; override;

    private FFdcenter: TSFVec3f;
    public property Fdcenter: TSFVec3f read FFdcenter;

    private FFdchildren: TMFNode;
    public property Fdchildren: TMFNode read FFdchildren;

    private FFddisplayed: TSFBool;
    public property Fddisplayed: TSFBool read FFddisplayed;

    private FFdsize: TSFVec3f;
    public property Fdsize: TSFVec3f read FFdsize;
  end;
{$endif read_interface}

{$ifdef read_implementation}
constructor TVRMLViewpointNode.Create(
  const ANodeName: string; const AWWWBasePath: string);
begin
  inherited;

  { In X3D, this is part of X3DViewpointNode.
    In our engine, X3DViewpointNode descends from TVRMLViewpointNode
    inheriting "orientation" field this way. }
  FFdorientation := TSFRotation.Create(Self, 'orientation', Vector3Single(0, 0, 1), 0);
   Fdorientation.ChangesAlways := [chViewpointVectors];
  Fields.Add(FFdorientation);
  { X3D specification comment: [-1,1],(-Inf,Inf) }

  FFddirection := TMFVec3f.Create(Self, 'direction', []);
   Fddirection.ChangesAlways := [chViewpointVectors];
  Fields.Add(FFddirection);

  FFdup := TMFVec3f.Create(Self, 'up', []);
   Fdup.ChangesAlways := [chViewpointVectors];
  Fields.Add(FFdup);

  FFdgravityUp := TSFVec3f.Create(Self, 'gravityUp', DefaultVRMLGravityUp);
   FdgravityUp.ChangesAlways := [chViewpointVectors];
  Fields.Add(FFdgravityUp);

  FEventCameraMatrix := TVRMLEvent.Create(Self, 'cameraMatrix', TSFMatrix4f, false);
  Events.Add(FEventCameraMatrix);

  FEventCameraInverseMatrix := TVRMLEvent.Create(Self, 'cameraInverseMatrix', TSFMatrix4f, false);
  Events.Add(FEventCameraInverseMatrix);

  FEventCameraRotationMatrix := TVRMLEvent.Create(Self, 'cameraRotationMatrix', TSFMatrix3f, false);
  Events.Add(FEventCameraRotationMatrix);

  FEventCameraRotationInverseMatrix := TVRMLEvent.Create(Self, 'cameraRotationInverseMatrix', TSFMatrix3f, false);
  Events.Add(FEventCameraRotationInverseMatrix);

  FFdcameraMatrixSendAlsoOnOffscreenRendering := TSFBool.Create(Self, 'cameraMatrixSendAlsoOnOffscreenRendering', false);
  Fields.Add(FFdcameraMatrixSendAlsoOnOffscreenRendering);

  Eventset_bind.OnReceive.Add(@EventSet_BindReceive);
end;

procedure TVRMLViewpointNode.GetView(
  out CamPos, CamDir, CamUp, GravityUp: TVector3Single);
begin
  CamPos := Position.Value;

  if FdDirection.Items.Length > 0 then
  begin
    CamDir := FdDirection.Items.Items[0];
    if ZeroVector(CamDir) then
    begin
      VRMLWarning(vwSerious, 'Viewpoint "direction" must not be zero, assuming defaults');
      CamDir := FdOrientation.RotatedPoint( DefaultVRMLCameraDirection );
    end;
  end else
    CamDir := FdOrientation.RotatedPoint( DefaultVRMLCameraDirection );

  if FdUp.Items.Length > 0 then
  begin
    CamUp := FdUp.Items.Items[0];
    if ZeroVector(CamUp) then
    begin
      VRMLWarning(vwSerious, 'Viewpoint "up" must not be zero, assuming defaults');
      CamUp := FdOrientation.RotatedPoint( DefaultVRMLCameraUp );
    end;
  end else
    CamUp := FdOrientation.RotatedPoint( DefaultVRMLCameraUp );

  GravityUp := FdGravityUp.Value;
  if ZeroVector(GravityUp) then
    GravityUp := DefaultVRMLGravityUp;

  { Niestety, macierz ponizej moze cos skalowac wiec nawet jesli powyzej
    uzylismy FdOrientation.RotatedPoint( DefaultVRMLCameraDirection/Up ) i wiemy ze CamDir/Up
    jest znormalizowane - to i tak musimy je tutaj znormalizowac.
    TODO: byloby dobrze uzyc tutaj czegos jak MatrixMultDirectionNoScale }
  CamPos    := MatrixMultPoint(Transform, CamPos);
  CamDir    := Normalized( MatrixMultDirection(Transform, CamDir) );
  CamUp     := Normalized( MatrixMultDirection(Transform, CamUp) );
  GravityUp := Normalized( MatrixMultDirection(Transform, GravityUp) );

  Assert(FloatsEqual(VectorLenSqr(CamDir), 1.0, 0.0001));
  Assert(FloatsEqual(VectorLenSqr(CamUp), 1.0, 0.0001));
end;

procedure TVRMLViewpointNode.EventSet_BindReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  if EventsEngine <> nil then
    EventsEngine.
      GetViewpointStack.Set_Bind(Self, (Value as TSFBool).Value);
end;

function TVRMLViewpointNode.TransformationChange: TNodeTransformationChange;
begin
  Result := ntcViewpoint;
end;

constructor TNodeX3DViewpointNode.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdcenterOfRotation := TSFVec3f.Create(Self, 'centerOfRotation', Vector3Single(0, 0, 0));
  Fields.Add(FFdcenterOfRotation);
  { X3D specification comment: (-Inf,Inf) }

  FFddescription := TSFString.Create(Self, 'description', '');
  Fields.Add(FFddescription);

  FFdjump := TSFBool.Create(Self, 'jump', true);
  Fields.Add(FFdjump);

  FFdretainUserOffsets := TSFBool.Create(Self, 'retainUserOffsets', false);
  Fields.Add(FFdretainUserOffsets);

  DefaultContainerField := 'children';
end;

function TNodeX3DViewpointNode.ProjectionMatrix: TMatrix4Single;
begin
  Result := IdentityMatrix4Single;
end;

function TNodeX3DViewpointNode.ModelviewMatrix: TMatrix4Single;
var
  CamPos, CamDir, CamUp, GravityUp: TVector3Single;
begin
  GetView(CamPos, CamDir, CamUp, GravityUp);
  Result := LookDirMatrix(CamPos, CamDir, CamUp);
end;

constructor TNodeBillboard.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdaxisOfRotation := TSFVec3f.Create(Self, 'axisOfRotation', Vector3Single(0, 1, 0));
  Fields.Add(FFdaxisOfRotation);
  { X3D specification comment: (-Inf,Inf) }

  DefaultContainerField := 'children';
end;

class function TNodeBillboard.ClassNodeTypeName: string;
begin
  Result := 'Billboard';
end;

function TNodeBillboard.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeBillboard.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

procedure TNodeBillboard.DirectEnumerateActive(Func: TEnumerateChildrenFunction);
var
  I: Integer;
begin
  for I := 0 to FdChildren.Count - 1 do
    Func(Self, FdChildren.Items[I]);
end;

procedure TNodeBillboard.ApplyTransform(State: TVRMLGraphTraverseState);
var
  NewX, NewZ: TVector3Single;
begin
  if CameraViewKnown then
  begin
    if PerfectlyZeroVector(FdAxisOfRotation.Value) then
    begin
      NewX := VectorProduct(FCameraDirection, FCameraUp);
      {$define NewY := FCameraUp}
      NewZ := -FCameraDirection;
      State.Transform := MatrixMult(State.Transform,
        TransformToCoordsMatrix(ZeroVector3Single, NewX, NewY, NewZ));
      State.InvertedTransform := MatrixMult(
        TransformFromCoordsMatrix(ZeroVector3Single, NewX, NewY, NewZ),
        State.InvertedTransform);
      {$undef NewY}
    end else
    begin
    end;
  end;
end;

procedure TNodeBillboard.CameraChanged(
  const APosition, ADirection, AUp: TVector3Single);
begin
  FCameraViewKnown := true;
  FCameraPosition := APosition;
  FCameraDirection := ADirection;
  FCameraUp := AUp;
end;

constructor TNodeCollision.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdenabled := TSFBool.Create(Self, 'enabled', true);
  { In VRML 2.0, Collision didn't descent from X3DSensorName and had
    special field "collide". In X3D, "enabled" is used for the exact
    same purpose. }
   Fdenabled.AddAlternativeName('collide', 2);
   Fdenabled.ChangesAlways := [chEverything];
  Fields.Add(FFdenabled);

  FEventcollideTime := TVRMLEvent.Create(Self, 'collideTime', TSFTime, false);
  Events.Add(FEventcollideTime);

  FEventisActive := TVRMLEvent.Create(Self, 'isActive', TSFBool, false);
  Events.Add(FEventisActive);

  FFdproxy := TSFNode.Create(Self, 'proxy', INodeX3DChildNode);
   Fdproxy.Exposed := false;
   Fdproxy.ChangesAlways := [chEverything];
  Fields.Add(FFdproxy);

  DefaultContainerField := 'children';
end;

class function TNodeCollision.ClassNodeTypeName: string;
begin
  Result := 'Collision';
end;

function TNodeCollision.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeCollision.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

procedure TNodeCollision.DirectEnumerateActive(Func: TEnumerateChildrenFunction);
var
  I: Integer;
begin
  FdProxy.EnumerateValid(Func);
  for I := 0 to FdChildren.Count - 1 do
    Func(Self, FdChildren.Items[I]);
end;

procedure TNodeCollision.DirectEnumerateActiveForTraverse(
  Func: TEnumerateChildrenFunction;
  StateStack: TVRMLGraphTraverseStateStack);

  procedure EnumChildren;
  var
    I: Integer;
  begin
    for I := 0 to FdChildren.Count - 1 do
      Func(Self, FdChildren.Items[I]);
  end;

begin
  if FdEnabled.Value then
  begin
    if FdProxy.Value = nil then
    begin
      { Collision node doesn't do anything in this trivial case,
        children are treated just like by Group. }
      EnumChildren;
    end else
    begin
      { This is the interesting case:
        proxy is not visible,
        children are not collidable. }

      Inc(StateStack.Top.InsideInvisible);
      try
        FdProxy.EnumerateValid(Func);
      finally Dec(StateStack.Top.InsideInvisible) end;

      Inc(StateStack.Top.InsideIgnoreCollision);
      try
        EnumChildren;
      finally Dec(StateStack.Top.InsideIgnoreCollision) end;
    end;
  end else
  begin
    { Nothing is collidable in this case. So proxy is just ignored. }
    Inc(StateStack.Top.InsideIgnoreCollision);
    try
      EnumChildren;
    finally Dec(StateStack.Top.InsideIgnoreCollision) end;
  end;
end;

constructor TVRMLLODNode.Create(const ANodeName: string; const AWWWBasePath: string);
begin
  inherited;

  FFdcenter := TSFVec3f.Create(Self, 'center', ZeroVector3Single);
   Fdcenter.Exposed := false;
   { Just redisplay, and new appropriate LOD children will be displayed. }
   Fdcenter.ChangesAlways := [chRedisplay];
  Fields.Add(FFdcenter);

  FFdrange := TMFFloat.Create(Self, 'range', []);
   Fdrange.Exposed := false;
   { Just redisplay, and new appropriate LOD children will be displayed. }
   Fdrange.ChangesAlways := [chRedisplay];
  Fields.Add(FFdrange);
  { X3D specification comment: [0,Inf) or -1 }

  FFdforceTransitions := TSFBool.Create(Self, 'forceTransitions', false);
  FFdforceTransitions.Exposed := false;
  Fields.Add(FFdforceTransitions);

  FEventlevel_changed := TVRMLEvent.Create(Self, 'level_changed', TSFInt32, false);
  Events.Add(FEventlevel_changed);

  DefaultContainerField := 'children';
end;

class function TVRMLLODNode.ClassNodeTypeName: string;
begin
  Result := 'LOD';
end;

function TVRMLLODNode.ChildrenField: TMFNode;
begin
  Result := FdChildren;
end;

procedure TVRMLLODNode.DirectEnumerateActive(Func: TEnumerateChildrenFunction);
begin
  { For now we simply always use the best LOD version,
    avoiding whole issue of choosing proper LOD child. }
  if FdChildren.Items.Count >= 1 then
    Func(Self, FdChildren.Items[0]);
end;

function TVRMLLODNode.TransformationChange: TNodeTransformationChange;
begin
  Result := ntcLOD;
end;

constructor TNodeLOD_2.Create(const ANodeName: string; const AWWWBasePath: string);
begin
  inherited;
  FdChildren.AddAlternativeName('level', 2);
  Eventlevel_changed.AddAlternativeName('levelIndex_changed', 2);
end;

class function TNodeLOD_2.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName);
end;

class function TNodeLOD_2.ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
begin
  Result := VerMajor = 2;
end;

function TNodeLOD_2.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeLOD_3.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

class function TNodeLOD_3.ForVRMLVersion(const VerMajor, VerMinor: Integer): boolean;
begin
  Result := VerMajor >= 3;
end;

function TNodeLOD_3.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 0, 1000);
end;

constructor TNodeNavigationInfo.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdavatarSize := TMFFloat.Create(Self, 'avatarSize', [0.25, 1.6, 0.75]);
   FdavatarSize.ChangesAlways := [chNavigationInfo];
  Fields.Add(FFdavatarSize);
  { X3D specification comment: [0,Inf) }

  FFdheadlight := TSFBool.Create(Self, 'headlight', true);
   Fdheadlight.ChangesAlways := [chHeadLightOn];
  Fields.Add(FFdheadlight);

  FFdspeed := TSFFloat.Create(Self, 'speed', 1.0);
   Fdspeed.ChangesAlways := [chNavigationInfo];
  Fields.Add(FFdspeed);
  { X3D specification comment: [0,Inf) }

  FFdtransitionTime := TSFTime.Create(Self, 'transitionTime', 1.0);
  Fields.Add(FFdtransitionTime);
  { X3D specification comment: [0, Inf) }

  FFdtransitionType := TMFString.Create(Self, 'transitionType', ['LINEAR']);
  Fields.Add(FFdtransitionType);
  { X3D specification comment: ["TELEPORT","LINEAR","ANIMATE",...] }

  { TODO: default value was ["WALK", "ANY"] in VRML 97.
    X3D changed default value. }
  FFdtype := TMFString.Create(Self, 'type', ['EXAMINE', 'ANY']);
   Fdtype.ChangesAlways := [chNavigationInfo];
  Fields.Add(FFdtype);
  { X3D specification comment: ["ANY","WALK","EXAMINE","FLY","LOOKAT","NONE",...] }

  FFdvisibilityLimit := TSFFloat.Create(Self, 'visibilityLimit', 0.0);
  Fields.Add(FFdvisibilityLimit);
  { X3D specification comment: [0,Inf) }

  FEventtransitionComplete := TVRMLEvent.Create(Self, 'transitionComplete', TSFBool, false);
  Events.Add(FEventtransitionComplete);

  DefaultContainerField := 'children';

  Eventset_bind.OnReceive.Add(@EventSet_BindReceive);
end;

class function TNodeNavigationInfo.ClassNodeTypeName: string;
begin
  Result := 'NavigationInfo';
end;

function TNodeNavigationInfo.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 100);
end;

class function TNodeNavigationInfo.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

procedure TNodeNavigationInfo.EventSet_BindReceive(
  Event: TVRMLEvent; Value: TVRMLField; const Time: TVRMLTime);
begin
  if EventsEngine <> nil then
    EventsEngine.
      GetNavigationInfoStack.Set_Bind(Self, (Value as TSFBool).Value);
end;

constructor TNodeOrthoViewpoint.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdfieldOfView := TMFFloat.Create(Self, 'fieldOfView', [-1, -1, 1, 1]);
   FdfieldOfView.ChangesAlways := [chViewpointProjection];
  Fields.Add(FFdfieldOfView);
  { X3D specification comment:  (-Inf,Inf) }

  FFdposition := TSFVec3f.Create(Self, 'position', Vector3Single(0, 0, 10));
   Fdposition.ChangesAlways := [chViewpointVectors];
  Fields.Add(FFdposition);
  { X3D specification comment: (-Inf,Inf) }

  DefaultContainerField := 'children';
end;

class function TNodeOrthoViewpoint.ClassNodeTypeName: string;
begin
  Result := 'OrthoViewpoint';
end;

function TNodeOrthoViewpoint.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeOrthoViewpoint.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeOrthoViewpoint.Position: TSFVec3f;
begin
  Result := FdPosition;
end;

class function TNodeOrthoViewpoint.ProjectionType: TProjectionType;
begin
  Result := ptOrthographic;
end;

function TNodeOrthoViewpoint.ProjectionMatrix: TMatrix4Single;
var
  OrthoViewDimensions: TVector4Single;
begin
  { default OrthoViewDimensions, for OrthoViewpoint }
  OrthoViewDimensions[0] := -1;
  OrthoViewDimensions[1] := -1;
  OrthoViewDimensions[2] :=  1;
  OrthoViewDimensions[3] :=  1;

  if FdFieldOfView.Items.High >= 0 then OrthoViewDimensions[0] := FdFieldOfView.Items[0];
  if FdFieldOfView.Items.High >= 1 then OrthoViewDimensions[1] := FdFieldOfView.Items[1];
  if FdFieldOfView.Items.High >= 2 then OrthoViewDimensions[2] := FdFieldOfView.Items[2];
  if FdFieldOfView.Items.High >= 3 then OrthoViewDimensions[3] := FdFieldOfView.Items[3];

  { TODO: for currently bound viewpoint, we should honour
    fieldOfView and aspect ratio of current window,
    by calling AspectFieldOfView. }

  Result := OrthoProjMatrix(
    { Beware: order of OrthoViewpoint.fieldOfView and OrthoViewDimensions
      is different than typical OpenGL and our OrthoProjMatrix params. }
    OrthoViewDimensions[0],
    OrthoViewDimensions[2],
    OrthoViewDimensions[1],
    OrthoViewDimensions[3],
    1, 100); { TODO: near, far projection testing values }
end;

class procedure TNodeOrthoViewpoint.AspectFieldOfView(
  var FieldOfView: TVector4Single; const WindowWidthToHeight: Single);

  { Scale the extent. Since AspectFieldOfView should only make FieldOfView
    larger (because OrthoViewpoint.fieldOfView gives the minimal extents),
    so given here Scale should always be >= 1. }
  procedure ScaleExtent(const Scale: Single; var Min, Max: Single);
  var
    L, Middle: Single;
  begin
    Middle := (Min + Max) / 2;
    L := Max - Min;

    if L < 0 then
    begin
      if Log then
        WritelnLog('OrthoViewpoint', 'OrthoViewpoint.fieldOfView max extent smaller than min extent');
      Exit;
    end;

    Min := Middle - Scale * L / 2;
    Max := Middle + Scale * L / 2;
  end;

var
  FOVAspect: Single;
begin
  if FloatsEqual(FieldOfView[2], FieldOfView[0]) or
     FloatsEqual(FieldOfView[3], FieldOfView[1]) then
  begin
    if Log then
      WritelnLog('OrthoViewpoint', 'OrthoViewpoint.fieldOfView extent (max-min) is zero');
    Exit;
  end;

  FOVAspect :=
    (FieldOfView[2] - FieldOfView[0]) /
    (FieldOfView[3] - FieldOfView[1]);

  { The idea is to change FieldOfView, such that at the end the above
    equation would calculate FOVAspect as equal to WindowWidthToHeight.

    To do this, multiply above equation by WindowWidthToHeight / FOVAspect.
    We have to transform put this scale into either horizontal or vertical
    extent, since we only want to make FieldOfView larger (never smaller). }

  if FOVAspect > WindowWidthToHeight then
  begin
    ScaleExtent(FOVAspect / WindowWidthToHeight, FieldOfView[1], FieldOfView[3]);
  end else
  if FOVAspect < WindowWidthToHeight then
  begin
    ScaleExtent(WindowWidthToHeight / FOVAspect, FieldOfView[0], FieldOfView[2]);
  end;
end;

constructor TNodeViewpoint.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdfieldOfView := TSFFloat.Create(Self, 'fieldOfView', DefaultViewpointFieldOfView);
   FdfieldOfView.ChangesAlways := [chViewpointProjection];
  Fields.Add(FFdfieldOfView);
  { X3D specification comment: (0,Pi) }

  FFdposition := TSFVec3f.Create(Self, 'position', Vector3Single(0, 0, 10));
   Fdposition.ChangesAlways := [chViewpointVectors];
  Fields.Add(FFdposition);
  { X3D specification comment: (-Inf,Inf) }

  DefaultContainerField := 'children';
end;

class function TNodeViewpoint.ClassNodeTypeName: string;
begin
  Result := 'Viewpoint';
end;

function TNodeViewpoint.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  { Since VRML 2.0 }
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 2, 0, 1000);
end;

class function TNodeViewpoint.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNVRML97Nodes + ClassNodeTypeName) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

function TNodeViewpoint.Position: TSFVec3f;
begin
  Result := FdPosition;
end;

class function TNodeViewpoint.ProjectionType: TProjectionType;
begin
  Result := ptPerspective;
end;

function TNodeViewpoint.AngleOfView(
  const ThisToOtherSizeRatio: Single): Single;
begin
  Result := ViewpointAngleOfView(FdFieldOfView.Value, ThisToOtherSizeRatio);
end;

class function TNodeViewpoint.ViewpointAngleOfView(
  FieldOfView: Single;
  const ThisToOtherSizeRatio: Single): Single;
var
  OtherAngle: Single;
begin
  Clamp(FieldOfView, 0.01, Pi - 0.01);

  if ThisToOtherSizeRatio < 1 then
  begin
    { So the resulting angle is the smaller one. }
    Result := FieldOfView;
    OtherAngle :=
      AdjustViewAngleRadToAspectRatio(Result, 1 / ThisToOtherSizeRatio);
    if OtherAngle > Pi then
      Result := AdjustViewAngleRadToAspectRatio(Pi, ThisToOtherSizeRatio);
  end else
  begin
    { So the resulting angle is the larger one. }
    OtherAngle := FieldOfView;
    Result :=
      AdjustViewAngleRadToAspectRatio(OtherAngle, ThisToOtherSizeRatio);
    if Result > Pi then
      Result := Pi;
  end;
end;

function TNodeViewpoint.ProjectionMatrix: TMatrix4Single;
begin
  { TODO: for currently bound viewpoint, we should honour
    fieldOfView and aspect ratio of current window? }
  Result := PerspectiveProjMatrixRad(
    FdFieldOfView.Value, 1,
    1, 100); { TODO: near, far projection testing values }
end;

constructor TNodeViewpointGroup.Create(const ANodeName: string;
  const AWWWBasePath: string);
begin
  inherited;

  FFdcenter := TSFVec3f.Create(Self, 'center', Vector3Single(0, 0, 0));
  Fields.Add(FFdcenter);
  { X3D specification comment: (-Inf,Inf) }

  FFdchildren := TMFNode.Create(Self, 'children', [TNodeX3DViewpointNode, TNodeViewpointGroup]);
  Fields.Add(FFdchildren);

  FFddisplayed := TSFBool.Create(Self, 'displayed', true);
  Fields.Add(FFddisplayed);

  FFdsize := TSFVec3f.Create(Self, 'size', Vector3Single(0, 0, 0));
  Fields.Add(FFdsize);
  { X3D specification comment: (-Inf,Inf) }

  DefaultContainerField := 'children';
end;

class function TNodeViewpointGroup.ClassNodeTypeName: string;
begin
  Result := 'ViewpointGroup';
end;

function TNodeViewpointGroup.SuggestedVRMLVersion(
  out VerMajor, VerMinor, SuggestionPriority: Integer): boolean;
begin
  Result := inherited SuggestedVRMLVersion(VerMajor, VerMinor, SuggestionPriority);
  AndSuggestedVRMLVersion(Result, VerMajor, VerMinor, SuggestionPriority,
    true, 3, 2, 2000);
end;

class function TNodeViewpointGroup.URNMatching(const URN: string): boolean;
begin
  Result := (inherited URNMatching(URN)) or
    (URN = URNX3DNodes + ClassNodeTypeName);
end;

procedure RegisterNavigationNodes;
begin
  NodesManager.RegisterNodeClasses([
    TNodeBillboard,
    TNodeCollision,
    TNodeLOD_2,
    TNodeLOD_3,
    TNodeNavigationInfo,
    TNodeOrthoViewpoint,
    TNodeViewpoint,
    TNodeViewpointGroup
  ]);
end;
{$endif read_implementation}
