{$ifdef read_interface}

  { }
  TGLTextureNode = class;

  TGLTextureNodeClass = class of TGLTextureNode;

  TTextureEnableDisable = (etOff, et2D, etCubeMap, et3D);

  { OpenGL handling for VRML texture node. }
  TGLTextureNode = class(TResourceRenderer)
  protected
    { Calculate things from TextureProperties node.
      If TextureProperties = @nil, they are taken from defaults
      (possibly in Attributes). }
    procedure HandleTexturePropertiesCore(
      TextureProperties: TNodeTextureProperties;
      out MinFilter, MagFilter: TGLint;
      out Anisotropy: TGLfloat);

    { Calculate things from TextureProperties node.
      If TextureProperties = @nil or not of TNodeTextureProperties class,
      they are taken from defaults (possibly in Attributes).

      This is useful when interpreting VRML/X3D files,
      as you have no guarantee user didn't place there some disallowed node
      in "textureProperties" field. }
    procedure HandleTextureProperties(
      TextureProperties: TVRMLNode;
      out MinFilter, MagFilter: TGLint;
      out Anisotropy: TGLfloat);

    { Decide if this class can handle given texture Node. }
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; virtual; abstract;

    { Enable/disable texturing (2D and cube map) on current texture unit. }
    class procedure TextureEnableDisable(const Enable: TTextureEnableDisable);

    { Do the time-consuming preparations before rendering this texture.
      Called from TVRMLOpenGLRenderer.Prepare, always through our
      Prepare method. Our Prepare method takes care to catch
      common exceptions from this (EFramebufferError, ETextureLoadError),
      convert them to VRMLWarning and make Unprepare to undo the preparations.
      So Prepare-Unprepare work like constructor-destructor, with Unprepare
      having to be prepared to finilizing incomplete instance. }
    procedure PrepareCore(State: TVRMLGraphTraverseState); virtual; abstract;
  public
    { ANode must be TNodeX3DTextureNode }
    constructor Create(ARenderer: TVRMLOpenGLRenderer; ANode: TVRMLNode); override;

    { Reference to handled texture node.
      Never @nil.
      It's guaranteed to satisfy IsClassForTextureNode method of this class. }
    function TextureNode: TNodeX3DTextureNode;

    { Find suitable TGLTextureNode class that can best handle given Node
      (with given Cache). Returns @nil if not found.

      @italic(Descedants implementors): override IsClassForTextureNode
      to be correctly recognized by this. }
    class function ClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): TGLTextureNodeClass;

    { Do the time-consuming preparations before rendering this texture.
      Calls PrepareCore. }
    procedure Prepare(State: TVRMLGraphTraverseState);
  public
    { This is the alpha channel of this texture.
      Used by TVRMLOpenGLRenderer.PreparedTextureAlphaChannelType.
      Should be calculated and set in Prepare.

      For textures with normal images, this is the saved result of
      TImage.AlphaChannelType. For videos, saved result of
      TVideo.AlphaChannelType.

      By default, atNone in this class.

      TODO: it would be better to move this inside, possibly
      only to applicable class types? And expose only function
      like UseBlending, and this is the main use of
      TVRMLOpenGLRenderer.PreparedTextureAlphaChannelType ? }
    AlphaChannelType: TAlphaChannelType;

    { Bind texture for OpenGL (without enabling it).

      Just like Enable, returns @false when texture node was not successfully
      prepared for OpenGL. Returns @true when it was successfully bound
      (caller can be sure then that given texture unit is currently active). }
    function Bind(const TextureUnit: Cardinal): boolean; virtual; abstract;

    { Enables texture for OpenGL. This has to bind texture identifier
      and enable proper texture state (for example:
      2D, and not 3D, and not cube).

      When returns @false, it means that texture node was not successfully
      prepared for OpenGL, which means (we assume that you called Prepare
      before Enable) that texture failed to load, required not available
      OpenGL version / extension etc. Caller will then disable
      the texture unit, and you don't have to generate tex coords for it.

      When returns @true (success) caller can be sure that the specified
      TextureUnit is currently bound (if OpenGL multitexturing
      extensions are available at all). This is useful, if you want
      to later adjust texture unit parameters, like
      glTexEnvi(GL_TEXTURE_ENV, ...).

      It's also already enabled (by glEnable(GL_TEXTURE_2D /
      GL_TEXTURE_CUBE_MAP_ARB / GL_TEXTURE_3D_EXT) ).

      Primitives3DTextureCoords may be modified,
      but only to true, by this procedure. }
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; virtual; abstract;

    { Sets texture state for many texture units, based on this node.
      On every texture unit where something is enabled,
      proper texture identifier must be bound.
      Also, has to set complete glTexEnv on every enabled texture unit.

      TextureUnitsCount says how many texture units can be enabled/disabled.

      TextureUnitsCount does *not* take into account whether multitexturing
      OpenGL extensions are available at all.
      Look at UseMultiTexturing for this.
      Think of UseMultiTexturing as capping TextureUnitsCount to 1
      (still, remember to honour TextureUnitsCount = 0 case in your implementation,
      even when UseMultiTexturing = @true).

      You have to set TexCoordsNeeded, this is the count of texture units
      where some texture coordinates should be generated.
      This means that all texture units above TexCoordsNeeded
      (to TextureUnitsCount - 1) should be disabled by the caller (no need to
      do this in EnableAll),
      and there's no need to generated texture coords for them.

      (
      Yes, there is some small optimization missed in the definition
      of TexCoordsNeeded: if some textures in the middle of
      multitexture children list failed to load, but some following children
      succeded, we'll generate tex coords even for the useless texture units
      in the middle. We could avoid generating texture coords for them,
      by changing TexCoordsNeeded into bool array.
      This optimization is not considered worthy implementing for now.
      )

      You have to set texture state of all texture units < TexCoordsNeeded,
      and only on them.

      Primitives3DTextureCoords may be modified,
      but only to true, by this procedure. }
    procedure EnableAll(
      const TextureUnitsCount: Cardinal;
      const UseMultiTexturing: boolean;
      out TexCoordsNeeded: Cardinal;
      var Primitives3DTextureCoords: boolean); virtual; abstract;
  end;

  TGLTextureNodes = class(TResourceRenderersList)
  private
    function GetItems(const Index: Integer): TGLTextureNode;
  public
    { Looks for item with given ANode.
      Returns -1 if not found. }
    function TextureNodeIndex(ANode: TNodeX3DTextureNode): Integer;

    { Looks for item with given ANode.
      Returns @nil if not found. }
    function TextureNode(ANode: TNodeX3DTextureNode): TGLTextureNode;

    property Items[Index: Integer]: TGLTextureNode read GetItems; default;

    { Prepare texture node, adding it to the list, if not prepared already.
      Accepts multi texture or not-multi texture nodes, accepts (and ignores)
      also @nil as TextureNode.
      Ignore not handled node classes.

      Returns created (or already existing) TGLTextureNode,
      it may be useful in case of TGLMultiTextureNode.Prepare implementation.

      Returns @nil if Node not suitable for TGLTextureNode (not handled,
      or not really a texture node at all). }
    function Prepare(State: TVRMLGraphTraverseState;
      ANode: TNodeX3DTextureNode;
      ARenderer: TVRMLOpenGLRenderer): TGLTextureNode;

    { Only bind texture node. Calls TGLTextureNode.Enable method.
      If no texture renderer is prepared for this node,
      returns @false. }
    function Bind(ANode: TNodeX3DTextureNode;
      const TextureUnit: Cardinal): boolean;

    { Enable and bind texture node. Calls TGLTextureNode.Enable method.
      If no texture renderer is prepared for this node,
      returns @false. }
    function Enable(ANode: TNodeX3DTextureNode;
      const TextureUnit: Cardinal;
      var APrimitives3DTextureCoords: boolean): boolean;
  end;

  { Common class for all single (not multi-texture) texture nodes.

    Implements EnableAll method, by calling @link(Enable) call.
    Override only @link(Enable) in descendants. }
  TGLSingleTextureNode = class(TGLTextureNode)
  protected
    { Determines should texture mode be suited for RGB and grayscale texture.
      Default false, you should set this in descendant
      (latest possibility is to set this is a successfull Enable call,
      but usually you want to do it in a Prepare call).
      You can set it by SetTextureRGBFromImage. }
    TextureRGB: boolean;
    procedure SetTextureRGBFromImage(Image: TEncodedImage);
  public
    procedure EnableAll(
      const TextureUnitsCount: Cardinal;
      const UseMultiTexturing: boolean;
      out TexCoordsNeeded: Cardinal;
      var Primitives3DTextureCoords: boolean); override;
  end;

  { Handler for TNodeMultiTexture.

    This is somewhat special, in that it will use other TGLTextureNode
    handlers to handle single textures inside --- but this is completely
    hidden from the interface. }
  TGLMultiTextureNode = class(TGLTextureNode)
  private
    PreparedTextureChildren: TVRMLNodesList;
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    { ANode must be TNodeMultiTexture }
    constructor Create(ARenderer: TVRMLOpenGLRenderer; ANode: TVRMLNode); override;
    destructor Destroy; override;

    function TextureNode: TNodeMultiTexture;

    procedure Unprepare; override;
    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;
    procedure EnableAll(
      const TextureUnitsCount: Cardinal;
      const UseMultiTexturing: boolean;
      out TexCoordsNeeded: Cardinal;
      var Primitives3DTextureCoords: boolean); override;
  end;

  { Handler for TVRMLTextureNode with image (not a video). }
  TGLImageTextureNode = class(TGLSingleTextureNode)
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    GLName: TGLuint;
    NormalMap, HeightMap: TGLuint;
    HeightMapScale: Single;

    function TextureNode: TVRMLTextureNode;

    procedure Unprepare; override;
    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;
  end;

  TGLMovieTextureNode = class(TGLSingleTextureNode)
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    GLVideo: TGLVideo;

    function TextureNode: TNodeMovieTexture;

    procedure Unprepare; override;
    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;
  end;

  TGLRenderedTextureNode = class(TGLSingleTextureNode)
  private
    RenderToTexture: TGLRenderToTexture;
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    GLName: TGLuint;

    { The actual decided image size and mipmap status. }
    Width, Height: Cardinal;
    NeedsMipmaps: boolean;
    DepthMap: boolean;

    function TextureNode: TNodeRenderedTexture;

    procedure Unprepare; override;
    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;

    procedure Update(
      const Render: TRenderFromViewFunction;
      const ProjectionNear, ProjectionFar: Single;
      var NeedsRestoreViewport: boolean;
      CurrentViewpoint: TVRMLViewpointNode;
      IsLastViewer: boolean;
      const LastViewerPosition, LastViewerDirection, LastViewerUp: TVector3Single);
  end;

  { Common handling for texture nodes of TNodeX3DEnvironmentTextureNode. }
  TGLCubeMapTextureNode = class(TGLSingleTextureNode)
  public
    GLName: TGLuint;

    function TextureNode: TNodeX3DEnvironmentTextureNode;

    { Releases GLName by TextureCubeMap_DecReference.
      Suitable for descendants tht initialize GLName by
      TextureCubeMap_IncReference. }
    procedure Unprepare; override;

    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;
  end;

  TGLComposedCubeMapTextureNode = class(TGLCubeMapTextureNode)
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    function TextureNode: TNodeComposedCubeMapTexture;
  end;

  TGLImageCubeMapTextureNode = class(TGLCubeMapTextureNode)
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    function TextureNode: TNodeImageCubeMapTexture;
  end;

  TGLGeneratedCubeMapTextureNode = class(TGLCubeMapTextureNode)
  private
    RenderToTexture: TGLRenderToTexture;
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    { The right size of the texture,
      that satisfies all OpenGL cube map sizes requirements
      (IsCubeMapTextureSized). }
    Size: Cardinal;

    { This says if MinFilter needs mipmaps. }
    NeedsMipmaps: boolean;

    function TextureNode: TNodeGeneratedCubeMapTexture;

    procedure Unprepare; override;

    procedure Update(
      const Render: TRenderFromViewFunction;
      const ProjectionNear, ProjectionFar: Single;
      var NeedsRestoreViewport: boolean;
      const CubeMiddle: TVector3Single);
  end;

  TGL3DTextureNode = class(TGLSingleTextureNode)
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    GLName: TGLuint;

    function TextureNode: TNodeX3DTexture3DNode;

    procedure Unprepare; override;
    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;
  end;

  TGLGeneratedShadowMap = class(TGLSingleTextureNode)
  private
    RenderToTexture: TGLRenderToTexture;
    { VarianceShadowMaps calculated at the PrepareCore time. }
    VarianceShadowMaps: boolean;
    VarianceShadowMapsProgram: TGLSLProgram;
    NeedsMipmaps: boolean;
  protected
    class function IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
      ANode: TNodeX3DTextureNode): boolean; override;
    procedure PrepareCore(State: TVRMLGraphTraverseState); override;
  public
    GLName: TGLuint;

    { The right size of the texture,
      that satisfies all OpenGL sizes requirements. }
    Size: Cardinal;

    function TextureNode: TNodeGeneratedShadowMap;

    procedure Unprepare; override;
    function Bind(const TextureUnit: Cardinal): boolean; override;
    function Enable(const TextureUnit: Cardinal;
      var Primitives3DTextureCoords: boolean): boolean; override;

    procedure Update(
      const Render: TRenderFromViewFunction;
      const ProjectionNear, ProjectionFar: Single;
      var NeedsRestoreViewport: boolean;
      Light: TNodeX3DLightNode);
  end;

{$endif read_interface}

{$ifdef read_implementation}

function TextureRepeatToGL(const VrmlTextureRepeat: boolean): TGLenum;
begin
  if VrmlTextureRepeat then
    Result := GL_REPEAT else
    { GL_CLAMP is useless if VRML doesn't allow to control texture border color,
      and CLAMP_TO_EDGE is the more natural clamping method anyway...
      Hm, but X3D specification seems to indicate that normal clamp is OpenGL's CLAMP,
      and CLAMP_TO_EDGE is available by TextureProperties.boundaryMode*.
      But until this will get implemented, it's much safer (and more sensible?)
      to use GL_CLAMP_TO_EDGE here. }
    Result := KamGL_CLAMP_TO_EDGE;
end;

{ TGLTextureNode ------------------------------------------------------------- }

constructor TGLTextureNode.Create(ARenderer: TVRMLOpenGLRenderer; ANode: TVRMLNode);
begin
  Assert(ANode is TNodeX3DTextureNode, 'TGLTextureNode.Create acceps as Node only TNodeX3DTextureNode');
  inherited;
end;

procedure TGLTextureNode.HandleTexturePropertiesCore(
  TextureProperties: TNodeTextureProperties;
  out MinFilter, MagFilter: TGLint;
  out Anisotropy: TGLfloat);

  function StrToMinFilter(S: string): TGLint;
  begin
    S := UpperCase(S);

    if S = 'AVG_PIXEL' then Result := GL_LINEAR else
    if S = 'AVG_PIXEL_AVG_MIPMAP' then Result := GL_LINEAR_MIPMAP_LINEAR else
    if S = 'AVG_PIXEL_NEAREST_MIPMAP' then Result := GL_LINEAR_MIPMAP_NEAREST else
    if S = 'NEAREST_PIXEL_AVG_MIPMAP' then Result := GL_NEAREST_MIPMAP_LINEAR else
    if S = 'NEAREST_PIXEL_NEAREST_MIPMAP' then Result := GL_NEAREST_MIPMAP_NEAREST else
    if S = 'NEAREST_PIXEL' then Result := GL_NEAREST else

    if S = 'DEFAULT' then Result := Renderer.Attributes.TextureMinFilter else

    if S = 'FASTEST' then Result := GL_NEAREST else
    if S = 'NICEST' then Result := GL_LINEAR_MIPMAP_LINEAR else

    if S = 'NEAREST' then
    begin
      VRMLWarning(vwSerious, Format('"%s" is not allowed texture minification, this is an Avalon-only extension, please fix to "NEAREST_PIXEL"', [S]));
      Result := GL_NEAREST;
    end else

    if S = 'LINEAR' then
    begin
      VRMLWarning(vwSerious, Format('"%s" is not allowed texture minification, this is an Avalon-only extension, please fix to "AVG_PIXEL"', [S]));
      Result := GL_LINEAR;
    end else

    begin
      Result := Renderer.Attributes.TextureMinFilter;
      VRMLWarning(vwSerious, Format('Unknown texture minification filter "%s"', [S]));
    end;
  end;

  function StrToMagFilter(S: string): TGLint;
  begin
    S := UpperCase(S);

    if S = 'AVG_PIXEL' then Result := GL_LINEAR else
    if S = 'NEAREST_PIXEL' then Result := GL_NEAREST else

    if S = 'DEFAULT' then Result := Renderer.Attributes.TextureMagFilter else

    if S = 'FASTEST' then Result := GL_NEAREST else
    if S = 'NICEST' then Result := GL_LINEAR else

    if S = 'NEAREST' then
    begin
      VRMLWarning(vwSerious, Format('"%s" is not allowed texture magnification, this is an Avalon-only extension, please fix to "NEAREST_PIXEL"', [S]));
      Result := GL_NEAREST;
    end else

    if S = 'LINEAR' then
    begin
      VRMLWarning(vwSerious, Format('"%s" is not allowed texture magnification, this is an Avalon-only extension, please fix to "AVG_PIXEL"', [S]));
      Result := GL_LINEAR;
    end else

    begin
      Result := Renderer.Attributes.TextureMagFilter;
      VRMLWarning(vwSerious, Format('Unknown texture minification filter "%s"', [S]));
    end;
  end;

begin { HandleTextureProperties }
  if TextureProperties <> nil then
  begin
    MinFilter := StrToMinFilter(TextureProperties.FdMinificationFilter.Value);
    MagFilter := StrToMagFilter(TextureProperties.FdMagnificationFilter.Value);
    Anisotropy := TextureProperties.FdAnisotropicDegree.Value;
  end else
  begin
    MinFilter := Renderer.Attributes.TextureMinFilter;
    MagFilter := Renderer.Attributes.TextureMagFilter;
    Anisotropy := 1;
  end;
end { HandleTextureProperties };

procedure TGLTextureNode.HandleTextureProperties(
  TextureProperties: TVRMLNode;
  out MinFilter, MagFilter: TGLint;
  out Anisotropy: TGLfloat);
begin
  if (TextureProperties = nil) or
     not (TextureProperties is TNodeTextureProperties) then
    HandleTexturePropertiesCore(nil, MinFilter, MagFilter, Anisotropy) else
    HandleTexturePropertiesCore(TNodeTextureProperties(TextureProperties),
      MinFilter, MagFilter, Anisotropy);
end;

class procedure TGLTextureNode.TextureEnableDisable(
  const Enable: TTextureEnableDisable);
begin
  case Enable of
    etOff:
      begin
        glDisable(GL_TEXTURE_2D);
        if GL_ARB_texture_cube_map then glDisable(GL_TEXTURE_CUBE_MAP_ARB);
        if GL_EXT_texture3D        then glDisable(GL_TEXTURE_3D_EXT);
      end;
    et2D:
      begin
        glEnable(GL_TEXTURE_2D);
        if GL_ARB_texture_cube_map then glDisable(GL_TEXTURE_CUBE_MAP_ARB);
        if GL_EXT_texture3D        then glDisable(GL_TEXTURE_3D_EXT);
      end;
    etCubeMap:
      begin
        glDisable(GL_TEXTURE_2D);
        if GL_ARB_texture_cube_map then glEnable(GL_TEXTURE_CUBE_MAP_ARB);
        if GL_EXT_texture3D        then glDisable(GL_TEXTURE_3D_EXT);
      end;
    et3D:
      begin
        glDisable(GL_TEXTURE_2D);
        if GL_ARB_texture_cube_map then glDisable(GL_TEXTURE_CUBE_MAP_ARB);
        if GL_EXT_texture3D        then glEnable(GL_TEXTURE_3D_EXT);
      end;
    else raise EInternalError.Create('TextureEnableDisable?');
  end;
end;

class function TGLTextureNode.ClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): TGLTextureNodeClass;

  function TryResult(C: TGLTextureNodeClass): boolean;
  begin
    Result := C.IsClassForTextureNode(Cache, ANode);
    if Result then
      ClassForTextureNode := C;
  end;

begin
  { TODO: in the future, some way of registering class for this will
    be done. For now, just try known final TGLTextureNode descendants. }
  if not (TryResult(TGLMultiTextureNode) or
          TryResult(TGLImageTextureNode) or
          TryResult(TGLMovieTextureNode) or
          TryResult(TGLRenderedTextureNode) or
          TryResult(TGLComposedCubeMapTextureNode) or
          TryResult(TGLImageCubeMapTextureNode) or
          TryResult(TGLGeneratedCubeMapTextureNode) or
          TryResult(TGL3DTextureNode) or
          TryResult(TGLGeneratedShadowMap) ) then
    Result := nil;
end;

procedure TGLTextureNode.Prepare(State: TVRMLGraphTraverseState);
begin
  try
    PrepareCore(State);
  except
    on E: EFramebufferError do
    begin
      Unprepare;
      VRMLWarning(vwIgnorable, 'Framebuffer error, generated texture not possible: '
        + E.Message);
    end;

    on E: ETextureLoadError do
    begin
      Unprepare;
      VRMLWarning(vwIgnorable, 'Cannot load texture to OpenGL: ' + E.Message);
    end;
  end;
end;

function TGLTextureNode.TextureNode: TNodeX3DTextureNode;
begin
  Result := TNodeX3DTextureNode(inherited Node);
end;

{ TGLTextureNodes ------------------------------------------------------------ }

function TGLTextureNodes.TextureNodeIndex(ANode: TNodeX3DTextureNode): Integer;
begin
  Result := inherited NodeIndex(ANode);
end;

function TGLTextureNodes.TextureNode(ANode: TNodeX3DTextureNode): TGLTextureNode;
begin
  Result := TGLTextureNode(inherited Node(ANode));
end;

function TGLTextureNodes.GetItems(const Index: Integer): TGLTextureNode;
begin
  Result := TGLTextureNode(inherited Items[Index]);
end;

function TGLTextureNodes.Prepare(State: TVRMLGraphTraverseState;
  ANode: TNodeX3DTextureNode;
  ARenderer: TVRMLOpenGLRenderer): TGLTextureNode;
var
  GLTextureNodeClass: TGLTextureNodeClass;
begin
  Result := nil;

  { Conditions below describing when the texture is added to the cache
    (more precisely, just "not Attributes.PureGeometry" for now)
    are reflected in PreparedTextureAlphaChannelType documentation. }

  if (not ARenderer.Attributes.PureGeometry) and
     (ANode <> nil) then
  begin
    GLTextureNodeClass := TGLTextureNodeClass.ClassForTextureNode(ARenderer.Cache, ANode);

    if (GLTextureNodeClass <> nil { Ignore if not handled node. }) and
       (TextureNodeIndex(ANode) = -1) then
    begin
      Result := GLTextureNodeClass.Create(ARenderer, ANode);
      Result.Prepare(State);
      Add(Result);
    end;
  end;
end;

function TGLTextureNodes.Bind(ANode: TNodeX3DTextureNode;
  const TextureUnit: Cardinal): boolean;
var
  GLTextureNode: TGLTextureNode;
begin
  GLTextureNode := TextureNode(ANode);
  Result := GLTextureNode <> nil;
  if Result then
    Result := GLTextureNode.Bind(TextureUnit);
end;

function TGLTextureNodes.Enable(ANode: TNodeX3DTextureNode;
  const TextureUnit: Cardinal;
  var APrimitives3DTextureCoords: boolean): boolean;
var
  GLTextureNode: TGLTextureNode;
begin
  GLTextureNode := TextureNode(ANode);
  Result := GLTextureNode <> nil;
  if Result then
    Result := GLTextureNode.Enable(TextureUnit, APrimitives3DTextureCoords);
end;

{ TGLSingleTextureNode ------------------------------------------------------- }

procedure TGLSingleTextureNode.SetTextureRGBFromImage(Image: TEncodedImage);
begin
  TextureRGB :=
    (Image is TS3TCImage) or
    (Image is TRGBImage) or
    (Image is TRGBAlphaImage) or
    (Image is TRGBFloatImage);
end;

procedure TGLSingleTextureNode.EnableAll(
  const TextureUnitsCount: Cardinal;
  const UseMultiTexturing: boolean;
  out TexCoordsNeeded: Cardinal;
  var Primitives3DTextureCoords: boolean);
begin
  TexCoordsNeeded := 0;
  if (TextureUnitsCount > 0) and
     Enable(0, Primitives3DTextureCoords) then
  begin
    { Set glTexEnvi using Attributes.TextureModeRGB/Grayscale }
    if TextureRGB then
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, Renderer.Attributes.TextureModeRGB) else
      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, Renderer.Attributes.TextureModeGrayscale);
    TexCoordsNeeded := 1;
  end;
end;

{ TGLMultiTextureNode -------------------------------------------------------- }

constructor TGLMultiTextureNode.Create(ARenderer: TVRMLOpenGLRenderer; ANode: TVRMLNode);
begin
  Assert(ANode is TNodeMultiTexture, 'TGLMultiTextureNode.Create acceps as Node only TNodeMultiTexture');
  inherited;
  PreparedTextureChildren := TVRMLNodesList.Create;
end;

destructor TGLMultiTextureNode.Destroy;
begin
  FreeAndNil(PreparedTextureChildren);
  inherited;
end;

class function TGLMultiTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeMultiTexture;
end;

function TGLMultiTextureNode.TextureNode: TNodeMultiTexture;
begin
  Result := TNodeMultiTexture(inherited TextureNode);
end;

procedure TGLMultiTextureNode.PrepareCore(State: TVRMLGraphTraverseState);

  procedure MaxTo1st(var A: TAlphaChannelType; const B: TAlphaChannelType);
  begin
    if B > A then A := B;
  end;

var
  ChildTex: TVRMLNode;
  ChildPrepared: TGLTextureNode;
  I: Integer;
begin
  { Prepare all children.

    Also, calculate our AlphaChannelType:
    - if any texture has atFullRange, then we're atFullRange,
    - otherwise, if any texture has atSimpleYesNo, then we're atSimpleYesNo,
    - otherwise, we're atNone

    Thanks to how order of TAlphaChannelType is defined,
    this is equivalent to simple "our AlphaChannelType is maximum
    AlphaChannelType of our children".
  }

  AlphaChannelType := atNone; { default value, but set for paranoia anyway }

  { fill PreparedTextureChildren along the way.
    This will be used in Unprepare. }
  PreparedTextureChildren.Count := 0;

  for I := 0 to TextureNode.FdTexture.Count - 1 do
  begin
    ChildTex := TextureNode.FdTexture.Items[I];
    if (ChildTex <> nil) and
       (ChildTex is TNodeX3DTextureNode) then
    begin
      if ChildTex is TNodeMultiTexture then
        VRMLWarning(vwSerious, 'Child of MultiTexture node cannot be another MultiTexture node') else
      begin
        PreparedTextureChildren.Add(ChildTex);
        ChildPrepared := Renderer.GLTextureNodes.Prepare(State, TNodeX3DTextureNode(ChildTex), Renderer);
        if ChildPrepared <> nil then
          MaxTo1st(AlphaChannelType, ChildPrepared.AlphaChannelType);
      end;
    end;
  end;
end;

procedure TGLMultiTextureNode.Unprepare;
var
  I: Integer;
begin
  { Below comments concerns engine before 2.0.0. After 2.0.0 this could actually
    by simplified, no need for PreparedTextureChildren.

    We cannot look at TextureNode.FdTexture here.

    Reason: TextureNode may be already freed at the Unprepare time.
    VRMLOpenGLRenderer explicitly allows to free vrml nodes before
    unpreparing them. This is used e.g. by doing TVRMLScene.Load
    (that calls ChangedAll, that calls Unprepare, only at the end,
    *after* old nodes have been already freed.)

    Accessing here TextureNode.FdTexture.Count e.g. crashes on
    multiple_viewports: open models/castle_y_up.x3dv, then open
    models/boxes.x3dv. (Note that multiple_viewports loads new scene
    by simple Scene.Load.)

    That's why we use PreparedTextureChildren saved.

    Note: we cannot save TGLTextureNode values, as they could be freed
    by something beside our control. So PreparedTextureChildren holds
    only vrml nodes, passed to Renderer.GLTextureNodes.Unprepare. }

  for I := 0 to PreparedTextureChildren.Count - 1 do
    Renderer.GLTextureNodes.Unprepare(PreparedTextureChildren[I]);
end;

function TGLMultiTextureNode.Bind(const TextureUnit: Cardinal): boolean;
begin
  { TGLMultiTextureNode cannot set only one texture unit.
    This may be called from GLSL shader, when someone will use MultiTexture
    node for a shader uniform field. I don't know how this should be handled,
    I guess returning failure is Ok for now. }
  Result := false;
end;

function TGLMultiTextureNode.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  { This should never be called. TGLMultiTextureNode cannot set only one
    texture unit. }
  Result := false;
end;

procedure TGLMultiTextureNode.EnableAll(
  const TextureUnitsCount: Cardinal;
  const UseMultiTexturing: boolean;
  out TexCoordsNeeded: Cardinal;
  var Primitives3DTextureCoords: boolean);
type
  TChannel = (cRGB, cAlpha);
  TGLIntPerChannel = array [TChannel] of TGLint;
  TCombinePerChannel = TGLIntPerChannel;
  TArgPerChannel = array [TChannel] of Integer;
  TScalePerChannel = array [TChannel] of TGLfloat;
  TStringPerChannel = array [TChannel] of string;

  { Simple type constructors, for ease of coding.
    Versions with only 1 argument set both channel (rgb and alpha) to the same. }
  function CombinePerChannel(const RGB, Alpha: TGLint): TCombinePerChannel;
  begin
    Result[cRGB] := RGB;
    Result[cAlpha] := Alpha;
  end;

  function CombinePerChannel(const Value: TGLint): TCombinePerChannel;
  begin
    Result := CombinePerChannel(Value, Value);
  end;

  function ArgPerChannel(const RGB, Alpha: Integer): TArgPerChannel;
  begin
    Result[cRGB] := RGB;
    Result[cAlpha] := Alpha;
  end;

  function ArgPerChannel(const Value: Integer): TArgPerChannel;
  begin
    Result := ArgPerChannel(Value, Value);
  end;

  function ScalePerChannel(const RGB, Alpha: TGLfloat): TScalePerChannel;
  begin
    Result[cRGB] := RGB;
    Result[cAlpha] := Alpha;
  end;

  function ScalePerChannel(const Value: TGLfloat): TScalePerChannel;
  begin
    Result := ScalePerChannel(Value, Value);
  end;

  { If S contains two separate modes (one for RGB, one for Alpha)
    returns @true and sets PerChannel to these separate strings.
    Strings returned in PerChannel will not contain the separator
    (slash, comma), and will not contain whitespace. }
  function SplitStringPerChannel(const S: string;
    out PerChannel: TStringPerChannel): boolean;
  var
    P: Integer;
  begin
    P := CharsPos(['/', ','], S);
    Result := P > 0;
    if Result then
    begin
      PerChannel[cRGB] := Trim(Copy(S, 1, P - 1));
      PerChannel[cAlpha] := Trim(SEnding(S, P + 1));
    end;
  end;

  { Return OpenGL values for
    GL_COMBINE_RGB_EXT, GL_COMBINE_ALPHA_EXT.

    Also, specify which argument (0, 1, 2 for
    GL_SOURCE0, GL_SOURCE1, GL_SOURCE2, or -1 if none) should represent
    current texture unit (this is "Arg1" in X3D spec wording),
    and which is the source (default is previous texture unit,
    although may change by "source" field; this is "Arg2" in X3D spec).

    You can assign here explicitly sources/operands for other
    arguments, if needed (e.g. "BLEND*" modes fill here 3rd source/operand
    directly).

    Also, specify Scale (remember OpenGL allows
    only 1.0, 2.0 and 4.0 scales). By default are 1. }
  procedure ModeFromString(const S: string;
    out Combine: TCombinePerChannel;
    out Arg1: TArgPerChannel;
    out Arg2: TArgPerChannel;
    var Scale: TScalePerChannel;
    var AlreadyHandled: boolean;
    var NeedsConstantColor: boolean);

    { Interpret simple mode name (this is for sure only one mode,
      without any "/" and whitespaces). This handles only the simplest
      modes, that behave the same and are allowed separately for
      both RGB and alpha channel.

      LS passed here must already be lowercase.

      Scale passed here must be initially 1.0. }
    procedure SimpleModeFromString(
      const LS: string;
      out Combine: TGLint;
      out Arg1, Arg2: Integer;
      var Scale: TGLfloat;
      const Channels: string);
    begin
      if LS = 'modulate' then
      begin
        Combine := GL_MODULATE;
        Arg1 := 0;
        Arg2 := 1;
      end else
      if LS = 'modulate2x' then
      begin
        Combine := GL_MODULATE;
        Arg1 := 0;
        Arg2 := 1;
        Scale := 2;
      end else
      if LS = 'modulate4x' then
      begin
        Combine := GL_MODULATE;
        Arg1 := 0;
        Arg2 := 1;
        Scale := 4;
      end else
      if (LS = 'replace') or (LS = 'selectarg1') then
      begin
        { SELECTARG1 is exactly the same as REPLACE.

          Note: don't get confused by X3D spec saying in table 18.3 that
          "REPLACE" takes the Arg2, that's an error, it takes
          from Arg1 to be consistent with other spec words.
          I wrote some remarks about this on
          http://vrmlengine.sourceforge.net/vrml_implementation_status.php }

        Combine := GL_REPLACE;
        Arg1 := 0;
        Arg2 := -1;
      end else
      if LS = 'selectarg2' then
      begin
        Combine := GL_REPLACE;
        Arg1 := -1;
        Arg2 := 0;
      end else
      if LS = 'add' then
      begin
        Combine := GL_ADD;
        Arg1 := 0;
        Arg2 := 1;
      end else
      if LS = 'addsigned' then
      begin
        Combine := GL_ADD_SIGNED_EXT;
        Arg1 := 0;
        Arg2 := 1;
      end else
      if LS = 'addsigned2x' then
      begin
        Combine := GL_ADD_SIGNED_EXT;
        Arg1 := 0;
        Arg2 := 1;
        Scale := 2;
      end else
      if LS = 'subtract' then
      begin
        Combine := GL_SUBTRACT;
        Arg1 := 0;
        Arg2 := 1;
      end else
      begin
        Combine := GL_MODULATE;
        Arg1 := 0;
        Arg2 := 1;
        VRMLWarning(vwSerious, Format('Not supported multi-texturing mode "%s" for channels "%s"', [LS, Channels]));
      end;
    end;

    procedure RGBModeFromString(
      const LS: string;
      out Combine: TGLint;
      out Arg1, Arg2: Integer;
      var Scale: TGLfloat);
    begin
      if LS = 'dotproduct3' then
      begin
        { We use DOT3_RGB_ARB here.
          This means it will fill only RGB values.

          This is our extension (X3D spec allows only DOTPRODUCT3
          for both channels, and to fill them both, this case is handled
          in BothModesFromString). }
        Combine := GL_DOT3_RGB_ARB;
        Arg1 := 0;
        Arg2 := 1;
      end else
        SimpleModeFromString(LS, Combine, Arg1, Arg2, Scale, 'RGB');
    end;

    procedure AlphaModeFromString(
      const LS: string;
      out Combine: TGLint;
      out Arg1, Arg2: Integer;
      var Scale: TGLfloat);
    begin
      SimpleModeFromString(LS, Combine, Arg1, Arg2, Scale, 'Alpha');
    end;

    procedure BothModesFromString(
      const LS: string;
      out Combine: TCombinePerChannel;
      out Arg1, Arg2: TArgPerChannel;
      var Scale: TScalePerChannel);
    begin
      if LS = '' then
      begin
        { LS = '' means that mode list was too short.
          X3D spec says explicitly that default mode is "MODULATE"
          in this case. (Accidentaly, this also will accept
          explict "" string as "MODULATE" --- not a worry, we don't
          have to produce error messages for all possible invalid VRMLs...). }

        Combine := CombinePerChannel(GL_MODULATE);
        Arg1 := ArgPerChannel(0);
        Arg2 := ArgPerChannel(1);
      end else
      if LS = 'off' then
      begin
        { For OFF, turn off the texture unit? This is the correct
          interpretation, right? }
        TGLTextureNode.TextureEnableDisable(etOff);
        AlreadyHandled := true;
      end else
      if LS = 'dotproduct3' then
      begin
        { We use DOT3_RGBA_ARB, not DOT3_RGB_ARB.
          See [http://www.opengl.org/registry/specs/ARB/texture_env_dot3.txt].

          This means that the dot (done on only RGB channels) will
          be replicated to all four channels (RGBA). This is exactly what
          the X3D specification requires, so we're happy.
          Yes, this means that COMBINE_ALPHA_ARB will be ignored. }

        Combine := CombinePerChannel(GL_DOT3_RGBA_ARB,
          GL_REPLACE { <- whatever, alpha combine will be ignored });
        Arg1 := ArgPerChannel(0);
        Arg2 := ArgPerChannel(1);
      end else
      if LS = 'blenddiffusealpha' then
      begin
        Combine := CombinePerChannel(GL_INTERPOLATE_EXT);
        Arg1 := ArgPerChannel(0);
        Arg2 := ArgPerChannel(1);

        { Whole source2 (both RGB and alpha) is filled by alpha of material
          (primary color). }
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_RGB_EXT, GL_PRIMARY_COLOR_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_RGB_EXT, GL_SRC_ALPHA);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_ALPHA_EXT, GL_PRIMARY_COLOR_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_ALPHA_EXT, GL_SRC_ALPHA);
      end else
      if LS = 'blendtexturealpha' then
      begin
        Combine := CombinePerChannel(GL_INTERPOLATE_EXT);
        Arg1 := ArgPerChannel(0);
        Arg2 := ArgPerChannel(1);

        { Whole source2 (both RGB and alpha) is filled by alpha of current
          tex unit. }
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_RGB_EXT, GL_TEXTURE);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_RGB_EXT, GL_SRC_ALPHA);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_ALPHA_EXT, GL_TEXTURE);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_ALPHA_EXT, GL_SRC_ALPHA);
      end else
      if LS = 'blendfactoralpha' then
      begin
        Combine := CombinePerChannel(GL_INTERPOLATE_EXT);
        Arg1 := ArgPerChannel(0);
        Arg2 := ArgPerChannel(1);

        { Whole source2 (both RGB and alpha) is filled by const alpha. }
        NeedsConstantColor := true;
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_RGB_EXT, GL_CONSTANT_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_RGB_EXT, GL_SRC_ALPHA);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_ALPHA_EXT, GL_CONSTANT_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_ALPHA_EXT, GL_SRC_ALPHA);
      end else
      if LS = 'blendcurrentalpha' then
      begin
        Combine := CombinePerChannel(GL_INTERPOLATE_EXT);
        Arg1 := ArgPerChannel(0);
        Arg2 := ArgPerChannel(1);

        { Whole source2 (both RGB and alpha) is filled by alpha from prev tex. }
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_RGB_EXT, GL_PREVIOUS_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_RGB_EXT, GL_SRC_ALPHA);
        glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_ALPHA_EXT, GL_PREVIOUS_EXT);
        glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_ALPHA_EXT, GL_SRC_ALPHA);
      end else
      begin
        SimpleModeFromString(LS,
          Combine[cRGB], Arg1[cRGB], Arg2[cRGB], Scale[cRGB], 'both RGB and Alpha');
        Combine[cAlpha] := Combine[cRGB];
        Arg1   [cAlpha] := Arg1   [cRGB];
        Arg2   [cAlpha] := Arg2   [cRGB];
        Scale  [cAlpha] := Scale  [cRGB];
      end;
    end;

  var
    LS: string;
    StringPerChannel: TStringPerChannel;
  begin
    LS := LowerCase(S);
    if SplitStringPerChannel(LS, StringPerChannel) then
    begin
      RGBModeFromString(StringPerChannel[cRGB], Combine[cRGB], Arg1[cRGB], Arg2[cRGB], Scale[cRGB]);
      AlphaModeFromString(StringPerChannel[cAlpha], Combine[cAlpha], Arg1[cAlpha], Arg2[cAlpha], Scale[cAlpha]);
    end else
      BothModesFromString(LS, Combine, Arg1, Arg2, Scale);
  end;

  procedure SourceFromString(const S: string; out Source: TGLIntPerChannel;
    var NeedsConstantColor: boolean);

    procedure SimpleSourceFromString(const LS: string;
      out Source: TGLint;
      var NeedsConstantColor: boolean);
    begin
      if LS = '' then
        Source := GL_PREVIOUS_EXT else
      if (LS = 'diffuse') or (LS = 'specular') then
        Source := GL_PRIMARY_COLOR_EXT else
      if LS = 'factor' then
      begin
        NeedsConstantColor := true;
        Source := GL_CONSTANT_EXT;
      end else
      begin
        Source := GL_PREVIOUS_EXT;
        VRMLWarning(vwSerious, Format('Not supported multi-texturing source "%s"', [LS]))
      end;
    end;

  var
    LS: string;
    SourcePerChannel: TStringPerChannel;
  begin
    LS := LowerCase(S);
    if SplitStringPerChannel(LS, SourcePerChannel) then
    begin
      SimpleSourceFromString(SourcePerChannel[cRGB  ], Source[cRGB  ], NeedsConstantColor);
      SimpleSourceFromString(SourcePerChannel[cAlpha], Source[cAlpha], NeedsConstantColor);
    end else
    begin
      SimpleSourceFromString(LS, Source[cRGB], NeedsConstantColor);
      Source[cAlpha] := Source[cRGB];
    end;
  end;

  procedure DisableTexture(const TextureUnit: Cardinal);
  begin
    Renderer.ActiveTexture(TextureUnit);
    TGLTextureNode.TextureEnableDisable(etOff);
  end;

var
  ChildTex: TVRMLNode;
  I: Integer;
  Success: boolean;
  Combine: TCombinePerChannel;
  Arg1, Arg2: TArgPerChannel;
  Scale: TScalePerChannel;
  S: string;
  AlreadyHandled: boolean;
  NeedsConstantColor: boolean;
  Source: TGLIntPerChannel;
begin
  { calculate TexCoordsNeeded }
  TexCoordsNeeded := Min(TextureUnitsCount, TextureNode.FdTexture.Count);
  if not UseMultiTexturing then
    MinTo1st(TexCoordsNeeded, 1);

  for I := 0 to TexCoordsNeeded - 1 do
  begin
    ChildTex := TextureNode.FdTexture.Items.Items[I];
    Success := false;

    if (ChildTex <> nil) and
       (ChildTex is TNodeX3DTextureNode) then
    begin
      if ChildTex is TNodeMultiTexture then
        VRMLWarning(vwSerious, 'Child of MultiTexture node cannot be another MultiTexture node') else
        Success := Renderer.GLTextureNodes.Enable(TNodeX3DTextureNode(ChildTex),
          I, Primitives3DTextureCoords);

      if Success and UseMultiTexturing { needed OpenGL exts available } then
      begin
        { Set all the multitexture mode-related stuff.
          Below we handle TextureNode.mode, source, color, alpha,
          function fields. }

        AlreadyHandled := false;
        Scale[cRGB] := 1;
        Scale[cAlpha] := 1;
        NeedsConstantColor := false;

        if I < TextureNode.FdMode.Count then
          S := TextureNode.FdMode.Items[I] else
          S := '';

        ModeFromString(S, Combine, Arg1, Arg2,
          Scale, AlreadyHandled, NeedsConstantColor);

        if not AlreadyHandled then
        begin
          glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);

          glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, Combine[cRGB]);
          glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_EXT, Combine[cAlpha]);

          glTexEnvf(GL_TEXTURE_ENV, GL_RGB_SCALE_EXT, Scale[cRGB]);
          glTexEnvf(GL_TEXTURE_ENV, GL_ALPHA_SCALE, Scale[cAlpha]);

          { Set Arg1 as source.
            First argument is always current texture unit.
            (This is indicated by X3D spec wording
            "The source field determines the colour source for the second argument.") }

          if Arg1[cRGB] <> -1 then
          begin
            glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT + Arg1[cRGB], GL_TEXTURE);
            glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT + Arg1[cRGB], GL_SRC_COLOR);
          end;

          if Arg1[cAlpha] <> -1 then
          begin
            glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT + Arg1[cAlpha], GL_TEXTURE);
            glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT + Arg1[cAlpha], GL_SRC_ALPHA);
          end;

          if (Arg2[cRGB] <> -1) or (Arg2[cAlpha] <> -1) then
          begin
            if I < TextureNode.FdSource.Count then
              S := TextureNode.FdSource.Items[I] else
              S := '';

            SourceFromString(S, Source, NeedsConstantColor);

            if Arg2[cRGB] <> -1 then
            begin
              glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_EXT + Arg2[cRGB], Source[cRGB]);
              glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB_EXT + Arg2[cRGB], GL_SRC_COLOR);
            end;

            if Arg2[cAlpha] <> -1 then
            begin
              glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_EXT + Arg2[cAlpha], Source[cAlpha]);
              glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA_EXT + Arg2[cAlpha], GL_SRC_ALPHA);
            end;
          end;

          if NeedsConstantColor then
          begin
            { Assign constant color now, when we know it should be used. }
            glTexEnvv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, Vector4Single(
              TextureNode.FdColor.Value,
              TextureNode.FdAlpha.Value));
          end;
        end;
      end;
    end;

    if not Success then
      DisableTexture(I);
  end;
end;

{ TGLImageTextureNode -------------------------------------------------------- }

class function TGLImageTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  if ANode is TVRMLTextureNode then
  begin
    { You have to set Cache before using IsTextureImage. }
    TVRMLTextureNode(ANode).Cache := Cache;
    Result := TVRMLTextureNode(ANode).IsTextureImage;
  end else
    Result := false;
end;

function TGLImageTextureNode.TextureNode: TVRMLTextureNode;
begin
  Result := TVRMLTextureNode(inherited TextureNode);
end;

procedure TGLImageTextureNode.PrepareCore(State: TVRMLGraphTraverseState);
var
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  TextureWrap: TTextureWrap2D;
begin
  { HandledNode already made sure IsTextureImage = @true }

  HandleTexturePropertiesCore(TextureNode.TextureProperties,
    MinFilter, MagFilter, Anisotropy);

  TextureWrap[0] := TextureRepeatToGL(TextureNode.RepeatS);
  TextureWrap[1] := TextureRepeatToGL(TextureNode.RepeatT);

  SetTextureRGBFromImage(TextureNode.TextureImage);

  GLName := Renderer.Cache.TextureImage_IncReference(
    TextureNode.TextureImage,
    TextureNode.TextureUsedFullUrl,
    TextureNode,
    MinFilter,
    MagFilter,
    Anisotropy,
    TextureWrap,
    Renderer.Attributes.ColorModulatorByte,
    TextureNode.TextureDDS,
    { This way, our AlphaChannelType is calculated (or taken from cache)
      by TextureImage_IncReference }
    AlphaChannelType);
end;

procedure TGLImageTextureNode.Unprepare;
begin
  if GLName <> 0 then
  begin
    Renderer.Cache.TextureImage_DecReference(GLName);
    GLName := 0;
  end;
end;

function TGLImageTextureNode.Bind(const TextureUnit: Cardinal): boolean;
begin
  Result := GLName <> 0;
  if not Result then Exit;

  Renderer.ActiveTexture(TextureUnit);
  glBindTexture(GL_TEXTURE_2D, GLName);
end;

function TGLImageTextureNode.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  Result := Bind(TextureUnit);
  if not Result then Exit;

  TextureEnableDisable(et2D);
end;

{ TGLMovieTextureNode -------------------------------------------------------- }

class function TGLMovieTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  { Although for most code TGLMovieTextureNode, it would be enought
    to have any TVRMLTextureNode with IsTextureVideo = @true.
    For when rendering, we'll need some TNodeMovieTexture properties
    to choose video frame.

    Anyway, TNodeMovieTexture is for now the only texture node possible
    that may have IsTextureVideo = @true, so it's not a real problem for now. }

  if ANode is TNodeMovieTexture then
  begin
    { You have to set Cache before using IsTextureImage. }
    TNodeMovieTexture(ANode).Cache := Cache;
    Result := TNodeMovieTexture(ANode).IsTextureVideo;
  end else
    Result := false;
end;

function TGLMovieTextureNode.TextureNode: TNodeMovieTexture;
begin
  Result := TNodeMovieTexture(inherited TextureNode);
end;

procedure TGLMovieTextureNode.PrepareCore(State: TVRMLGraphTraverseState);
var
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  TextureWrap: TTextureWrap2D;
begin
  { HandledNode already made sure IsTextureVideo = @true }

  HandleTexturePropertiesCore(TextureNode.TextureProperties,
    MinFilter, MagFilter, Anisotropy);

  TextureWrap[0] := TextureRepeatToGL(TextureNode.RepeatS);
  TextureWrap[1] := TextureRepeatToGL(TextureNode.RepeatT);

  SetTextureRGBFromImage(TextureNode.TextureVideo.Items[0]);

  GLVideo := Renderer.Cache.TextureVideo_IncReference(
    TextureNode.TextureVideo,
    TextureNode.TextureUsedFullUrl,
    TextureNode,
    MinFilter,
    MagFilter,
    Anisotropy,
    TextureWrap,
    Renderer.Attributes.ColorModulatorByte,
    { This way, our AlphaChannelType is calculated (or taken from cache)
      by TextureVideo_IncReference }
    AlphaChannelType);
end;

procedure TGLMovieTextureNode.Unprepare;
begin
  if GLVideo <> nil then
    Renderer.Cache.TextureVideo_DecReference(GLVideo);
end;

function TGLMovieTextureNode.Bind(const TextureUnit: Cardinal): boolean;
var
  VideoTime: TKamTime;
begin
  { Note: don't call IsTextureImage, IsTextureVideo here --- this
    would cause reloading images/videos, nullifying
    TVRMLScene.FreeResources([frTextureDataInNodes]) purpose.

    Actually, it would be safe to call this for non-MovieTexture nodes,
    as they should be prepared to display lists before doing
    FreeResources. But for MovieTexture nodes it's forbidden,
    as it's called at every frame render. }

  Result := GLVideo <> nil;
  if not Result then Exit;

  VideoTime := TextureNode.TimeDependentNodeHandler.ElapsedTime *
               TextureNode.FdSpeed.Value;
  if TextureNode.FdSpeed.Value < 0 then
    VideoTime := TextureNode.Duration + VideoTime;

  Renderer.ActiveTexture(TextureUnit);
  glBindTexture(GL_TEXTURE_2D, GLVideo.GLTextureFromTime(VideoTime));
end;

function TGLMovieTextureNode.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  Result := Bind(TextureUnit);
  if not Result then Exit;

  TextureEnableDisable(et2D);
end;

{ TGLRenderedTextureNode ----------------------------------------------------- }

class function TGLRenderedTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeRenderedTexture;
end;

function TGLRenderedTextureNode.TextureNode: TNodeRenderedTexture;
begin
  Result := TNodeRenderedTexture(inherited TextureNode);
end;

procedure TGLRenderedTextureNode.PrepareCore(State: TVRMLGraphTraverseState);
var
  InitialImage: TImage;
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  TextureWrap: TTextureWrap2D;
  NodeWidth, NodeHeight: Cardinal;
begin
  HandleTextureProperties(TextureNode.FdTextureProperties.Value,
    MinFilter, MagFilter, Anisotropy);

  { calculate MinFilter, MagFilter, Anisotropy, NeedsMipmaps }
  NeedsMipmaps := TextureMinFilterNeedsMipmaps(MinFilter);
  if NeedsMipmaps and not HasGenerateMipmap then
  begin
    VRMLWarning(vwIgnorable { This may be caused by OpenGL implementation
      limits, so it may be impossible to predict by VRML author,
      so it's "ignorable" warning. },
      'OpenGL implementation doesn''t allow any glGenerateMipmap* version, so you cannot use mipmaps for RenderedTexture');
    MinFilter := GL_LINEAR;
    NeedsMipmaps := false;
  end;

  TextureWrap[0] := TextureRepeatToGL(TextureNode.FdRepeatS.Value);
  TextureWrap[1] := TextureRepeatToGL(TextureNode.FdRepeatT.Value);

  { calculate Width, Height }
  if TextureNode.FdDimensions.Items.High >= 0 then
    NodeWidth := Max(TextureNode.FdDimensions.Items[0], 0) else
    NodeWidth := DefaultRenderedTextureWidth;
  if TextureNode.FdDimensions.Items.High >= 1 then
    NodeHeight := Max(TextureNode.FdDimensions.Items[1], 0) else
    NodeHeight := DefaultRenderedTextureHeight;
  Width  := NodeWidth ;
  Height := NodeHeight;
  if not IsTextureSized(Width, Height) then
  begin
    ResizeToTextureSize(Width, Height);
    VRMLWarning(vwIgnorable { This may be caused by OpenGL implementation
      limits, so it may be impossible to predict by VRML author,
      so it's "ignorable" warning. },
      Format('Rendered texture size %d x %d is incorrect (texture size must be a power of two, > 0 and <= GL_MAX_TEXTURE_SIZE = %d), corrected to %d x %d',
        [ NodeWidth, NodeHeight,
          GLMaxTextureSize,
          Width, Height]));
  end;

  { calculate DepthMap }
  if TextureNode.FdDepthMap.Count > 0 then
    DepthMap := TextureNode.FdDepthMap.Items[0] else
    DepthMap := false;

  if DepthMap then
  begin
    if not GL_ARB_depth_texture then
    begin
      VRMLWarning(vwSerious, 'Your OpenGL doesn''t support ARB_depth_texture, cannot use RenderedTexture with depthMap = TRUE');
      Exit;
    end;

    GLName := Renderer.Cache.TextureDepth_IncReference(
      TextureNode, TextureWrap, nil, Width, Height);
  end else
  begin
    InitialImage := TRGBImage.Create(Width, Height);
    try
      SetTextureRGBFromImage(InitialImage);

      { Fill with deliberately stupid (but constant) color,
        to recognize easily RenderedTexture which don't have textures
        updated. }
      InitialImage.Clear(Vector4Byte(255, 0, 255, 255));

      GLName := Renderer.Cache.TextureImage_IncReference(
        InitialImage,
        '',
        TextureNode,
        MinFilter,
        MagFilter,
        Anisotropy,
        TextureWrap,
        Renderer.Attributes.ColorModulatorByte,
        nil,
        { This way, our AlphaChannelType is calculated (or taken from cache)
          by TextureImage_IncReference }
        AlphaChannelType);

      { RenderedTexture never has any normal / height map
        (Hm, although it would be possible to generate some in theory
        --- after all, we generate it from 3D data. Idea for the future.)
      NormalMap := 0;
      HeightMap := 0;
      }
    finally FreeAndNil(InitialImage) end;
  end;

  RenderToTexture := TGLRenderToTexture.Create(Width, Height);
  RenderToTexture.SetTexture(GLName, GL_TEXTURE_2D);
  RenderToTexture.DepthTexture := DepthMap;
  RenderToTexture.Stencil := not DepthMap;
  RenderToTexture.GLContextInit;
end;

procedure TGLRenderedTextureNode.Unprepare;
begin
  FreeAndNil(RenderToTexture);

  if GLName <> 0 then
  begin
    if DepthMap then
      Renderer.Cache.TextureDepth_DecReference(GLName) else
      Renderer.Cache.TextureImage_DecReference(GLName);
    GLName := 0;
  end;
end;

function TGLRenderedTextureNode.Bind(const TextureUnit: Cardinal): boolean;
begin
  Result := GLName <> 0;
  if not Result then Exit;

  Renderer.ActiveTexture(TextureUnit);
  glBindTexture(GL_TEXTURE_2D, GLName);
end;

function TGLRenderedTextureNode.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  Result := Bind(TextureUnit);
  if not Result then Exit;

  TextureEnableDisable(et2D);
end;

procedure TGLRenderedTextureNode.Update(
  const Render: TRenderFromViewFunction;
  const ProjectionNear, ProjectionFar: Single;
  var NeedsRestoreViewport: boolean;
  CurrentViewpoint: TVRMLViewpointNode;
  IsLastViewer: boolean;
  const LastViewerPosition, LastViewerDirection, LastViewerUp: TVector3Single);

var
  Viewpoint: TVRMLViewpointNode;

  function GetProjectionMatrix: TMatrix4Single;
  { This somewhat follows the logic similar to TVRMLGLScene.GLProjectionCore:
    we have to calculate projection, given Viewpoint node.

    We have to calculate things a little differently, e.g. we have
    no NavigationInfo (it would be bad to use scene bound NavigationInfo,
    since VRML author cannot change it by any RenderedTexture field,
    and adding such field could be too much...),
    no knowledge of scene box (although we do have ProjectionNear / Far
    already).
  }

    procedure DoPerspective;
    var
      FieldOfView: Single;
      AngleOfViewX, AngleOfViewY: Single;
    begin
      if (Viewpoint <> nil) and
         (Viewpoint is TNodeViewpoint) then
        FieldOfView := TNodeViewpoint(Viewpoint).FdFieldOfView.Value else
        FieldOfView := DefaultViewpointFieldOfView;

      AngleOfViewX := RadToDeg(TNodeViewpoint.ViewpointAngleOfView(
        FieldOfView, Width / Height));

      AngleOfViewY := AdjustViewAngleDegToAspectRatio(
        AngleOfViewX, Height / Width);

      Result := PerspectiveProjMatrixDeg(AngleOfViewY, Width / Height,
        ProjectionNear, ProjectionFar);
    end;

    procedure DoOrthographic;
    var
      FieldOfView: TDynSingleArray;
      Left, Right, Bottom, Top: Single;
    begin
      { default left / right / bottom / top }
      Left   := -1;
      Right  :=  1;
      Bottom := -1;
      Top    :=  1;

      { update left / right / bottom / top using OrthoViewpoint.fieldOfView }
      if (Viewpoint <> nil) and
         (Viewpoint is TNodeOrthoViewpoint) then
      begin
        FieldOfView := TNodeOrthoViewpoint(Viewpoint).FdFieldOfView.Items;
        { Beware: order of OrthoViewpoint.fieldOfView is different
          than typical OpenGL and our ProjectionGLOrtho. }
        if FieldOfView.High >= 0 then Left   := FieldOfView.Items[0];
        if FieldOfView.High >= 1 then Bottom := FieldOfView.Items[1];
        if FieldOfView.High >= 2 then Right  := FieldOfView.Items[2];
        if FieldOfView.High >= 3 then Top    := FieldOfView.Items[3];
      end;

      Result := OrthoProjMatrix(Left, Right, Bottom, Top,
        ProjectionNear, ProjectionFar);
    end;

  var
    ProjectionType: TProjectionType;
  begin
    if Viewpoint <> nil then
      ProjectionType := Viewpoint.ProjectionType else
      ProjectionType := ptPerspective;

    case ProjectionType of
      ptPerspective: DoPerspective;
      ptOrthographic: DoOrthographic;
      else EInternalError.Create('TGLRenderedTextureNode.Update-ProjectionType?');
    end;
  end;

  procedure GetRenderedTextureCamera(out Pos, Dir, Up: TVector3Single);
  var
    { It's returned by Viewpoint.GetCameraVectors, but we'll ignore it. }
    GravityUp: TVector3Single;

    procedure GetFromCurrent;
    begin
      if IsLastViewer then
      begin
        Pos := LastViewerPosition;
        Dir := LastViewerDirection;
        Up  := LastViewerUp;
      end else
      if CurrentViewpoint <> nil then
        CurrentViewpoint.GetCameraVectors(Pos, Dir, Up, GravityUp) else
      begin
        { If all else fails (no viewpoint node bound, not known current
          camera seetings) use defaults. }
        Pos := DefaultVRMLCameraPosition[2];
        Dir := DefaultVRMLCameraDirection;
        Up  := DefaultVRMLCameraUp;
      end;
    end;

  begin
    if Viewpoint = CurrentViewpoint then
      GetFromCurrent else
    begin
      { Viewpoint gets assigned something different than CurrentViewpoint
        only when it's non-nil. }
      Assert(Viewpoint <> nil);
      Viewpoint.GetCameraVectors(Pos, Dir, Up, GravityUp);
    end;
  end;

var
  ProjectionMatrix: TMatrix4Single;
  Pos, Dir, Up: TVector3Single;
begin
  if GLName = 0 then Exit;

  { calculate Viewpoint }
  if (TextureNode.FdViewpoint.Value <> nil) and
     (TextureNode.FdViewpoint.Value is TVRMLViewpointNode) then
    Viewpoint := TVRMLViewpointNode(TextureNode.FdViewpoint.Value) else
    Viewpoint := CurrentViewpoint;

  ProjectionMatrix := GetProjectionMatrix;

  GetRenderedTextureCamera(Pos, Dir, Up);

  RenderState.Target := rfOffScreen;
  RenderState.CameraFromMatrix(
    LookDirMatrix(Pos, Dir, Up),
    LookDirMatrix(ZeroVector3Single, Dir, Up),
    ProjectionMatrix);

  RenderToTexture.RenderBegin;

    glViewport(0, 0, Width, Height);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix;
      glLoadMatrix(ProjectionMatrix);
      glMatrixMode(GL_MODELVIEW);
      Render;
      glMatrixMode(GL_PROJECTION);
    glPopMatrix;
    glMatrixMode(GL_MODELVIEW);

  RenderToTexture.RenderEnd;

  { depth maps (created by TextureDepth_IncReference, with GL_DEPTH_COMPONENT)
    cannot have mipmaps regenerated. On Mesa 7.6 (ubuntu 10.4, Mesa DRI Intel
    on "domek") glGenerateMipmapEXT even causes "invalid operation" OpenGL
    error (test e.g. view3dscene on rendered_texture.x3dv). }
  if NeedsMipmaps and (not DepthMap) then
    RenderToTexture.GenerateMipmap;

  NeedsRestoreViewport := true;
end;

{ TGLCubeMapTextureNode ------------------------------------------------------ }

function TGLCubeMapTextureNode.TextureNode: TNodeX3DEnvironmentTextureNode;
begin
  Result := TNodeX3DEnvironmentTextureNode(inherited TextureNode);
end;

procedure TGLCubeMapTextureNode.Unprepare;
begin
  if GLName <> 0 then
  begin
    Renderer.Cache.TextureCubeMap_DecReference(GLName);
    GLName := 0;
  end;
end;

function TGLCubeMapTextureNode.Bind(const TextureUnit: Cardinal): boolean;
begin
  Result := GLName <> 0;
  if not Result then Exit;

  Renderer.ActiveTexture(TextureUnit);
  glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, GLName);
end;

function TGLCubeMapTextureNode.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  Result := Bind(TextureUnit);
  if not Result then Exit;

  TextureEnableDisable(etCubeMap);
end;

{ TGLComposedCubeMapTextureNode ---------------------------------------------- }

class function TGLComposedCubeMapTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeComposedCubeMapTexture;
end;

function TGLComposedCubeMapTextureNode.TextureNode: TNodeComposedCubeMapTexture;
begin
  Result := TNodeComposedCubeMapTexture(inherited TextureNode);
end;

procedure TGLComposedCubeMapTextureNode.PrepareCore(State: TVRMLGraphTraverseState);

  { Checks is given side has non-nil valid node class,
    and then if image there can be loaded. }
  function SideLoaded(SideField: TSFNode): boolean;
  var
    SideTex: TVRMLTextureNode;
  begin
    Result :=
      (SideField.Value <> nil) and
      (SideField.Value is TVRMLTextureNode);
    if Result then
    begin
      SideTex := TVRMLTextureNode(SideField.Value);
      SideTex.Cache := Renderer.Cache;
      Result := SideTex.IsTextureImage;

      if Result and not (SideTex.TextureImage is TImage) then
      begin
        VRMLWarning(vwIgnorable, 'ComposedCubeMapTexture cannot contain S3TC images, as we have to rotate images within, and we cannot do this (fast) with compressed textures');
        Result := false;
      end;
    end;
  end;

var
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  BackRot, FrontRot, LeftRot, RightRot: TImage;
begin
  if not GL_ARB_texture_cube_map then
  begin
    VRMLWarning(vwSerious, 'Your OpenGL doesn''t support ARB_texture_cube_map, cannot use CubeMapTexture');
    Exit;
  end;

  if not (SideLoaded(TextureNode.FdBack) and
     SideLoaded(TextureNode.FdBottom) and
     SideLoaded(TextureNode.FdFront) and
     SideLoaded(TextureNode.FdLeft) and
     SideLoaded(TextureNode.FdRight) and
     SideLoaded(TextureNode.FdTop)) then
  begin
    VRMLWarning(vwSerious, 'Not all sides of a CubeMapTexture are correctly set and loaded, cannot use cube map');
    Exit;
  end;

  HandleTextureProperties(TextureNode.FdTextureProperties.Value,
    MinFilter, MagFilter, Anisotropy);

  try
    { To match expected orientation for OpenGL, we have to rotate images.
      (source images are oriented as for VRML Background.)
      We safely cast them to TImage below, SideLoaded above checked
      that they are indeed of TImage class. }
    BackRot  := (TVRMLTextureNode(TextureNode.FdBack .Value).TextureImage as TImage).MakeRotated(2);
    FrontRot := (TVRMLTextureNode(TextureNode.FdFront.Value).TextureImage as TImage).MakeRotated(2);
    LeftRot  := (TVRMLTextureNode(TextureNode.FdLeft .Value).TextureImage as TImage).MakeRotated(2);
    RightRot := (TVRMLTextureNode(TextureNode.FdRight.Value).TextureImage as TImage).MakeRotated(2);

    SetTextureRGBFromImage(RightRot);

    GLName := Renderer.Cache.TextureCubeMap_IncReference(
      TextureNode,
      MinFilter, MagFilter, Anisotropy,
      { positive x } RightRot,
      { negative x } LeftRot,
      { positive y } TVRMLTextureNode(TextureNode.FdTop   .Value).TextureImage as TImage,
      { negative y } TVRMLTextureNode(TextureNode.FdBottom.Value).TextureImage as TImage,
      { positive z } BackRot,
      { negative z } FrontRot,
      nil,
      AlphaChannelType);
  finally
    FreeAndNil(BackRot);
    FreeAndNil(FrontRot);
    FreeAndNil(LeftRot);
    FreeAndNil(RightRot);
  end;
end;

{ TGLImageCubeMapTextureNode ------------------------------------------------- }

class function TGLImageCubeMapTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeImageCubeMapTexture;
end;

function TGLImageCubeMapTextureNode.TextureNode: TNodeImageCubeMapTexture;
begin
  Result := TNodeImageCubeMapTexture(inherited TextureNode);
end;

procedure TGLImageCubeMapTextureNode.PrepareCore(State: TVRMLGraphTraverseState);
var
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  DDS: TDDSImage;
begin
  if not GL_ARB_texture_cube_map then
  begin
    VRMLWarning(vwSerious, 'Your OpenGL doesn''t support ARB_texture_cube_map, cannot use CubeMapTexture');
    Exit;
  end;

  DDS := TextureNode.LoadImage;
  { If TextureNode doesn't contain anything useful, just exit.
    TextureNode.LoadImage already did necessary VRMLWarnings. }
  if DDS = nil then Exit;

  try

    HandleTextureProperties(TextureNode.FdTextureProperties.Value,
      MinFilter, MagFilter, Anisotropy);

    { TODO: this is a quick and dirty method:
      - We call LoadImage each time, while load calls should
        be minimized (to avoid loading image many times, but also
        to avoid making repeated warnings in case image fails).
        Should be cached, like for 2D texture nodes.
      - We do not use cube map mipmaps stored inside DDS file.
    }

    SetTextureRGBFromImage(DDS.CubeMapImage(dcsPositiveX));

    GLName := Renderer.Cache.TextureCubeMap_IncReference(
      TextureNode,
      MinFilter, MagFilter, Anisotropy,
      DDS.CubeMapImage(dcsPositiveX),
      DDS.CubeMapImage(dcsNegativeX),
      { Swap meaning of positive/negative Y faces from DDS,
        see TDDSCubeMapSide for explanation. }
      DDS.CubeMapImage(dcsNegativeY),
      DDS.CubeMapImage(dcsPositiveY),
      DDS.CubeMapImage(dcsPositiveZ),
      DDS.CubeMapImage(dcsNegativeZ),
      DDS,
      AlphaChannelType);
  finally FreeAndNil(DDS); end;
end;

{ TGLGeneratedCubeMapTextureNode --------------------------------------------- }

class function TGLGeneratedCubeMapTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeGeneratedCubeMapTexture;
end;

function TGLGeneratedCubeMapTextureNode.TextureNode: TNodeGeneratedCubeMapTexture;
begin
  Result := TNodeGeneratedCubeMapTexture(inherited TextureNode);
end;

procedure TGLGeneratedCubeMapTextureNode.PrepareCore(State: TVRMLGraphTraverseState);
var
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  InitialImage: TImage;
begin
  if not GL_ARB_texture_cube_map then
  begin
    VRMLWarning(vwSerious, 'Your OpenGL doesn''t support ARB_texture_cube_map, cannot use CubeMapTexture');
    Exit;
  end;

  HandleTextureProperties(TextureNode.FdTextureProperties.Value,
    MinFilter, MagFilter, Anisotropy);

  { calculate MinFilter, MagFilter, Anisotropy, NeedsMipmaps }
  NeedsMipmaps := TextureMinFilterNeedsMipmaps(MinFilter);
  if NeedsMipmaps and not HasGenerateMipmap then
  begin
    VRMLWarning(vwIgnorable { This may be caused by OpenGL implementation
      limits, so it may be impossible to predict by VRML author,
      so it's "ignorable" warning. },
      'OpenGL implementation doesn''t allow any glGenerateMipmap* version, so you cannot use mipmaps for GeneratedCubeMapTexture');
    MinFilter := GL_LINEAR;
    NeedsMipmaps := false;
  end;

  { calculate Size }
  Size := Max(TextureNode.FdSize.Value, 0);
  if not IsCubeMapTextureSized(Size) then
  begin
    Size := ResizeToCubeMapTextureSize(Size);
    VRMLWarning(vwIgnorable { This may be caused by OpenGL implementation
      limits, so it may be impossible to predict by VRML author,
      so it's "ignorable" warning. },
      Format('Cube map texture size %d is incorrect (cube map texture size must be a power of two, > 0 and <= GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = %d), corrected to %d',
        [ TextureNode.FdSize.Value,
          GLMaxCubeMapTextureSizeARB,
          Size]));
  end;

  InitialImage := TRGBImage.Create(Size, Size);
  try
    { Fill with deliberately stupid (but constant) color,
      to recognize easily GeneratedCubeMapTexture which don't have textures
      updated. }
    InitialImage.Clear(Vector4Byte(255, 0, 255, 255));

    SetTextureRGBFromImage(InitialImage);

    GLName := Renderer.Cache.TextureCubeMap_IncReference(
      TextureNode,
      MinFilter, MagFilter, Anisotropy,
      InitialImage, InitialImage,
      InitialImage, InitialImage,
      InitialImage, InitialImage,
      nil,
      AlphaChannelType);
  finally FreeAndNil(InitialImage) end;

  RenderToTexture := TGLRenderToTexture.Create(Size, Size);
  RenderToTexture.SetTexture(GLName, GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB);
  RenderToTexture.GLContextInit;

  { Workaround for NVidia GeForce FX 5200 bug:
    (Confirmed it's needed on Linux, both 32 and 64bit, Kambi's "kocury".
     Confirmed it's *not* needed on Radeon (Linux 32bit, fglrx, Kambi's chantal).)

    Although TextureCubeMap_IncReference (glTextureCubeMap inside) already
    called initial GenerateMipmap (for our InitialImage), it's not enough.
    It seems that assigning texture to FBO destroys it's mipmaps (at least
    their contents).
    So you have to call GenerateMipmap *after* RenderToTexture.GLContextInit
    before showing this texture, to recreate mipmaps.

    To see bug, comment below, and run view3scene on
    kambi_vrml_test_suite/x3d/cubemap_generated_recursive.x3dv
    Before pressing [space] (which triggers Update method), teapots
    (or any other objects, reproducible with various IndexedFaceSets)
    will have seemingly random mipmaps (base level 0 is Ok, RGB(255,0,255),
    but mipmaps are seemingly filled with random garbage).
    Line below fixes it at negligible cost (we'll generate mipmaps at loading
    one more time than necessary). Other fix that works is to move
    RenderToTexture.GLContextInit to first Update call, but this obfuscates code. }
  if GLVersion.VendorNvidia and NeedsMipmaps then
  begin
    RenderToTexture.CompleteTextureTarget := GL_TEXTURE_CUBE_MAP_ARB;
    RenderToTexture.GenerateMipmap;
  end;
end;

procedure TGLGeneratedCubeMapTextureNode.Unprepare;
begin
  FreeAndNil(RenderToTexture);
  inherited;
end;

procedure TGLGeneratedCubeMapTextureNode.Update(
  const Render: TRenderFromViewFunction;
  const ProjectionNear, ProjectionFar: Single;
  var NeedsRestoreViewport: boolean;
  const CubeMiddle: TVector3Single);
begin
  if GLName = 0 then Exit;

  GLCaptureCubeMapTexture(GLName, Size,
    CubeMiddle,
    Render, ProjectionNear, ProjectionFar,
    RenderToTexture);

  if NeedsMipmaps then
    RenderToTexture.GenerateMipmap;

  NeedsRestoreViewport := true;
end;

{ TGL3DTextureNode ----------------------------------------------------------- }

class function TGL3DTextureNode.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeX3DTexture3DNode;
end;

function TGL3DTextureNode.TextureNode: TNodeX3DTexture3DNode;
begin
  Result := TNodeX3DTexture3DNode(inherited TextureNode);
end;

procedure TGL3DTextureNode.PrepareCore(State: TVRMLGraphTraverseState);
var
  MinFilter, MagFilter: TGLint;
  Anisotropy: TGLfloat;
  TextureWrap: TTextureWrap3D;
begin
  if not GL_EXT_texture3D then
  begin
    VRMLWarning(vwSerious, 'Your OpenGL doesn''t support EXT_texture3D, cannot use Texture3D nodes');
    Exit;
  end;

  TextureNode.Cache := Renderer.Cache;
  TextureNode.TextureLoaded := true;

  { If TextureImage doesn't contain anything useful, just exit.
    Setting TextureLoaded already did necessary VRMLWarnings. }
  if TextureNode.TextureImage = nil then Exit;

  HandleTextureProperties(TextureNode.FdTextureProperties.Value,
    MinFilter, MagFilter, Anisotropy);

  { calculate TextureWrap }
  TextureWrap[0] := TextureRepeatToGL(TextureNode.FdRepeatS.Value);
  TextureWrap[1] := TextureRepeatToGL(TextureNode.FdRepeatT.Value);
  TextureWrap[2] := TextureRepeatToGL(TextureNode.FdRepeatR.Value);

  SetTextureRGBFromImage(TextureNode.TextureImage);

  GLName := Renderer.Cache.Texture3D_IncReference(
    TextureNode, MinFilter, MagFilter, Anisotropy,
    TextureWrap, TextureNode.TextureImage, TextureNode.TextureDDS,
    AlphaChannelType);
end;

procedure TGL3DTextureNode.Unprepare;
begin
  if GLName <> 0 then
  begin
    Renderer.Cache.Texture3D_DecReference(GLName);
    GLName := 0;
  end;
end;

function TGL3DTextureNode.Bind(const TextureUnit: Cardinal): boolean;
begin
  Result := GLName <> 0;
  if not Result then Exit;

  Renderer.ActiveTexture(TextureUnit);
  glBindTexture(GL_TEXTURE_3D_EXT, GLName);
end;

function TGL3DTextureNode.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  Result := Bind(TextureUnit);
  if not Result then Exit;

  Primitives3DTextureCoords := true;

  TextureEnableDisable(et3D);
end;

{ TGLGeneratedShadowMap ------------------------------------------------------ }

class function TGLGeneratedShadowMap.IsClassForTextureNode(Cache: TTexturesImagesVideosCache;
  ANode: TNodeX3DTextureNode): boolean;
begin
  Result := ANode is TNodeGeneratedShadowMap;
end;

function TGLGeneratedShadowMap.TextureNode: TNodeGeneratedShadowMap;
begin
  Result := TNodeGeneratedShadowMap(inherited TextureNode);
end;

procedure TGLGeneratedShadowMap.PrepareCore(State: TVRMLGraphTraverseState);
var
  TextureWrap: TTextureWrap2D;
  MinFilter: TGLint;
begin
  VarianceShadowMaps := Renderer.Attributes.VarianceShadowMaps and
    (TGLSLProgram.ClassSupport <> gsNone) and
    (GL_ATI_texture_float or GL_ARB_texture_float);

  if Log then
    WritelnLog('Shadows', Format('Variance Shadow Maps used: %s (Reasons: Attributes.VarianceShadowMaps = %s, GLSL support = %s, ATI_texture_float = %s, ARB_texture_float = %s)',
      [ BoolToStr[VarianceShadowMaps],
        BoolToStr[Renderer.Attributes.VarianceShadowMaps],
        GLSupportNames[TGLSLProgram.ClassSupport],
        BoolToStr[GL_ATI_texture_float],
        BoolToStr[GL_ARB_texture_float] ]));

  { TODO: fix TextureNode.FdSize.Value if needed }
  Size := TextureNode.FdSize.Value;

  { In this case, clamp to border is Ok? TODO: test here }
  TextureWrap[0] := GL_CLAMP;
  TextureWrap[1] := GL_CLAMP;

  { calculate MinFilter, NeedsMipmaps }
  if VarianceShadowMaps and HasGenerateMipmap then
  begin
    NeedsMipmaps := true;
    MinFilter := GL_LINEAR_MIPMAP_LINEAR;
  end else
  begin
    NeedsMipmaps := false;
    MinFilter := GL_LINEAR;
  end;

  if VarianceShadowMaps then
  begin
    GLName := Renderer.Cache.TextureFloat_IncReference(
      TextureNode, MinFilter, GL_LINEAR, TextureWrap, Size, Size, true);

    VarianceShadowMapsProgram := TGLSLProgram.Create;
    VarianceShadowMapsProgram.AttachFragmentShader({$I variance_shadow_map_generate.fs.inc});
    VarianceShadowMapsProgram.Link(true);
  end else
  begin
    if not GL_ARB_depth_texture then
    begin
      VRMLWarning(vwSerious, 'Your OpenGL doesn''t support ARB_depth_texture, cannot use GeneratedShadowMap nodes');
      Exit;
    end;

    GLName := Renderer.Cache.TextureDepth_IncReference(
      TextureNode, TextureWrap, TextureNode.FdCompareMode, Size, Size);
  end;

  RenderToTexture := TGLRenderToTexture.Create(Size, Size);
  RenderToTexture.SetTexture(GLName, GL_TEXTURE_2D);
  RenderToTexture.DepthTexture := not VarianceShadowMaps;
  RenderToTexture.Stencil := false;
  RenderToTexture.GLContextInit;
end;

procedure TGLGeneratedShadowMap.Unprepare;
begin
  FreeAndNil(RenderToTexture);

  if GLName <> 0 then
  begin
    if VarianceShadowMaps then
      Renderer.Cache.TextureFloat_DecReference(GLName) else
      Renderer.Cache.TextureDepth_DecReference(GLName);
    GLName := 0;
  end;

  if VarianceShadowMapsProgram <> nil then
    FreeAndNil(VarianceShadowMapsProgram);
end;

function TGLGeneratedShadowMap.Bind(const TextureUnit: Cardinal): boolean;
begin
  Result := GLName <> 0;
  if not Result then Exit;

  Renderer.ActiveTexture(TextureUnit);
  glBindTexture(GL_TEXTURE_2D, GLName);
end;

function TGLGeneratedShadowMap.Enable(const TextureUnit: Cardinal;
  var Primitives3DTextureCoords: boolean): boolean;
begin
  Result := Bind(TextureUnit);
  if not Result then Exit;

  TextureEnableDisable(et2D);
end;

procedure TGLGeneratedShadowMap.Update(
  const Render: TRenderFromViewFunction;
  const ProjectionNear, ProjectionFar: Single;
  var NeedsRestoreViewport: boolean;
  Light: TNodeX3DLightNode);
var
  ProjectionMatrix: TMatrix4Single;
begin
  if GLName = 0 then Exit;

  { Render view for shadow map }
  ProjectionMatrix := Light.MapProjectionMatrix;

  if VarianceShadowMaps then
    RenderState.Target := rtVarianceShadowMap else
    RenderState.Target := rtShadowMap;

  RenderState.CameraFromMatrix(
    Light.MapModelviewMatrix,
    Light.MapModelviewRotationMatrix,
    ProjectionMatrix);

  RenderToTexture.RenderBegin;

    glViewport(0, 0, Size, Size);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix;
      glLoadMatrix(ProjectionMatrix);
      glMatrixMode(GL_MODELVIEW);

      glPushAttrib(GL_POLYGON_BIT);
        { enable polygon offset for everything (whole scene) }
        glEnable(GL_POLYGON_OFFSET_FILL); { saved by GL_POLYGON_BIT }
        glEnable(GL_POLYGON_OFFSET_LINE); { saved by GL_POLYGON_BIT }
        glEnable(GL_POLYGON_OFFSET_POINT); { saved by GL_POLYGON_BIT }
        glPolygonOffset(TextureNode.FdScale.Value, TextureNode.FdBias.Value); { saved by GL_POLYGON_BIT }

        if VarianceShadowMaps then VarianceShadowMapsProgram.Enable;
          Render;
        if VarianceShadowMaps then VarianceShadowMapsProgram.Disable;

      glPopAttrib;

      glMatrixMode(GL_PROJECTION);
    glPopMatrix;
    glMatrixMode(GL_MODELVIEW);

  RenderToTexture.RenderEnd;

  if NeedsMipmaps then
    RenderToTexture.GenerateMipmap;

  NeedsRestoreViewport := true;
end;

{$endif read_implementation}
