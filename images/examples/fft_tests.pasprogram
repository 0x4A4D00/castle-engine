{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple demo of operating on image in the frequency domain.
  Uses ImagesFftw unit (that uses FFTW library) to perform DFT and IDFT
  on the image.

  As $1 pass image file name.

  Practically, this is the solution for exercise 2 on
  http://www.ii.uni.wroc.pl/~anl/dyd/PO/ }
program fft_tests;

uses SysUtils, KambiUtils, Images, ImagesFftw, GLWindow, GL, GLImages,
  KambiTimeUtils, KambiStringUtils, Fftw_s, KambiGLUtils, Math;


var
  Alpha: Single = 0.5;

type
  TGLWindowImage = class(TGLWindowDemo)
  public
    destructor Destroy; override;

    Image: TRGBImage;
    ImageDL: TGLuint;
    procedure UpdateDL;
    procedure EventDraw; override;
    procedure EventInit; override;
  end;

destructor TGLWindowImage.Destroy;
begin
  FreeAndNil(Image);
  inherited;
end;

procedure TGLWindowImage.EventDraw;
begin
  inherited;
  glClear(GL_COLOR_BUFFER_BIT);
  glCallList(ImageDL);
end;

procedure TGLWindowImage.EventInit;
begin
  inherited;
  UpdateDL;
end;

procedure TGLWindowImage.UpdateDL;
begin
  MakeCurrent;
  glFreeDisplayList(ImageDL);
  ImageDL := ImageDrawToDisplayList(Image);
  PostRedisplay;
end;

var
  Source, Freq, Output: TGLWindowImage;
  Fft: TImageFftw;
  Operation: Integer;

{ Remake Freq.Image and Output.Image, using Fft }
procedure MakeFft;
var
  X, Y, Color: Integer;
  Ptr: Pcomplex_single;
  Tmp, Phi, R: Single;
begin
  Fft.Image := Source.Image;

  ProcessTimerBegin;
  Fft.DFT;
  Writeln('Making DFT: ', ProcessTimerEnd:1:2, ' secs');

  { Now perform the Operation on image in frequency domain.
    Lameness warning: yes, it's ultra lame to perform "case Operation..."
    check in every loop, but this allowed me to write this very shortly. }
  for Color := 0 to 2 do
  begin
    Ptr := Fft.ImageF[Color];
    for Y := 0 to Freq.Image.Height - 1 do
      for X := 0 to Freq.Image.Width - 1 do
      begin
        case Operation of
          1: Ptr^.Im := 0;
          2: Ptr^.Re := 0;
          3: begin Ptr^.Re := CMod(Ptr^); Ptr^.Im := 0; end;
          4: Ptr^ := CNormalized(Ptr^);
          5: Ptr^.Im := -Ptr^.Im;
          6: Ptr^.Re *= Alpha;
          7: begin
               Tmp := (Sqr(X {- Freq.Image.Width  div 2}) +
                       Sqr(Y {- Freq.Image.Height div 2})) / 100000.0;
               Ptr^.Re *= Tmp;
               Ptr^.Im *= Tmp;
             end;
          8: begin
               if (X {- Freq.Image.Width  div 2} > 25) or
                  (Y {- Freq.Image.Height div 2} > 25) then
               begin
                 Ptr^.Re := 0;
                 Ptr^.Im := 0;
               end;
             end;
          9: begin
               if (X {- Freq.Image.Width  div 2} <= 25) and
                  (Y {- Freq.Image.Height div 2} <= 25) then
               begin
                 Ptr^.Re := 0;
                 Ptr^.Im := 0;
               end;
             end;
          10:if Odd(X + Y) then
             begin
               Ptr^.Re := -Ptr^.Re;
               Ptr^.Im := -Ptr^.Im;
             end;
          11:begin
               R := Sqrt(Sqr(Ptr^.Re) + Sqr(Ptr^.Im));
               Phi := ArcTan2(Ptr^.Im, Ptr^.Re);

               Phi += Alpha;

               Ptr^.Re := R * Cos(Phi);
               Ptr^.Im := R * Sin(Phi);
             end;
        end;
        Inc(Ptr);
      end;
  end;

  Fft.ImageFModulusAsRGB(Freq.Image, 0.01);
  if not Freq.Closed then Freq.UpdateDL;

  Fft.Image := Output.Image;

  ProcessTimerBegin;
  Fft.IDFT;
  Writeln('Making IDFT: ', ProcessTimerEnd:1:2, ' secs');

  if not Output.Closed then Output.UpdateDL;
end;

procedure MenuCommand(glwin: TGLWindow; Item: TMenuItem);
begin
  case Item.IntData of
    10: Glwm.Quit;
    100..150:
      begin
        Operation := Item.IntData - 100;
        MakeFft;
      end;
    200:
      begin
        Alpha -= 0.1;
        MakeFft;
        Writeln('Alpha = ', Alpha:1:10);
      end;
    201:
      begin
        Alpha += 0.1;
        MakeFft;
        Writeln('Alpha = ', Alpha:1:10);
      end;
  end;
end;

function CreateMainMenu: TMenu;
var
  M: TMenu;
begin
  Result := TMenu.Create('Main menu');
  M := TMenu.Create('_File');
    M.Append(TMenuItem.Create('No operation'     , 100));
    M.Append(TMenuItem.Create('Only real'        , 101));
    M.Append(TMenuItem.Create('Only imaginary'   , 102));
    M.Append(TMenuItem.Create('Set to norm'      , 103));
    M.Append(TMenuItem.Create('Normalize'        , 104));
    M.Append(TMenuItem.Create('Conjugate'        , 105));
    M.Append(TMenuItem.Create('Re *= Alpha'      , 106));
    M.Append(TMenuItem.Create('Multiply by m^2+n^2'    , 107));
    M.Append(TMenuItem.Create('Zero outside the square', 108));
    M.Append(TMenuItem.Create('Zero inside the square' , 109));
    M.Append(TMenuItem.Create('Multiply by (-1)^(m+n)' , 110));
    M.Append(TMenuItem.Create('Phi += Alpha' , 111));
    { numbers up to ..150 are reserved for future testing operations }
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('Alpha -= 0.1' , 200, CtrlA));
    M.Append(TMenuItem.Create('Alpha += 0.1' , 201, CtrlD));
    M.Append(TMenuSeparator.Create);
    M.Append(TMenuItem.Create('_Quit', 10, CharEscape));
    Result.Append(M);
end;

begin
  Parameters.CheckHigh(1);
  try
    Source := TGLWindowImage.Create;
    Source.Image := LoadImage(Parameters[1], [TRGBImage], []) as TRGBImage;
    Source.Width  := Source.Image.Width ;
    Source.Height := Source.Image.Height;
    Source.Caption := 'Source image';
    Source.OnResize := @Resize2d;
    Source.Left := 10;
    Source.Top := 10;
    Source.Close_CharKey := #0;

    Freq := TGLWindowImage.Create;
    Freq.Image := TRGBImage.Create(Source.Image.Width, Source.Image.Height);
    Freq.Width  := Freq.Image.Width ;
    Freq.Height := Freq.Image.Height;
    Freq.Caption := 'Frequency domain - modulus';
    Freq.OnResize := @Resize2d;
    Freq.Left := 10;
    Freq.Top := Source.Top + Source.Height + 10;
    Freq.Close_CharKey := #0;

    Output := TGLWindowImage.Create;
    Output.Image := TRGBImage.Create(Source.Image.Width, Source.Image.Height);
    Output.Width  := Output.Image.Width ;
    Output.Height := Output.Image.Height;
    Output.Caption := 'Output image';
    Output.OnResize := @Resize2d;
    Output.Left := Source.Left + Source.Width + 10;
    Output.Top := Source.Top + Source.Height + 10;
    Output.Close_CharKey := #0;

    Output.MainMenu := CreateMainMenu;
    Output.OnMenuCommand := @MenuCommand;

    ProcessTimerBegin;
    Fft := TImageFftw.Create(Source.Image);
    Writeln('Creating FFTW plans for image with ', Fft.Size, ' pixels: ', ProcessTimerEnd:1:2, ' secs');
    MakeFft;

    Source.Init;
    Freq.Init;
    Output.Init;
    Glwm.Loop;
  finally
    FreeAndNil(Fft);

    FreeAndNil(Output);
    FreeAndNil(Freq);
    FreeAndNil(Source);
  end;
end.
