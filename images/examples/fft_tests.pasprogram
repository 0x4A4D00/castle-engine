{
  Copyright 2009 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ Simple demo of operating on image in the frequency domain.
  Uses ImagesFftw unit (that uses FFTW library) to perform DFT and IDFT
  on the image.

  As $1 pass image file name. }
program fft_tests;

uses SysUtils, KambiUtils, Images, ImagesFftw, GLWindow, GL, GLImages,
  KambiTimeUtils;

type
  TGLWindowImage = class(TGLWindowDemo)
  public
    destructor Destroy; override;

    Image: TRGBImage;
    ImageDL: TGLuint;
    procedure UpdateDL;
    procedure EventDraw; override;
    procedure EventInit; override;
  end;

destructor TGLWindowImage.Destroy;
begin
  FreeAndNil(Image);
  inherited;
end;

procedure TGLWindowImage.EventDraw;
begin
  inherited;
  glClear(GL_COLOR_BUFFER_BIT);
  glCallList(ImageDL);
end;

procedure TGLWindowImage.EventInit;
begin
  inherited;
  UpdateDL;
end;

procedure TGLWindowImage.UpdateDL;
begin
  ImageDL := ImageDrawToDisplayList(Image);
end;

var
  Source, Freq, Output: TGLWindowImage;
  Fft: TImageFftw;

{ Remake Freq.Image and Output.Image, using Fft }
procedure MakeFft;
begin
  Fft.Image := Source.Image;

  ProcessTimerBegin;
  Fft.DFT;
  Writeln('Making DFT: ', ProcessTimerEnd:1:2, ' secs');

  Fft.ImageFAsRGB(Freq.Image, 0.01);
  if not Freq.Closed then Freq.UpdateDL;

  Fft.Image := Output.Image;

  ProcessTimerBegin;
  Fft.IDFT;
  Writeln('Making IDFT: ', ProcessTimerEnd:1:2, ' secs');

  if not Output.Closed then Output.UpdateDL;
end;

begin
  Parameters.CheckHigh(1);
  try
    Source := TGLWindowImage.Create;
    Source.Image := LoadImage(Parameters[1], [TRGBImage], []) as TRGBImage;
    Source.Width  := Source.Image.Width ;
    Source.Height := Source.Image.Height;
    Source.Caption := 'Source image';
    Source.OnResize := @Resize2d;
    Source.Left := 10;
    Source.Top := 10;

    Freq := TGLWindowImage.Create;
    Freq.Image := TRGBImage.Create(Source.Image.Width, Source.Image.Height);
    Freq.Width  := Freq.Image.Width ;
    Freq.Height := Freq.Image.Height;
    Freq.Caption := 'Frequency domain';
    Freq.OnResize := @Resize2d;
    Freq.Left := 10;
    Freq.Top := Source.Top + Source.Height + 10;

    Output := TGLWindowImage.Create;
    Output.Image := TRGBImage.Create(Source.Image.Width, Source.Image.Height);
    Output.Width  := Output.Image.Width ;
    Output.Height := Output.Image.Height;
    Output.Caption := 'Output image';
    Output.OnResize := @Resize2d;
    Output.Left := Source.Left + Source.Width + 10;
    Output.Top := Source.Top + Source.Height + 10;

    ProcessTimerBegin;
    Fft := TImageFftw.Create(Source.Image);
    Writeln('Creating FFTW plans for image with ', Fft.Size, ' pixels: ', ProcessTimerEnd:1:2, ' secs');
    MakeFft;

    Source.Init;
    Freq.Init;
    Output.Init;
    Glwm.Loop;
  finally
    FreeAndNil(Fft);

    FreeAndNil(Output);
    FreeAndNil(Freq);
    FreeAndNil(Source);
  end;
end.
