TODO: This is just a plan for now.

Script castle-engine in this directory allows to compile a program
using our engine to various targets. Standalone (executable for
desktop Linux, Windows, Mac OS X etc.) or mobile (library with special
helper files for Android, iOS etc.).

If you're only interested in creating normal standalone executables,
then you don't need to be concerned with this script. You can, as always,
just write your games as normal programs (.lpr files), and compile them
as you're accustomed to --- using Lazarus or command-line FPC.

If you're interested in creating games for other targets (mobile
devices, also a browser plugin in the future), and especially if you're
interested in creating games that can be compiled into multiple targets
(one source code -> Linux, Windows, MacOSX, Android, iOS, browser plugin)
...then this script is for you. Motivation behind this script is that
various platforms require various loading code, some of them go to a "program",
some of them go to a "library", some of them require additional helper
files (like an AndroidManifest.xml) to actually compile them to a final program.

Usage is simple:

- You create your game as an Object Pascal unit that exposes a global variable
  "Window", that must descend from TCastleWindowCustom (is most cases,
  just use the TCastleWindow class).

  In the initialization section of your
  unit, create an instance of this class, and add there any callbacks
  you want --- OnCreate, OnOpen, OnUpdate etc., see the CastleWindow
  documentation. Your main game code will start there, you implement
  these callbacks (e.g. to load 3D scenes, setup 2D controls etc.).

  *Do not*:
  - Do not create any .lpi or .lpr files yourself. The castle-engine
    script will do it for you.

  - Do not call Window.Open or Window.Close. The main program/library
    generated by castle-engine will automatically take care of it.

  - Do not create more than one Window. Due to technical limitations,
    if you want your game to be truly portable to any device --- you
    have to limit yourself to using only one Window. For normal games
    that's probably natural anyway.

    The engine still supports, and will always support, multiple-window
    programs, but to make you will have to just write your own program code.
    See e.g. castle_game_engine/examples/window/multi_window.lpr example.
    There's no way to do it portably.

- To compile, enter the directory of your project and execute
    castle-engine generate <target>
    castle-engine build <target>

  Where <target> is
    standalone
      (Generate an xxx.lpr program file,
      compile a standalone executable using FPC.

      By default this compiles an executable for your current OS and processor,
      so if you're on 32-bit  Windows -> you will compile a 32-bit Windows binary, if you're on 64-bit
      Linux -> you will compile a 64-bit Linux binary and so on.
      But you can configure FPC to act as a cross-compiler (see FPC wiki)
      to compile to any other platform.
      The enviromnent variable CASTLE_FPC_OPTIONS, if set, will be used
      and may contain additional options you want to pass to compiler.)

    standalone --lazarus
      (Generate an xxx.lpr program file (like above),
      xxx.lpi Lazarus project file,
      compile a standalone executable using Lazarus (lazbuild must be on $PATH).

      This is exactly like above, but uses Lazarus. Useful especially
      if your project uses some Lazarus packages, e.g. Lazarus LCL --- it's best
      to compile then everything through Lazarus tools like lazbuild.)

    android
      (Generate xxx.lpr with a library file,
      compile using command-line FPC to a library libxxx.so,
      generate Android helper files inside android/ subdirectory,
      copy our library there,
      and use Android SDK toolchain ("android", "ant") to build an Android
      application (xxx.apk file))

    android --lazarus
      (Like above, but generates also a Lazarus project file xxx.lpi
      and compiles the same thing using Lazarus.)

- The most secure way of working is to never touch the generated files,
  do not commit them to version control systems (SVN, GIT),
  and clean them when needed by

    castle-engine clean-generate <target>
    castle-engine clean-build <target>

  If you really want to tweak them, then of course you can,
  and then you probably *want* to commit generated files to version control
  system and you probably *do not* want to call "clean-generate" action.
  The catch is that, if you tweak them, you will be responsible for updating
  them when new engine release will come out. We will try not to break
  compatibility for them, but it's too early to promise it right now.
  So just be prepared that, if you customize them, some day you may have to
  call "castle-engine generate <target>" again and re-apply your manual tweaks
  (if you use a version control system then it may actually be quite painless
  to investigate and re-apply the changes).
