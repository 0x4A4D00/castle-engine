TODO: This is just a plan for now.
TODO: expose TCastleWindow.OnCreate.

Script castle-engine in this directory allows to compile a program
using our engine to various targets. Standalone (executable for
desktop Linux, Windows, Mac OS X etc.) or mobile (library with special
helper files for Android, iOS etc.).

If you're only interested in creating normal standalone executables,
then you don't need to be concerned with this script. You can, as always,
just write your games as normal programs (.lpr files), and compile them
as you're accustomed to --- using Lazarus or command-line FPC.

If you're interested in creating games for other targets (mobile
devices, also a browser plugin in the future), and especially if you're
interested in creating games that can be compiled into multiple targets
(one source code -> Linux, Windows, MacOSX, Android, iOS, browser plugin)
...then this script is for you. Motivation behind this script is that
various platforms require various loading code, some of them go to a "program",
some of them go to a "library", some of them require additional helper
files (like an AndroidManifest.xml) to actually compile them to a final program.

Usage is simple:

- You create your game as an Object Pascal unit that exposes a global variable
  "Window", that must descend from TCastleWindowCustom (in most cases,
  just use the standard TCastleWindow class, although you can also derive
  your own descendants of it).

  In the initialization section of your
  unit, create an instance of this class, and add there any callbacks
  you want --- OnCreate, OnOpen, OnUpdate etc., see the CastleWindow
  documentation. Your main game code will start there, you implement
  these callbacks (e.g. to load 3D scenes, setup 2D controls etc.).

  Example:

  ----------------------------------------------------------------------------
  unit MyFantasticGame;
  interface
  uses CastleWindow;

  var
    Window: TCastleWindow;

  implementation

  var
    SampleImage: TCastleImageControl;
    SampleScene: TCastleScene;

  procedure ContextCreate(Sender: TCastleWindowBase);
  begin
    { 1-time initialization of resources, independent of OpenGL context. }

    Image := TCastleImageControl.Create(Window);
    Image.URL := ApplicationData('sample_texture.png');
    Window.Controls.InsertFront(Image);

    Scene := TCastleScene.Create(Application);
    Scene.Load('my_scene.x3d');
    Scene.Spatial := [ssRendering, ssDynamicCollisions];
    Scene.ProcessEvents := true;
    Window.SceneManager.Items.Add(Scene);
    Window.SceneManager.MainScene := Scene;
  end;

  procedure ContextOpen(Sender: TCastleWindowBase);
  begin
    { OpenGL context is created, initialize things that require OpenGL
      context. Often you do not need to use this callback (engine components will
      automatically create/release OpenGL resource when necessary),
      but sometimes it may be handy (e.g. TGLImage requires OpenGL context).

      You could also always derive new classes from TUIControl or it's descendants,
      and override their GLContextOpen / GLContextClose methods to react to
      context being open/closed.

      ContextOpen is always *after* ContextCreate.
      In normal circumstances, for a standalone game, the ContextOpen will
      happen only once. But for other targets, it may be necessary to close/reopen
      the OpenGL context many times, e.g. on mobile platforms it's normal
      that application may "loose" the OpenGL context and it may need
      to recreate OpenGL resources when it wakes up. }
  end;

  initialization
    Window := TCastleWindow.Create(Application);
    Window.OnCreate := @ContextCreate;
    Window.OnOpen := @ContextOpen;
  end.
  ----------------------------------------------------------------------------

  *Do not*:
  - Do not create any .lpi or .lpr files yourself. The castle-engine
    script will do it for you.

  - Do not call Window.Open or Window.Close or Application.Run.
    The main program/library
    generated by castle-engine will automatically take care of it.

  - Do not create more than one Window. Due to technical limitations,
    if you want your game to be truly portable to any device --- you
    have to limit yourself to using only one Window. For normal games
    that's probably natural anyway.

    The engine still supports, and will always support, multiple-window
    programs, but to make you will have to just write your own program code.
    See e.g. castle_game_engine/examples/window/multi_window.lpr example.
    There's no way to do it portably.

- To compile, enter the directory of your project and execute
    castle-engine generate MyFantasticGame <target>
    castle-engine build MyFantasticGame <target>

  Where <target> is
    standalone
      (Generate an xxx.lpr program file,
      compile a standalone executable using FPC.

      By default this compiles an executable for your current OS and processor,
      so if you're on 32-bit  Windows -> you will compile a 32-bit Windows binary, if you're on 64-bit
      Linux -> you will compile a 64-bit Linux binary and so on.
      But you can configure FPC to act as a cross-compiler (see FPC wiki)
      to compile to any other platform.
      The enviromnent variable CASTLE_FPC_OPTIONS, if set, will be used
      and may contain additional options you want to pass to compiler.)

    standalone --lazarus
      (Generate an xxx.lpr program file (like above),
      xxx.lpi Lazarus project file,
      compile a standalone executable using Lazarus (lazbuild must be on $PATH).

      This is exactly like above, but uses Lazarus. Useful especially
      if your project uses some Lazarus packages, e.g. Lazarus LCL --- it's best
      to compile then everything through Lazarus tools like lazbuild.)

    android
      (Generate xxx.lpr with a library file,
      compile using command-line FPC to a library libxxx.so,
      generate Android helper files inside android/ subdirectory,
      copy our library there,
      and use Android SDK toolchain ("android", "ant") to build an Android
      application (xxx.apk file))

    android --lazarus
      (Like above, but generates also a Lazarus project file xxx.lpi
      and compiles the same thing using Lazarus.)

  MyFantasticGame above is of course just an example.
  This is the base name of your game unit, and it will also determine
  target name (so executable will be called "MyFantasticGame" on Linux
  or "MyFantasticGame.exe" on Windows, Android app will be called
  "MyFantasticGame.apk" etc.)

- The most secure way of working is to never touch the generated files,
  do not commit them to version control systems (SVN, GIT),
  and clean them when needed by

    castle-engine clean-generate MyFantasticGame <target>
    castle-engine clean-build MyFantasticGame <target>

  If you really want to tweak them, then of course you can,
  and then you probably *want* to commit generated files to version control
  system and you probably *do not* want to call "clean-generate" action.
  The catch is that, if you tweak them, you will be responsible for updating
  them when new engine release will come out. We will try not to break
  compatibility for them, but it's too early to promise it right now.
  So just be prepared that, if you customize them, some day you may have to
  call "castle-engine generate <target>" again and re-apply your manual tweaks
  (if you use a version control system then it may actually be quite painless
  to investigate and re-apply the changes).

- The script is a bash script for now. It requires a tiny Unix environment,
  on Linux or Mac OS X you already have it, on Windows ---
  you have to install MSys or Cygwin.

