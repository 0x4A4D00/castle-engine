@title(Introduction)
@shorttitle(Introduction)

Table of contents:
@tableOfContents

@section(1 SectionAuthor Author)

This is a reference for @italic(Castle Game Engine),
see [http://castle-engine.sourceforge.net/]. Developed by
Michalis Kamburelis.

All comments, bug reports, questions, patches and everything are welcome.
See [http://castle-engine.sourceforge.net/support.php].

@section(1 SectionDocumentation About this documentation)

What you are reading right now is a reference for my units
generated by PasDoc (see [http://pasdoc.sf.net/] and
[http://castle-engine.sourceforge.net/reference.php]).
Everything is documented, every unit starts with a comment documenting
it's purpose, and every method, class etc. has a comment documenting
exactly what it does (with the exception of really trivial stuff that
is hopefully self-explanatory).
I believe everything is really good documented.

There's also a separate documentation that describes engine usage
from somewhat more higher-level view. It also describes some reasoning
behind internal organization of the engine. See
[http://castle-engine.sourceforge.net/vrml_engine_doc.php].

@section(1 SectionExamples Examples)

As a programmer, you probably want to jump straight into the action,
so take a look at the examples in @code(examples/) subdirectory
of the engine. You can compile them from Lazarus (install
castle_base and castle_components packages first, and then just open examples
.lpi files), or by @code(make examples).

There are a lot of examples, for 3D game examples look e.g. at

@unorderedList(
  @itemSpacing Compact
  @item examples/vrml/scene_manager_basic.lpr
  @item examples/vrml/scene_manager_demos.lpr
)

@section(1 SectionCompiling Compiling)

@section(2 SectionCompilingFPC Compiling these units with FPC)

Latest stable version of FPC is always advised.
See [http://castle-engine.sourceforge.net/sources.php#section_fpc_ver]
for more comments about FPC versions allowed.

Compile my programs with @code(compile.sh) script
prepared in directory of each program.
In summary, this script just calls fpc with proper command-line options.

If you want to use my units in your own programs then you
would probably like some way to compile only my units.
Here it is:

@orderedList(
  @item(
    If you use Lazarus, the most comfortable way to use my units
    in your programs is probably by using Lazarus castle_base and
    castle_components packages. Just install them in Lazarus.
    See @code(castle_game_engine/packages/README) in sources for more information.)

  @item(
    If you don't use Lazarus, you should compile my units using
    @code(castle_game_engine/Makefile) file. GNU make is required
    (under Linux this is the default `make',
    under Windows you have this already bundled with FPC
    (you can also get this from Cygwin or MinGW),
    under FreeBSD this is called `gmake').)

  @item(
    If you need more control over compilation process then
    you can also directly use castle-fpc.cfg file. This is my configuration
    file for FPC. It's used by @code(castle_game_engine/fpmake.pp) and by all @code(compile.sh)
    scripts of all programs. All my programs and units must be compiled with
    FPC using exactly this configuration.

    There is also @code(fpmake.pp) file inside the archive, as another
    alternative way to compile engine units. See FPC wiki for Fpmake
    documentation.)
)

@section(2 SectionCompilingDelphi Compiling these units with Delphi)

Long, long time ago some parts of the engine could be compiled by
Delphi 7 for Windows (all versions, even Delphi 7 Personal).
This concerned most of the units in @code(base/) subdirectory,
all units in @code(images/) and @code(fonts/).
Also, some parts used to be compileable with Kylix (Delphi for Linux).

This is all probably not possible now. I don't use Delphi anymore,
I don't have it installed, and I don't plan to support Delphi in my engine.
Some parts may still compile with Delphi, but this would be mostly
"by accident". Let's be serious and use FPC/Lazarus.

@italic(If you really really need to try Delphi compilation),
you can still try. Required Delphi compiler configuration:
@unorderedList(
  @itemSpacing Compact
  @item Complete boolean eval: off,
  @item Extended syntax: on,
  @item Typed @ operator: off,
  @item Huge strings: on,
  @item IO checking: on.
)

This is rather standard Delphi configuration, so it should not be any
problem. Other configuration settings do not matter, i.e. my code should
compile and work properly with any values of other configuration settings.

As usual you can turn on Range checking, Overflow checking and Assertions
for debugging purposes.

@section(1 SectionRequirements Requirements)

@section(2 SectionLibraries Libraries)

@link(Images) unit requires libpng (libpng.so under UNIXes,
libpng12.dll under Windows) installed if you want to load/save
PNG images. Otherwise you will get ELibPngNotAvailable exception
when trying to load/save files in PNG format.
Note that libpng requires also zlib installed.

CastleZLib unit (required by CastleZStream unit and used by
X3DNodes) requires zlib installed.

Some additional libraries are required for sound playing: OggVorbis stuff
requires @code(@noAutoLink(vorbisfile)) library, OpenAL stuff naturally requires
the OpenAL library. But all sound units are implemented in such way that
even if the user doesn't have OpenAL/@noAutoLink(vorbisfile) installed,
programs using these units can still run fine (e.g. units will not raise
any exception at unit initialization just because some library cannot
be loaded; instead, appropriate boolean variable will be set to @false,
and higher-level code can always check this).

For Windows, you can get some of the required DLLs easily
from my site, [http://castle-engine.sourceforge.net/miscella/win32_dlls.zip].
Inside this archive there are also pointers where the "upstream" versions
of these DLLs can be found on WWW.

On Mac OS X there are some additional requirements, since Mac OS X
port is done much like any other Unix right now. So some units require
some typical Unix libraries, like X11, GTK, GTKGlExt etc. See
[http://castle-engine.sourceforge.net/macosx_requirements.php]
for details.

@section(2 SectionOsArchCompat OS / architectures compatibility)

Tested and actually used on Linux, FreeBSD, Darwin/Mac OS X and Windows,
on i386 processor (32 bit). Also, Linux on x86-64 (64 bit) is working flawlessly.

The engine is very portable, and minimal amount of work / testing
should get it to compile under any other modern platform supported
by FPC. All Unix flavors may work out of the box. Windows on x86-64
is probably OK too, but needs to be tested. On big-endian processors
(most not-x86 processors), some image loading code probably needs to be adjusted.
Porters / testers are most welcome.

@section(1 SectionUnitsMap Units map)

Here's a short map of the important units documented here.
Units are divided into a couple of groups.
Group's name (like "@code(base)") is also the name of
subdirectory where unit's source code is placed.
The "@italic(Uses:)" notes below say which
units are allowed to be used by units in specific group.

@definitionList(
  @itemLabel @code(base)
  @item(
    These units provide some basic functions and classes.
    Some units hide OS-specific issues.
    Most important are CastleUtils, CastleClassUtils, CastleFilesUtils and
    other Kambi*Utils units which contain many useful routines.

    There are also some templates
    (see dynarray.inc, dim2array.inc, dim3array.inc, objectslist.inc,
    and their automatically duplicated versions in templates/ subdirectory).

    There's unit @link(CastleParameters)
    for command-line parsing, VectorMath unit with a lot of primitive
    geometry types and functions. And some more.

    @italic(Uses:) Nothing. These units do not depend on units
    from other groups.)

  @itemLabel @code(audio)
  @item(
    3D sound support. @link(ALSoundEngine) gives you a very comfortable way
    to load and play 3D sounds. The @link(XMLSoundEngine) additionally
    reads 3D sounds descriptions from special XML file (useful for games
    with fixed sound set).

    Lower-level sound units include OpenAL header translation (CastleOpenAL) and
    OpenAL helpers (@link(ALUtils)).
    Sound file formats (currently, WAV and OggVorbis) are handled by the
    @link(SoundFile) unit.

    @italic(Uses:) @code(base).)

  @itemLabel @code(images)
  @item(
    This is my @link(Images) unit to load images to 2d pixel arrays.
    Also an image cache (@link(ImagesCache)) unit, to help avoiding the same
    images more than once (which is important e.g. when loading game textures).
    Also some things to handle PasJPEG.
    Also my binding to libpng library (CastlePng).

    @italic(Uses:) @code(base).)

  @itemLabel @code(fonts)
  @item(
    Units TTFontsTypes and BmpFontsTypes and many units named
    TTF_* and BFNT_* that depend on TTFontsTypes or BmpFontsTypes.
    Units TTF_* and BFNT_* are automatically generated using font2pascal
    program. Also some helpers for Windows fonts and for translating them
    to Pascal sources (like those TTF_* and BFNT_* units).

    @italic(Uses:) @code(base).)

  @itemLabel @code(@noAutoLink(castlescript))
  @item(
    Parsing and executing expressions and programs in CastleScript language
    [http://castle-engine.sourceforge.net/castle_script.php].

    @italic(Uses:) @code(base), @code(images),
      VRML parts also use @code(vrml).)

  @itemLabel @code(ui)
  @item(
    User interface of the engine.

    First of all, unit UIControls with basic control class
    TUIControl and basic container interface IUIContainer.

    Concepts:

    @unorderedList(
      @item("Containers" are tied to a particular windowing library.
        We have two containers right now:

	@orderedList(
	  @itemSpacing Compact
	  @item A window, by our TCastleWindow class (see @code(window) directory).
	  @item A Lazarus component, by our TCastleControl class (see @code(components) directory).
	)

	The main task of a "container" is to handle a list of controls
	(instances of TUIControl class). For our two current containers
	this list is TCastleWindow.Controls and TCastleControl.Controls.
	Container doesn't care about particular control types,
	it just handles generic TUIControl classes, passing to them
	key, mouse events and much more.)

      @item("Controls" may be tied to a particular rendering library,
        in practice --- all current controls are invisible
	(like a camera) or use OpenGL rendering.

        The controls are @italic(not tied to the windowing library),
        for example you can use our TCastleOnScreenMenu both inside CastleWindow,
        as well as inside Lazarus GL area component, etc.
        Everywhere is fine, as long as you have OpenGL rendering context.)
    )

    We have a camera control in @link(Cameras) unit,
    and OpenGL controls (like TCastleOnScreenMenu) in @code(ui/opengl/) subdirectory.
    Also our 3D scene (TCastleScene) and animation (TCastlePrecalculatedAnimation),
    and our scene manager (TCastleSceneManager),
    are controls.

    @italic(Uses:) @code(base), @code(images), @code(3d).)

  @itemLabel @code(3d)
  @item(
    3D graphics stuff, not VRML-specific.
    This is the basis for VRML units in @code(vrml) directory.

    Operating on axis-aligned bounding boxes (Boxes3d),
    loading skyboxes (BackgroundBase),
    ray-tracer helpers (SpaceFillingCurves and
    SphereSampling) etc.

    Note: VectorMath unit is considered by me as something more general and
    useful --- so it's in @code(base) group, not here.

    @italic(Uses:) @code(base), @code(images).

    @italic(Subdirectory @code(opengl)) contains OpenGL-specific stuff,
    that uses also @code(opengl) units.)

  @itemLabel @code(opengl)
  @item(
    Basic OpenGL units. All the stuff here is usable in any OpenGL context,
    e.g. both in Lazarus OpenGL control and in CastleWindow.
    OpenGL fonts --- bitmap (OpenGLBmpFonts) and outline (OpenGLTTFonts),
    various OpenGL helpers (CastleGLUtils), handling OpenGL images and textures
    (GLImages),
    helpers for shadows (ShadowVolumesHelper) and anti-aliasing (GLAntiAliasing).

    @italic(Uses:) @code(base), @code(images), @code(3d), @code(fonts).)

  @itemLabel @code(@noAutoLink(window))
  @item(
    CastleWindow unit, to easily create a window with OpenGL context.
    For people who know the @code(glut) library: well, CastleWindow is "my glut",
    with nice ObjectPascal interface and countless improvements over
    the simple glut.

    This directory also contais various user-interface stuff usable only
    together with CastleWindow, like progress bar display in OpenGL window
    (CastleProgress), messages (CastleMessages, CastleNotifications, CastleInputs).

    @italic(Uses:) These units can use almost any other units:
    @code(base), @code(images), @code(3d), @code(fonts),
    @code(opengl), @code(vrml).

    What is important is that no other engine units may depend on
    CastleWindow units. So every OpenGL code outside @code(window)
    directory is usable with OpenGL context initialized in any way,
    like with Lazarus OpenGL control.)

  @itemLabel @code(vrml)
  @item(
    VRML rendering and processing. This is the core of our engine,
    most highest-level classes to render 3D scene are here.

    VRML file reading, writing and processing (X3DLexer, X3DFields,
    X3DNodes), building and using octree based on VRML model (VRMLOctree),
    ray-tracer based on VRML model (RayTracer),
    loading animations (PrecalculatedAnimationCore),
    other 3d model formats reading (Object3dGEO, Object3ds, Object3dOBJ,
    ColladaToVRML), and converting to VRML (Object3dAsVRML).

    @italic(Uses:) @code(base), @code(images), @code(3d), @code(fonts).

    @italic(Subdirectory @code(opengl)) contains OpenGL-specific stuff,
    that uses also @code(opengl) units.

    There's CastleScene unit that provides
    the most final and complete class for dealing with static VRML models and
    displaying them in OpenGL. And there's PrecalculatedAnimation, that
    provides the same thing, but for animations (actually using
    CastleScene underneath).
  )
)
