@title(Introduction)
@shorttitle(Introduction)

Table of contents:
@tableOfContents

@section(1 SectionAuthor Author)

This is a reference for @italic(Kambi VRML game engine),
see [http://vrmlengine.sourceforge.net/]. Developed by
Michalis Kamburelis.

All comments, bug reports, questions, patches and everything are welcome.

@section(1 SectionDocumentation About this documentation)

What you are reading right now is a reference for my units
generated by PasDoc (see [http://pasdoc.sf.net/] and
[http://vrmlengine.sourceforge.net/reference.php]).
Every unit should start with a comment documenting it's purpose,
every function (or functions' group) declared in unit's interface
should start with a comment documenting exactly what it does.
I believe everything is really good documented.
The only problem for English speakers is...

...Polish language: various parts of my Pascal sources may be still
documented in Polish. I am constantly translating those things to English,
but there's a lot of Polish text so full translation to English
isn't going to happen immediately. One thing you can do about that
is to tell me "I am interested in using/understanding
your sources and I really hate when I see a function/unit that looks
like what I want but is documented in Polish". Such "positive
criticism" should make me hasten my efforts to produce good English
documentation, so don't hesitate to email me with such requests.

There's also a separate documentation that describes engine usage
from somewhat more higher-level view. It also describes some reasoning
behind internal organization of the engine. See
[http://vrmlengine.sourceforge.net/vrml_engine_doc.php].

@section(1 SectionCompiling Compiling)

@section(2 SectionCompilingFPC Compiling these units with FPC)

Latest stable version of FPC is always advised.
See [http://vrmlengine.sourceforge.net/sources.php#section_fpc_ver]
for more comments about FPC versions allowed.

Compile my programs with @code(compile.sh) script
prepared in directory of each program.
In summary, this script just calls fpc with proper command-line options.

If you want to use my units in your own programs then you
would probably like some way to compile only my units.
Here it is:

@orderedList(
  @item(
    If you use Lazarus, the most comfortable way to use my units
    in your programs is probably by using Lazarus kambi_base package,
    see @code(kambi_vrml_game_engine/packages/README) in sources.)

  @item(
    If you don't use Lazarus, you should compile my units using
    @code(kambi_vrml_game_engine/Makefile) file. GNU make is required
    (under Linux this is the default `make',
    under Windows you have this already bundled with FPC
    (you can also get this from Cygwin or MinGW),
    under FreeBSD this is called `gmake').)

  @item(
    If you need more control over compilation process then
    you can also directly use kambi.cfg file. This is my configuration
    file for FPC. It's used by @code(kambi_vrml_game_engine/Makefile) and by all @code(compile.sh)
    scripts of all programs. All my programs and units must be compiled with
    FPC using exactly this configuration.)
)

@section(2 SectionCompilingDelphi Compiling these units with Delphi)

Long, long time ago some parts of the engine could be compiled by
Delphi 7 for Windows (all versions, even Delphi 7 Personal).
This concerned most of the units in @code(base/) subdirectory,
all units in @code(images/) and @code(fonts/).
Also, some parts used to be compileable with Kylix (Delphi for Linux).

This is all probably not possible now. I don't use Delphi anymore,
I don't have it installed, and I don't plan to support Delphi in my engine.
Some parts may still compile with Delphi, but this would be mostly
"by accident". Let's be serious and use FPC/Lazarus.

@italic(If you really really need to try Delphi compilation),
you can still try. Required Delphi compiler configuration:
@unorderedList(
  @itemSpacing Compact
  @item Complete boolean eval: off,
  @item Extended syntax: on,
  @item Typed @ operator: off,
  @item Huge strings: on,
  @item IO checking: on.
)

This is rather standard Delphi configuration, so it should not be any
problem. Other configuration settings do not matter, i.e. my code should
compile and work properly with any values of other configuration settings.

As usual you can turn on Range checking, Overflow checking and Assertions
for debugging purposes.

@section(1 SectionRequirements Requirements)

@section(2 SectionLibraries Libraries)

@link(Images) unit requires libpng (libpng.so under UNIXes,
libpng12.dll under Windows) installed if you want to load/save
PNG images. Otherwise you will get ELibPngNotAvailable exception
when trying to load/save files in PNG format.
Note that libpng requires also zlib installed.

KambiZlib unit (required by KambiZStream unit and used by
VRMLNodes) requires zlib installed.

Some additional libraries are required for sound playing: OggVorbis stuff
requires @code(@noAutoLink(vorbisfile)) library, OpenAL stuff naturally requires
OpenAL library. But all sound units are implemented in such way that
even if the user doesn't have OpenAL/@noAutoLink(vorbisfile) installed,
programs using these units can still run fine (e.g. units will not raise
any exception at unit initialization just because some library cannot
be loaded; instead, appropriate boolean variable will be set to @false,
and higher-level code can always check this).

For Windows, you can get some of the required DLLs easily
from my site, [http://vrmlengine.sourceforge.net/miscella/win32_dlls.zip].
Inside this archive there are also pointers where the "upstream" versions
of these DLLs can be found on WWW.

On Mac OS X there are some additional requirements, since Mac OS X
port is done much like any other Unix right now. So some units require
some typical Unix libraries, like X11, GTK, GTKGlExt etc. See
[http://vrmlengine.sourceforge.net/macosx_requirements.php]
for details.

@section(2 SectionOsArchCompat OS / architectures compatibility)

Tested and actually used on Linux, FreeBSD, Darwin/Mac OS X and Windows,
on i386 processor (32 bit). Also, Linux on x86-64 (64 bit) is working flawlessly.

The engine is very portable, and minimal amount of work / testing
should get it to compile under any other modern platform supported
by FPC. All Unix flavors may work out of the box. Windows on x86-64
is probably OK too, but needs to be tested. On big-endian processors
(most not-x86 processors), some image loading code probably needs to be adjusted.
Porters / testers are most welcome.

@section(1 SectionUnitsMap Units map)

Here's a short map of important units documented here.
Units are divided into a couple of groups.
Group's name (like "@code(base)") is also the name of
subdirectory where unit's source code is placed.
The "@italic(Uses:)" notes below say which
units are allowed to be used by units in specific group.

@definitionList(
  @itemLabel @code(base)
  @item(
    These units provide some basic functions and classes.
    Some units hide OS-specific issues.
    Most important are KambiUtils, KambiClassUtils, KambiFilesUtils and
    other Kambi*Utils units which contain many useful routines.

    There are also some templates
    (see dynarray.inc, dim2array.inc, dim3array.inc, objectslist.inc,
    and their automatically duplicated versions in templates/ subdirectory).

    There's unit @link(ParseParametersUnit)
    for command-line parsing, VectorMath unit with a lot of primitive
    geometry types and functions. And some more.

    @italic(Uses:) Nothing. These units do not depend on units
    from other groups.)

  @itemLabel @code(audio)
  @item(
    These are my audio units.
    OpenAL header translation (@link(KambiOpenAL)),
    OpenAL helper routines (@link(ALUtils)),
    sound file formats (currently, WAV and OggVorbis) reader (@link(SoundFile)),
    smart sound sources allocator (@link(ALSourceAllocator))
    and finally some high-level class to comfortably
    use this whole thing (@link(GameSoundEngine)).

    @italic(Uses:) @code(base).)

  @itemLabel @code(images)
  @item(
    This is my @link(Images) unit to load images to 2d pixel arrays.
    Also an image cache (@link(ImagesCache)) unit, to help avoiding the same
    images more than once (which is important e.g. when loading game textures).
    Also some things to handle PasJPEG.
    Also my binding to libpng library (@link(KambiPng))
    and some helpers (@link(KambiPngUtils)).

    @italic(Uses:) @code(base).)

  @itemLabel @code(fonts)
  @item(
    Units TTFontsTypes and BmpFontsTypes and many units named
    TTF_* and BFNT_* that depend on TTFontsTypes or BmpFontsTypes.
    Units TTF_* and BFNT_* are automatically generated using font2pascal
    program. Also some helpers for Windows fonts and for translating them
    to Pascal sources (like those TTF_* and BFNT_* units).

    @italic(Uses:) @code(base).)

  @itemLabel @code(@noAutoLink(kambiscript))
  @item(
    Parsing and executing expressions and programs in KambiScript language
    [http://vrmlengine.sourceforge.net/kambi_script.php].

    @italic(Uses:) @code(base), @code(images),
      VRML parts also use @code(3models).)

  @itemLabel @code(ui)
  @item(
    Abstract user interface classes. By "abstract" I mean that these
    units do not define actual, visible "controls" and "windows".
    This task is left up to units elsewhere,
    for example OpenGL controls and windows are within opengl/ units.
    Lazarus component in packages/components/ may also serve as a
    "window" for our controls.

    The ideas behind these classes:

    @unorderedList(
      @item("Windows" are tied to particular windowing library,
        like Lazarus component or GLWindow.

        Implementing "windows" class means handlign some generic
        abstract classes like TInputListener. Window doesn't have to
        care about each control type in particular. This means
        that developing new controls is easy, you do all the work
        by implementing descendant of appropriate class, and it can
        be automatically handled properly by all windows.)

      @item("Controls" are tied to particular rendering library,
        in practice --- all current controls use OpenGL rendering.

	TODO: below is currently not @true, TGLMenu requires GLWindow unit,
	although only for designer mode. The plan is to free TGLMenu
	from this as soon as possible.

        The controls are @italic(not tied to the windowing library),
        for example you can use our TGLMenu both inside GLWindow,
        as well as inside Lazarus GL area component, etc.
        Everywhere is fine, as long as you have OpenGL rendering context.)
    )

    @italic(Uses:) @code(base), @code(images), @code(3d).)

  @itemLabel @code(3d)
  @item(
    3D graphics stuff, not VRML-specific.
    This is the basis for VRML units in @code(vrml) directory.

    Operating on axis-aligned bounding boxes (Boxes3d),
    loading skyboxes (BackgroundBase), navigation in 3D world
    (MatrixNavigation), ray-tracer helpers (SpaceFillingCurves and
    SphereSampling) etc.

    Note: VectorMath unit is considered by me as something more general and
    useful --- so it's in @code(base) group, not here.

    @italic(Uses:) @code(base), @code(images).

    @italic(Subdirectory @code(opengl)) contains OpenGL-specific stuff,
    that uses also @code(opengl) units.)

  @itemLabel @code(opengl)
  @item(
    Basic OpenGL units. All the stuff here is usable in any OpenGL context,
    e.g. both in Lazarus OpenGL control and in GLWindow.
    OpenGL fonts --- bitmap (OpenGLBmpFonts) and outline (OpenGLTTFonts),
    various OpenGL helpers (KambiGLUtils), handling OpenGL images and textures
    (GLImages),
    helpers for shadows (ShadowVolumesHelper) and anti-aliasing (GLAntiAliasing).

    @italic(Uses:) @code(base), @code(images), @code(3d), @code(fonts).)

  @itemLabel @code(@noAutoLink(glwindow))
  @item(
    GLWindow unit, to easily create a window with OpenGL context.
    For people who know the @code(glut) library: well, GLWindow is "my glut",
    with nice ObjectPascal interface and countless improvements over
    the simple glut.

    This directory also contais various user-interface stuff usable only
    together with GLWindow, like progress bar display in OpenGL window
    (ProgressGL), messages (GLWinMessages, TimeMessages, GLWinInputs).

    @italic(Uses:) These units can use almost any other units:
    @code(base), @code(images), @code(3d), @code(fonts),
    @code(opengl), @code(vrml).

    What is important is that no other engine units may depend on
    GLWindow units. So every OpenGL code outside @code(glwindow)
    directory is usable with OpenGL context initialized in any way,
    like with Lazarus OpenGL control.)

  @itemLabel @code(vrml)
  @item(
    VRML rendering and processing. This is the core of our engine,
    most highest-level classes to render 3D scene are here.

    VRML file reading, writing and processing (VRMLLexer, VRMLFields,
    VRMLNodes), building and using octree based on VRML model (VRMLOctree),
    ray-tracer based on VRML model (VRMLRayTracer),
    loading animations (VRMLAnimation),
    other 3d model formats reading (Object3dGEO, Object3ds, Object3dOBJ,
    ColladaToVRML), and converting to VRML (Object3dAsVRML).

    @italic(Uses:) @code(base), @code(images), @code(3d), @code(fonts).

    @italic(Subdirectory @code(opengl)) contains OpenGL-specific stuff,
    that uses also @code(opengl) units.

    There's VRMLGLScene unit that provides
    the most final and complete class for dealing with static VRML models and
    displaying them in OpenGL. And there's VRMLGLAnimation, that
    provides the same thing, but for animations (actually using
    VRMLGLScene underneath).
  )
)
