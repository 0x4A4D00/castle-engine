@title(Introduction)
@shorttitle(Introduction)

@html(<img src="castle_game_engine_icon.png"
  alt="Castle Game Engine icon"
  align="right"/>)

Table of contents:
@tableOfContents

@section(1 SectionAuthor Author)

This is a reference for @italic(Castle Game Engine),
see [http://castle-engine.sourceforge.net/]. Developed by
Michalis Kamburelis.

All comments, bug reports, questions, patches and everything are welcome.
See [http://castle-engine.sourceforge.net/support.php].

@section(1 SectionDocumentation About this documentation)

This reference was generated by PasDoc (see [http://pasdoc.sf.net/]).
The online version of it is available on
[http://castle-engine.sourceforge.net/reference.php].

There's also a separate documentation that describes engine architecture
from higher-level point of view on
[http://castle-engine.sourceforge.net/engine_doc.php].

@section(1 SectionExamples Examples)

As a programmer, you probably want to jump straight into the action,
so take a look at the examples in @code(examples/) subdirectory
of the engine. You can compile them from Lazarus (install
castle_base and castle_components packages first, and then just open examples
.lpi files), or by @code(make examples).

There are a lot of examples, for 3D game examples look e.g. at

@unorderedList(
  @itemSpacing Compact
  @item examples/3d_rendering_processing/view_3d_model_basic.lpr
  @item examples/3d_rendering_processing/view_3d_model_advanced.lpr
  @item examples/3d_rendering_processing/scene_manager_demos.lpr
)

@section(1 SectionCompiling Compiling)

@section(2 SectionCompilingFPC Compiling these units with FPC)

Latest stable version of FPC is always advised.
See [http://castle-engine.sourceforge.net/sources.php#section_fpc_ver]
for more comments about FPC versions allowed.

Compile programs using the @code(xxx_compile.sh) script
prepared in directory of each program.
In summary, this script just calls fpc with proper command-line options.
Or open the @code(xxx.lpi) file in Lazarus, and compile from Lazarus.

To use the engine in your own programs, there are a couple of options:

@orderedList(
  @item(
    If you use Lazarus, the most comfortable way to use engine units
    is to use Lazarus castle_base and
    castle_components packages. Just install them in Lazarus.
    See @code(castle_game_engine/packages/README.txt) in sources for more information.)

  @item(
    If you don't use Lazarus, you should compile engine units using
    @code(castle_game_engine/Makefile) file. GNU make is required
    (under Linux this is the default `make',
    under Windows you have this already bundled with FPC
    (you can also get this from Cygwin or MinGW),
    under FreeBSD this is called `gmake').

    Currently, @code(make) simply uses @code(castle_game_engine/fpmake.pp).
    If you're familiar with FPMake (see [http://wiki.lazarus.freepascal.org/FPMake]),
    you may as well just compile @code(fpmake.pp) and run it yourself.)

  @item(
    If you need more control over compilation process then
    you can also directly use castle-fpc.cfg file. This is my configuration
    file for FPC. It's used by and by all @code(xxx_compile.sh)
    scripts, @code(fpmake.pp) etc. All my programs and units must be compiled with
    FPC using this configuration.)
)

@section(1 SectionRequirements Requirements)

@section(2 SectionLibraries Libraries)

@link(Images) unit requires libpng (libpng.so under UNIXes,
libpng12.dll under Windows) installed if you want to load/save
PNG images. Otherwise you will get ELibPngNotAvailable exception
when trying to load/save files in PNG format.
Note that libpng requires also zlib installed.

CastleZLib unit (required by CastleZStream unit and used by
X3DNodes) requires zlib installed.

Some additional libraries are required for sound playing: OggVorbis stuff
requires @code(@noAutoLink(vorbisfile)) library, OpenAL stuff naturally requires
the OpenAL library. But all sound units are implemented in such way that
even if the user doesn't have OpenAL/@noAutoLink(vorbisfile) installed,
programs using these units can still run fine (e.g. units will not raise
any exception at unit initialization just because some library cannot
be loaded; instead, appropriate boolean variable will be set to @false,
and higher-level code can always check this).

For Windows, you can get some of the required DLLs easily
from my site, [http://castle-engine.sourceforge.net/miscella/win32_dlls.zip].
Inside this archive there are also pointers where the "upstream" versions
of these DLLs can be found on WWW.

On Mac OS X there are some additional requirements, since Mac OS X
port is done much like any other Unix right now. So some units require
some typical Unix libraries, like X11, GTK, GTKGlExt etc. See
[http://castle-engine.sourceforge.net/macosx_requirements.php]
for details.

@section(2 SectionOsArchCompat OS / architectures compatibility)

Tested and actually used on Linux, FreeBSD, Darwin/Mac OS X and Windows,
on i386 processor (32 bit). Also, Linux on x86-64 (64 bit) is working flawlessly.

The engine is very portable, and minimal amount of work / testing
should get it to compile under any other modern platform supported
by FPC. All Unix flavors may work out of the box. Windows on x86-64
is probably OK too, but needs to be tested. On big-endian processors
(most not-x86 processors), some image loading code probably needs to be adjusted.
Porters / testers are most welcome.

@section(1 SectionUnitsMap Units map)

Here's a short map of the important units documented here.
Units are divided into a couple of groups.
Group's name (like "@code(base)") is also the name of
subdirectory where unit's source code is placed.
The "@italic(Uses:)" notes below say which
units are allowed to be used by units in specific group.

@definitionList(
  @itemLabel @code(base)
  @item(
    These units provide some basic functions and classes.
    Some units hide OS-specific issues.
    Most important are CastleUtils, CastleClassUtils, CastleFilesUtils and
    other Kambi*Utils units which contain many useful routines.

    There are also some templates
    (see dynarray.inc, dim2array.inc, dim3array.inc, objectslist.inc,
    and their automatically duplicated versions in templates/ subdirectory).

    There's unit @link(CastleParameters)
    for command-line parsing, VectorMath unit with a lot of primitive
    geometry types and functions. And some more.

    @italic(Uses:) Nothing. These units do not depend on units
    from other groups.)

  @itemLabel @code(audio)
  @item(
    3D sound support. @link(ALSoundEngine) gives you a very comfortable way
    to load and play 3D sounds, you can load and play them dynamically,
    you can also preload and configure some sounds by
    a special XML file (see @link(TXmlSoundEngine)).

    Lower-level sound units include OpenAL header translation (CastleOpenAL) and
    OpenAL helpers (@link(ALUtils)).
    Sound file formats (currently, WAV and OggVorbis) are handled by the
    @link(SoundFile) unit.

    @italic(Uses:) @code(base).)

  @itemLabel @code(images)
  @item(
    This is my @link(Images) unit to load images to 2d pixel arrays.
    Also an image cache (@link(ImagesCache)) unit, to help avoiding the same
    images more than once (which is important e.g. when loading game textures).
    Also some things to handle PasJPEG.
    Also my binding to libpng library (CastlePng).

    @italic(Uses:) @code(base).)

  @itemLabel @code(fonts)
  @item(
    Units TTFontsTypes and BmpFontsTypes and many units named
    TTF_* and BFNT_* that depend on TTFontsTypes or BmpFontsTypes.
    Units TTF_* and BFNT_* are automatically generated using font2pascal
    program. Also some helpers for Windows fonts and for translating them
    to Pascal sources (like those TTF_* and BFNT_* units).

    @italic(Uses:) @code(base).)

  @itemLabel @code(@noAutoLink(castlescript))
  @item(
    Parsing and executing expressions and programs in CastleScript language
    [http://castle-engine.sourceforge.net/castle_script.php].

    @italic(Uses:) @code(base), @code(images),
      X3D parts also use @code(x3d).)

  @itemLabel @code(ui)
  @item(
    User interface of the engine.

    First of all, unit UIControls with basic control class
    TUIControl and basic container interface IUIContainer.

    Concepts:

    @unorderedList(
      @item("Containers" are classes that implement IUIContainer interface.
        We have two containers right now:

        @orderedList(
          @itemSpacing Compact
          @item A window, by our TCastleWindow class (see @code(window) directory).
          @item A Lazarus component, by our TCastleControl class (see @code(components) directory).
            This descends from the base TOpenGLControl provided by Lazarus,
            inheriting it's functionality.
        )

        Container is tied to a particular windowing library, like GTK or WinAPI
        or something higher-level like Lazarus LCL.
        Container is responsible for initializing and managing OpenGL context.

        Container handles a list of controls, that is a list of
        instances of the TUIControl class. For our two current containers
        this list is TCastleWindow.Controls and TCastleControl.Controls.
        Container passes to them key events, mouse events and much more.)

      @item("Controls" are classes that descend from TUIControl class.
        They may be tied to a particular rendering library,
        in practice --- all current controls use OpenGL rendering.

        The controls are not concerned with how you initialized the OpenGL
        context, so all controls are useful with all containers.
        For example you can use the same TCastleOnScreenMenu class
        inside TCastleWindow, or inside Lazarus TCastleControl component, etc.)
    )

    We have many OpenGL controls (like TCastleOnScreenMenu and things
    like buttons inside CastleControls) in @code(ui/opengl/) subdirectory.
    We also have camera classes (Cameras unit with TCamera descendants),
    they are used by scene manager.

    @italic(Uses:) @code(base), @code(images), @code(3d).)

  @itemLabel @code(3d)
  @item(
    3D graphics stuff, not X3D-specific.
    This is the basis for X3D units in @code(x3d) directory.

    Operating on axis-aligned bounding boxes (Boxes3d),
    loading skyboxes (BackgroundBase),
    ray-tracer helpers (SpaceFillingCurves and
    SphereSampling) etc.

    Note: VectorMath unit is considered by me as something more general and
    useful --- so it's in @code(base) group, not here.

    @italic(Uses:) @code(base), @code(images).

    @italic(Subdirectory @code(opengl)) contains OpenGL-specific stuff,
    that uses also @code(opengl) units.)

  @itemLabel @code(opengl)
  @item(
    Basic OpenGL units. All the stuff here is usable in any OpenGL context,
    e.g. both in Lazarus OpenGL control and in CastleWindow.
    OpenGL fonts --- bitmap (OpenGLBmpFonts) and outline (OpenGLTTFonts),
    various OpenGL helpers (CastleGLUtils), handling OpenGL images and textures
    (GLImages),
    helpers for shadows (ShadowVolumesHelper).

    @italic(Uses:) @code(base), @code(images), @code(3d), @code(fonts).)

  @itemLabel @code(@noAutoLink(window))
  @item(
    CastleWindow unit, to easily create a window with OpenGL context.
    For people who know the @code(glut) library: well, CastleWindow is "my glut",
    with nice ObjectPascal interface and countless improvements over
    the simple glut.

    This directory also contains various user-interface stuff usable only
    together with CastleWindow, like progress bar display in OpenGL window
    (CastleProgress), messages (CastleMessages, CastleNotifications, CastleInputs).

    @italic(Uses:) These units can use almost any other units:
    @code(base), @code(images), @code(3d), @code(fonts),
    @code(opengl), @code(x3d).

    What is important is that no other engine units may depend on
    CastleWindow units. So every OpenGL code outside @code(window)
    directory is usable with OpenGL context initialized in any way,
    like with Lazarus OpenGL control.)

  @itemLabel @code(x3d)
  @item(
    VRML/X3D rendering and processing. This is the core of our engine,
    classes to handle and render 3D stuff are here.

    X3D file reading, writing and processing (X3DLexer, X3DFields,
    X3DNodes), building and using octree based on X3D model (ShapeOctree, TriangleOctree),
    ray-tracer based on X3D model (RayTracer),
    loading animations (PrecalculatedAnimationCore),
    load 3D model formats as X3D (X3DLoad).

    @italic(Uses:) @code(base), @code(images), @code(3d), @code(fonts).

    @italic(Subdirectory @code(opengl)) contains OpenGL-specific stuff,
    that uses also @code(opengl) units.

    CastleScene unit provides the complete class
    for dealing with 3D models and displaying them in OpenGL.
    PrecalculatedAnimation also provides a special way
    of animating models by interpolating between a set of 3D files.
  )

  @itemLabel @code(game)
  @item(
    High level units implementing game mechanics for 3D games.
    They build on top of other units.

    CastleCreatures provides creatures AI, CastleResources
    manages reference-counted heavy 3D resources.

    @italic(Uses:) everything except @code(window), as this must
    be suitable for both TCastleWindow and Lazarus TCastleControl.
  )
)

@section(1 SectionMultipleContext Multiple OpenGL contexts)

If you use more than one OpenGL context (TCastleWindow or TCastleControl)
in a single program, they will share OpenGL resources (like textures).
This happens automatically for TCastleControl.

TODO: It is not implemented yet for TCastleWindow correctly yet.
Be careful when you use more than one TCastleWindow with anything
that uses cache (like textures inside TCastleScene).
And please let us know on forum that you would like to see this fixed
--- it's simply a matter of time to finish it.
