This tutorial teaches you basic ideas of modeling 3D stuff (levels, creatures, items, --- everything) to use with our engine.

First of all, our engine was designed from the start to use <a>standard VRML/X3D model format</a>. This means that in principle you can use <b>any 3D modeler</a> to make models for our games, as almost everything can export to VRML/X3D (and when that's not enough, we also support many Collada, 3DS, Wavefront OBJ and other 3D formats). We consciously do not try to implement any 3D editor for our engine --- it's a wasted effort, just look how magnificent e.g. Blender is, and how it's constantly improving. So we want to use these tools, not reinvent them.

In this tutorial, we show how to use Blender to model 3D stuff. If you're a fan of other 3D modeler, you're most welcome to write alternative instructions / hints for using it (you can post them on our wiki, or forum, and --- depending on the size of your instructions --- we'll see how to show them nicely on our webpages).

TODO. Shortcut for now:

1. Get Blender.
2. Get our Blender X3D exporter from http://castle-engine.sourceforge.net/blender_stuff.php
3. Model as usual. Be aware of what is / is not currently exported (see "exporter notes" on http://castle-engine.sourceforge.net/blender_stuff.php).
4. Export to X3D, and you're done.

It's usually comfortable to open the exported file first with view3dscene. Once this looks nicely, use this within your game.

------------------------------------------------------------------------------
3D resources, like creatures and items, display various 3D animations. Depending on the creature state, like standing / attacking / dying, we may want to display different animation of the given creature instance. We define these animations using the <model> element of creature/item resource.xml file. (As a developer, you can also create T3DResourceAnimation class in T3DResource descendants, to load more animations in this manner, and use these animations however you like.)

-> At this point, I highly advice you compile and run the resource_animations example program from the engine sources. It's inside castle_game_engine/examples/resource_animations/. The data/ subdirectory shows examples of how you can define <model>, discussed below. It is also a great program to test your own creatures/items animations (before using in the actual game), you can load their resource.xml using the "Add resource..." button and directly play loaded animations.

There are three approaches, and which one to choose depends on what 3D modeler / exporter you use to design your models:

1. The best way (best for memory and loading time, which is really important in these situations) is to use a single X3D model, with many X3D TimeSensors representing different animations. You declare it in resource.xml file like this:

  <model file_name="model.x3d">
    <stand time_sensor="TimeSensorStand"/>
    <walk time_sensor="TimeSensorWalk"/>
  </model>

This is nice if your 3D modeler / exporter can record multiple animations inside a single X3D file, and each animation is controlled by a different X3D TimeSensor node. This is the most natural way to record multiple animations in a single X3D file. We will detect animation length from the TimeSensor.cycleInterval, and we'll simulate sending appropriate elapsedTime and fraction_changed from this TimeSensor to activate the desired moment of the desired animation.

Unfortunately, I don't know of any open-source 3D modeler / exporter right now that can nicely produce such multiple animations in a single X3D file. I plan to extend Blender X3D exporter to allow this in the future.

2. You can also use a separate X3D model for each animation state, like this:

  <model>
    <stand file_name="stand.x3d" time_sensor="MainTimeSensor"/>
    <walk file_name="walk.x3d" time_sensor="MainTimeSensor"/>
  </model>

3. You can also use a precalculation animation for each animation, from <a href=>kanim</a> or MD3 (Quake 3 engine format) file. This is useful if your 3D modeler / exporter cannot produce animated X3D files at all, but it can export to kanim (see <a href=">our Blender to kanim exporter</a> or MD3. In the worst case, you can also just export a couple of still frames and write the xxx.kanim file in a text editor, because the kanim format is a trivial XML file that just describes a transition between a couple of still 3D models. Internally, we'll use TCastlePrecalculatedAnimation for each animation state.

Example:

  <model>
    <stand file_name="stand.kanim"/>
    <walk file_name="walk.kanim"/>
  </model>

To describe above three cases in more precise manner:

- (Case 3. above) When animation state, like <stand> or <walk>, doesn't have a time_sensor attribute --- then it must have file_name attribute, and we use precalculated animation, TCastlePrecalculatedAnimation, to play it. Suitable for kanim and X3D animations. Suitable also when the model is just a still 3D model, as then TCastlePrecalculatedAnimation simply renders it.

- (Case 2. above) Otherwise, if an animation state like <stand> or <walk> has both time_sensor and file_name, then we load it to a TCastleScene and use appropriate TimeSensor to play the animation.

- (Case 1. above) Otherwise, if an animation state like <stand> or <walk> has only time_sensor, then we use a 3D model defined at <model> element to choose and play appropriate animation. This also means using TCastleScene and appropriate TimeSensor to play it, but now it's a single TCastleScene potentially shared by various animations.

In some situations, we have to know the animation duration (for example, to know when <attack> animation ends and we should get back to <stand> or <walk> state).
- For TCastlePrecalculatedAnimation, the animation always starts from the local time 0, goes to the last time (time of last <frame> in kanim file). Then it eventually goes backward, it backwards="true" in kanim file. So we know the duration by looking at frames time and backwards property: TimeEnd + (if Backwards then TimeEnd-TimeBegin else 0).
  So using backwards="true" in kanim works, useful for some animations when you do some gesture and then go back to original position by reversing this gesture --- e.g. dog-like creature biting.
- For TCastleScene and TimeSensor: in this case, X3D TimeSensor.cycleInterval gives us animation duration.

The looping is done automatically for animations that require it (like walk). So using loop attribute in kanim file, or loop field for TimeSensor is not necessary (it's ignored).

Design notes about X3D TimeSensor usage: Note that all creatures of a given kind share the same resources, e.g. if you have a single creature "werewolf" (defined by a resource.xml file with name="Werewolf" inside) you can instantiate this creature many times, and they will all actually use the same resource underneath. That is why we use TimeSensors by directly sending their elapsedTime/fraction_changed, instead of just activating them by TimeSensor.startTime: in the latter case, all werewolves visible on the level would be forced to be in the same state(and moment) of the animation.
------------------------------------------------------------------------------
To make exporting easy and automated without accidents, Michalis found it's best to place a short Python snippet that calls the export operator inside .blend file. This can look like this:

[[
import bpy
import os
dirname = os.path.dirname(bpy.context.blend_data.filepath)
filepath = os.path.join(dirname, "idle.x3d")
bpy.ops.export_scene.x3d(filepath=filepath,
    check_existing=False,
    use_selection=False,
    use_apply_modifiers=True,
    use_triangulate=False,
    use_normals=False,
    use_compress=False,
    use_hierarchy=True,
    name_decorations=True,
    use_h3d=False,
    axis_forward='Z',
    axis_up='Y',
    path_mode='AUTO')
]]

This way if you need to export some model, e.g. with path_mode="RELATIVE" (necessary if your texture paths start like ../../) then you can just write it down inside .blend file. Blender "Operator Presets" are too error-prone for this in my experience, you often end up not choosing them, and it's hard to share them with others and keep in SVN repo. Moreover, a script can even select necessary objects (in case you need to use use_selection), skip to appropriate animation frame, export a couple of files (maybe some X3D, maybe some KAnim).... See castle/data/creatures/barrel/barrel.blend for an example using it, like this:

[[
import bpy
import os

dirname = os.path.dirname(bpy.context.blend_data.filepath)

# make sure we're on the 1st frame
bpy.context.scene.frame_set(1)

# make sure that only Main is selected
bpy.ops.object.select_all(action='DESELECT')
main = bpy.data.objects['Main']
main.select = True
bpy.context.scene.objects.active = main

# export idle
filepath = os.path.join(dirname, "idle.x3d")
bpy.ops.export_scene.x3d(filepath=filepath,
	use_selection=True,
	axis_forward='Y', axis_up='Z',
	path_mode='RELATIVE'
	)

# export die
filepath = os.path.join(dirname, "die.kanim")
bpy.ops.export.kanim(filepath=filepath,
	use_selection=True,
	axis_forward='Y', axis_up='Z',
	path_mode='RELATIVE'
	)
]]
