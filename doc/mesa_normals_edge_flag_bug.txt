2006-12-11:
This is the log of debugging problem with Mesa 6.5.1 and 6.5.2
(not observed on Mesa 5.1 and 6.4.2). My VRML programs failed with

  $ view3dscene cones.wrl
  view3dscene: tnl/t_save_api.c:1605: _tnl_EndList: Assertion `((TNLcontext *)((ctx)->swtnl_context))->save.vertex_size == 0' failed.
  Aborted

Summary of results: quite nice workaround of the problem was found
(the workaround is literally 1-line modification inside
openglttfonts.pas... talk about a hard debugging day :).

TODO: but the bug is not reported to Mesa developers yet.
And the Mesa version where the problem is fixed is not known yet
--- should be added to openglttfonts.pas near GLVersion.IsMesa check.

Tests on VRMLs from
[http://www.camelot.homedns.org/~michalis/kambi_vrml_test_suite.php] and
[http://www.camelot.homedns.org/~michalis/vrml_engine_doc.php].

simplest_sphere_1.wrl:
  fails with smooth and flat shading (GLU_SMOOTH, GLU_FLAT for quadric)
  works when USE_VRML_NODES_TRIANGULATION is used
  works when gluSphere replaced with
    glNormal3f(0, 0, 1);
    glBegin(GL_TRIANGLES);
      glVertex3f(-Radius, 0,       0);
      glVertex3f(-Radius, +Radius, 0);
      glVertex3f(      0, +Radius, 0);
    glEnd;
  fails when glNormal3f call moved after glBegin

Hyphotesis 1: glNormal3f between glBegin/End caused the Mesa bug.

  Probably gluSphere calls glNormal3f between glBegin/End even when
  GLU_FLAT normals requested, that's why GLU_SMOOTH / GLU_FLAT for quadric
  doesn't make any difference.

castle.wrl:
  fails with smooth and flat shading (current implementation
  in VRMLOpenGLRenderer calls glNormal3f before each vertex,
  even for flat shading). So this confirms hyp1.

  When
  if Render_Normals = inGenerate then
    glNormalv(Render_GeneratedNormals.Items[indexNum]);
  commented out, works (although lighting is obviously wrong;
  but doesn't crash). Again, this confirms hyp1.

non_convex_face.wrl, normals.wrl:
  fail with smooth shading. Confirms hyp1.

creaseangle.wrl:
  Strange. Doesn't crash Mesa, even though it calls glNormal3f
  between glBegin/End, just like castle.wrl.

  Investigation: turns out that when creaseangle got converted
  to VRML 1.0 then it started crashing, like castle.wrl.
  So there must be something in VRML 2.0 path that accidentaly
  workarounds Mesa bug.

  Yeah! After a long long long long debugging battle, I figured out
  why creaseangle.wrl in VRML 2.0 version doesn't fail: that's because
  in VRML 2.0 by default no font is prepared, while in VRML 1.0
  every State has some font so a TTF OpenGL font is prepared.
  This is great news, because it narrows our problem significantly:

Hyp2: the problem occurs when both things occur simultaneously:
  - something inside TTF OpenGL font display list construction occurs
  - then VRMLOpenGLRendered does glNormal call between glBegin/End.

  Hyp2 is confirmed by the fact that when I commented out preparing
  TTF fonts from VRMLOpenGLRendered, then all testcases (castle.wrl,
  non_convex_face.wrl, normals.wrl, simplest_sphere_1.wrl) run 100%
  correct with their proper normals! This is both without
  USE_VRML_NODES_TRIANGULATION (so when the line
    if Render_Normals = inGenerate then
      glNormalv(Render_GeneratedNormals.Items[indexNum]);
  works) and when USE_VRML_NODES_TRIANGULATION is used and modified to
  perform glNormal after glBegin.

  This is great news, because this means that a simpler (less-destructive
  for our code) workaround may be possible (than forcing normals to be flat).

  After a little tweaking: it occurs that when I don't use
  gluTessCallback(tobj, GLU_TESS_EDGE_FLAG, ...) when generating
  display lists for TTF fonts, the bug doesn't occur. This is a great
  workaround, since removing (actually, putting it under
  "if not GLVersion.IsMesa ...") the glEdgeFlag is quite painless for us.
  The only drawback is that if we will render AsciiText/Text node,
  and user will view the model in wireframe mode, user will see additional
  edges. This is hardly a real problem.