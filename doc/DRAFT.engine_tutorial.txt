TODO: This is a work in progress. I want to finish this for next engine release (3.1.0 or maybe 4.0.0). This is supposed to be a full tutorial how to make a FPS game, from the basics (with enough info to make it obvious how to create other types of games, 3D or not).

The tutorial handles both alternatives for creating OpenGL context: as Lazarus component (on Lazarus form), or as our TCastleWindow instance. Appropriate parts of the tutorial will be in 2-column view to visualize this.

------------------------------------------------------------------------------
TODO: add somewhere here a nice diagram of engine classes, see DRAFT.engine_classes_diagram.txt.

Add at the beginning of each page: you're welcome to contribute to this tutorial (or any other part of the engine documentation, for that matter): go to <a href="http://sourceforge.net/p/castle-engine/wiki/Home/">our wiki</a> and write there about what you think is useful :) If you want to modify the contents of this tutorial, you're welcome to just start by copy-pasting the relevant text from here to wiki, and the improving it. We will merge the contents of wiki back to our "static" documentation, or (if wiki will prove successfull) we will just start linking to our wiki instead of static docs.
------------------------------------------------------------------------------
0. Introduction

This tutorial shows how to make a simple 3D first-person game using our <i>Castle Game Engine</i>. We'll explain the basics of our engine, show you some simple programs and mention the most important classes.

Throughout this tutorial you will see a links to our <a>engine reference</a>, and you will eventually want to follow them to read detailed reference of stuff that interests you. Note that you can also just read the units source code --- the reference is automatically generated from the comments in the units interface, so if you're brave enough, you can just dive straight into the source.

------------------------------------------------------------------------------
1. Download and install the engine, try the demos

If you haven't done it yet, download the engine source code with examples from ....

Run Lazarus, and open packages in the castle_game_engine/packages/ subdirectory. Open and compile all three packages (castle_base.lpk, castle_components.lpk, castle_window.lpk), to test that things compile OK. Then install the package <i>castle_components</i>. (Do not install castle_window --- you don't want to have this installed in Lazarus. You can install castle_base explicitly, but there's no need to: installing castle_components will also install castle_base automatically.)

Once packages are successfully installed, Lazarus restarts, and you should see "Castle" tab of components at the top (screenshot). Sorry, we don't have icons for our components yet, so it looks a little boring. Mouse over the icons to see component names.

Let's quickly open and run some demos, to make sure that everything works. I suggest running ... (some LCL demo) and ... (some CastleWindow demo).

Make sure you have installed the necessary libraries first, or some of the demos will not work. The required libraries (.so under Unix, .dll under Windows) are mentioned in the <a href="http://castle-engine.sourceforge.net/apidoc/html/introduction.html#SectionLibraries">Requirements -&gt; Libraries</a> section of our reference introduction. Under Windows, you will usually want to grab http://castle-engine.sourceforge.net/miscella/win32_dlls.zip and place them somewhere on your $PATH, or just place them in every directory with .exe files that you compile with our engine.

Now we'll start creating our own game from scratch.

------------------------------------------------------------------------------
2. Creating OpenGL context --- a window (TCastleWindow) or a Lazarus component (TCastleControl)

First of all, you need to initialize a rectangular area on the screen that will be able to display 3D content. This is called OpenGL context. There are two ways of doing this:

- You can use our own CastleWindow unit, that defines window class TCastleWindow. This gives you the most OpenGL capabilities (our TCastleWindow allows to request some funny stuff from OpenGL, not possible otherwise) and is usually best for 3D games.

You can develop such programs using Lazarus, or any other text editor. The only real requirement is having a FreePascal installed.

The left column of this tutorial will follow this way. We'll still be using Lazarus to compile our program, simply because it's the easiest and most popular method. But we will not use Lazarus form designer. As far as Lazarus is concerned, we're creating a "Custom Application" project.

-> Create new project using Lazarus "New Project" menu item. Choose "Custom Application".

Place this source code in your program file (lpr).

[[
var
  Window: TCastleWindow;
begin
  Window := TCastleWindow.Create(Application);
  Window.OpenAndRun;
end.
]]

Press "Run" and behold, a window! (without any contents drawn, so you will probably see the underlying screen contents underneath).

As you see, we give Application (this is defined in our CastleWindow unit) as the owner (first constructor parameter) of Window. This way we don't have to care about freeing it later. When the Application is freed (which is done automatically by CastleWindow unit finalization), the Window will be freed too. You can pass "nil" instead of "Application" if you really want to avoid this automatic memory management, and free things yourself. This whole "owner" mechanism is actually a normal behavior of ObjectPascal components.

- Alternative is to use our TCastleControl inside normal Lazarus form. Just pick TCastleControl from the component palette (tab "Castle") and drop it on a regular Lazarus form. This allows for seamless integration with the normal application design using Lazarus, as you have a normal Lazarus form where you can place normal buttons and such. The downside is that our TCastleControl inherits from Lazarus TOpenGLComponent, and it has some limitations (not all OpenGL features can be requested, sometimes mouse look may stutter a little because of Lazarus event loop processing).

To develop such programs you use Lazarus, period.

This tutorial doesn't suggest any particular method (TCastleWindow or TCastleControl). Both approaches make sense, really, and it's your choice. You should choose Lazarus method (TCastleControl) if you want to integrate game context with normal GUI (Lazarus forms, controls) or if you're just more comfortable with dropping components of a Lazarus form. If you want best OpenGL features, or if you're just more comfortable working outside of Lazarus (like with custom editor and only calling FPC through a script) then probably you want to choose TCastleWindow method. The difference is only how you start: create a TCastleWindow instance by code, or drop TCastleControl on a Lazarus form. Everything else goes *almost* the same, as the TCastleControl and TCastleWindow are designed specifically to resemble each other, so they both share similar methods and properties (like "Controls", where we add our engine 2D and 3D stuff).

In case of using Lazarus forms, you will usually want to place the initialization code inside your form's methods. In the simplest case, just place it inside the form's OnCreate event.

-> Create new project using Lazarus "New Project" menu item. Choose "Application". Drop TCastleControl on your form and resize it to fit the window. Press "Run" and behold :)

------------------------------------------------------------------------------
3. Creating 3D world --- scene manager

Actually, this step of the tutorial is already done for you: scene manager is already created and ready for use, in SceneManager property of the TCastleControl or TCastleWindow instance. But let's stop for a second to understand what scene manager <b>is</b>, as it's quite central idea to how you work with the engine.

Scene manager is a single TCastleSceneManager class instance that knows literally everything about your 3D world. It is essential to have it, and add all your 3D stuff to it.

In the simple scenario, by default TCastleSceneManager also acts as a viewport filling the whole window. So the whole OpenGL context is drawn to show your 3D world. In more complex scenarios you can have many smaller viewports inside your window using TCastleViewport controls (we'll not discuss it in this tutorial, see <a href="http://castle-engine.sourceforge.net/vrml_engine_doc/output/xsl/html/section.custom_viewports.html">custom viewports notes</a>, and <tt>multiple_viewports</tt> example in engine sources). You can also turn off scene manager from being a viewport (DefaultViewport := false), and then scene manager is really <b>only</b> something that keeps track of 3D world, and nothing more.

As I said, you actually already have SceneManager property of your window/control, so the work is done for you. If more advanced scenarios, you may want to create and manager scene managed yourself, see <a link to vrml_engine_doc about</a>.

------------------------------------------------------------------------------
4. Load a 3D model (simple approach to loading a game level or such)

We will now load a 3D model from file. This is basic way to load a game level, although you will learn a more advanced way later.

If you use a VRML/X3D file, this game level doesn't have to be static --- it can already include animated stuff, 3D sounds, scripts, and such.

- If you just want to try a ready level, download this 3D file (link to *standalone* vrml file, in a single x3d file, with no textures etc.). You can open it first with view3dscene to see how it looks like.

Or copy more interesting level model from castle_game_engine/examples/vrml/models/: copy bridge_final.x3dv, bridge.wrl, and textures/ subdirectory to your project.

- If you want, you can of course make your own new level. You can generally use any 3D modeler and export to any 3D format we can handle. Our other tutorial "how to make new level for CASTLE-2-NAME-HERE" (right now: DRAFT.modeling_tutorial.txt) describes from the basics how to use open-source Blender to create a level and export it to VRML/X3D. Highly advised reading! :)

To load a level, change your code to this:

[[
var
  Window: TCastleWindow;
  Scene: TCastleScene;
begin
  Scene := TCastleScene.Create(Application);
  Scene.Load('my_scene.x3d');
  Scene.Spatial := [ssRendering, ssDynamicCollisions];
  Scene.ProcessEvents := true;

  Window := TCastleWindow.Create(Application);
  Window.SceneManager.Items.Add(Scene);
  Window.SceneManager.MainScene := Scene;

  Window.OpenAndRun;
end.
]]

At the beginning we create a new instance of TCastleScene, and load it's contents from a file. Scene.Spatial determines what spatial structures (octrees for now) are created, the value [ssRendering, ssDynamicCollisions] is the most flexible one (it allows to speed up the rendering by frustum culling, detect collisions between player and level, and it adapts to a dynamic level that may have some animated parts). Scene.ProcessEvents activates animating VRML/X3D models (you can remove it if you know your level is, and always will be, static).

The level is added to the scene manager. The level is also set as the "MainScene" of scene manager, this means that some central settings (like initial camera position, initial headlight status and such) can be obtained from this scene.

------------------------------------------------------------------------------
5. Load a game level and a player

Instead of loading level like above, there is a slightly more comfortable and feature-rich way to load a level for a game: call the TGameSceneManager.LoadLevel method. Under the hood, TGameSceneManager.LoadLevel does eberything mentioned above --- the new 3D model is loaded, and added to the SceneManager.Items, and set as SceneManager.MainScene. But it also does some additional work, like detecting a "placeholders" in your 3D model, which should be replaced with creatures (from CastleCreatures unit) and items (from CastleItems unit).

It is also integrated with CastleLevels definition of what a "level" is: namely, it's a level.xml file referencing a 3D model and describing some additional level properties.t

The TGameSceneManager class allows you to define levels by using simple XML files. For each level, you create a file named "level.xml", with contents like this:

[[
<?xml version="1.0"?>
<level
  name="pits"
  type="Level"
  scene="pits.x3dv"
  title="The Pits of Azeroth"
/>
]]

- "name" is a unique internal name for the level, it will come in handy soon.
- "type" identifies the ObjectPascal class handling the level logic --- type "Level" is always available, for advanced games you can also create and use your own level logic types.
- "scene" is a filename of the 3D model containing the level.
- and "title" is just used for some logging and messages. Depending on your game, you may also find this title useful for other purposes, e.g. show the user a list of levels available to start. But this is up to you. The engine itself doesn't really make much use of the title.

See http://svn.code.sf.net/p/castle-engine/code/trunk/castle_game_engine/doc/README_about_index_xml_files.txt for more details about the level.xml and resource.xml files (defining levels and other stuff).

Traditionally, I place each level in a subdirectory of data/levels/, along with it's associated 3D models. So I have a structure like this:

[[
data/
  levels/
    pits/
      level.xml
      pits.x3dv
    swamp/
      level.xml
      swamp.x3dv
    mountains/
      level.xml
      mountains.x3dv
    ...
]]

Although this convention proved comfortable, it's not forced at all. The 3D models files may live in other directories than level.xml files, as "scene" field may contain a relative filename (in future, it should be possible to use there any absolute or relative URL; for now, only filenames are allowed). And level.xml files may be scattered throughout your directory as you wish. And what is "data directory" is configurable (by LevelsAvailable.LoadFromFiles optional parameter, by default we use ProgramDataPath). It's only important that the XML files have names "level.xml".

You can now start a game by creating a player, loading all levels informations from their level.xml files, and finally loading your desired level by referring to it's "name" field:

[[
  LevelsAvailable.LoadFromFiles;
  SceneManager.LoadLevel('base');
]]

The LoadLevel will clear all SceneManager.Items (except Player, more about this in a second). Then it will load new 3D model with a level (adding it to SceneManager.Items and setting as SceneManager.MainScene, just as we did manually in previous chapter), and do some more interesting stuff that we'll learn later.

The important thing here is that (except the "name" of the 1st level) levels are not hardcoded in any way in your program. This makes game data nice for people preparing new content: they can just drop new subdirectory into the data/levels/, and if it will contain proper level.xml file, it will be automatically recognized. A similar scheme will be used for creatures/items in the following chapter. Your game data is immediately friendly to MODders.

For a good measture, it will also be handy later to have a central Player object. This is used for various things:
- It will make camera automatically tied to the Player, making it a first-person perspective game. (More camera approach, like third-person view, will be available later.)
- It's also a central enemy of all hostile creatures created using CastleCreatures unit. This will be more configurable in the future.

To load a Player do this (before or after loading a level --- doesn't matter; conceptually, it's cleaner to do this before loading new level, but things will work either way).

[[
var
  Player: TPlayer;
...
  Player := TPlayer.Create(SceneManager);
  SceneManager.Items.Add(Player);
  SceneManager.Player := Player;
]]

------------------------------------------------------------------------------
6. Adding creatures and items

Thanks to using TGameSceneManager and LoadLevel, you actually don't need to do much. We have a nice default handling of creatures and items suitable for 3D games in CastleCreatures and CastleItems units.

Creatures/items are XML files named resource.xml with the <resource> root node. See for now castle1 daya for examples how such file looks like, e.g. castle/data/creatures/alien/resource.xml . See http://svn.code.sf.net/p/castle-engine/code/trunk/castle_game_engine/doc/README_about_index_xml_files.txt for more details about the properties you can set in resource.xml files.

The common properties about creatures, items and levels resource.xml and level.xml files:

- "name", like mentioned before, this is a unique internal name of the level/resource (resource being creature or item). In case of resources (creatures or items), it's particularly useful, as it can be used as Blender's object name to place initial creatures/items on the level inside Blender.
- "type" refers to ObjectPascal class handling the actual behavior of this resource. We provide various simple creatures/items, you can also extend our classes to create your own types.

There really isn't much code here. Just add

[[
  AllResources.LoadFromFiles;
]]

call somewhere before loading the level. This will cause all information about the creatures and items automatically loaded. Necessary creatures and items will be nicely prepared for each level if you use the <resources> section the levels level.xml files. Some resources may also be prepared always (see T3DResource.AlwaysPrepare).

The "type" of the creatures determines it's ObjectPascal class, in turn determining creature AI, how many 3D models (or states) it has, and various other properties. Hostile creatures are automatically hostile to our Player.

Items are automatically pickable by player, player backpack is automatically managed.

CastleCreatures unit (see inside src/game/ in sources) allows you to easily create creatures with artificial intelligence.

((TODO: describe player.xml somewhere later.)

6.1. For starters, you can just use the existing creature classes on CastleCreatures unit.

  To get walk-attack-state intelligence, use the TWalkAttackCreatureKind class. Such creature tracks the player (remembers last seen player 3D position, walks/flies to it, possibly through sectors/waypoints — so it can pass through narrow doors in a labyrinth or walk over a narrow bridge), attacks the player from the right distance (this can be either a melee attack, or shooting a missile — which adds a missile to the 3D world), eventually runs from the player (when he's too close and/or our health is low). For now, the player is always the main enemy, and there's no "creature vs creature" fighting, although it can be added easily in the future.

  For basic usage, there's no need to even derive new classes. All you need to do is to create a directory holding creature 3D data and resource.xml describing it (for example, see various subdirectories of castle/data/creatures/ in SVN).

  There are a lot of settings to achieve particular behavior, e.g. cowardly/brave, offensive/defensive, melee/ranged, etc.

  There is also a "missile" intelligence (TMissileCreatureKind), that causes the creature to blindly go in given direction (possibly with gravity and/or homing (close-on-target) features). On impact, missile may explode, hurting player and/or other creatures. Any kind of missile, like arrow or lighting bolt, is represented as such "missile creature", that flies independently of the shooter.

  And there is a TStillCreatureKind that just stands still (it can still show some looping animation, but there is no fancy logic behind it).

6.2. You can also derive simple descendants of CastleCreatures classes, to customize their behavior. For example, "The Castle" customizes walk-attack creature to give both ranged and melee attacks to the Spider Queen, to make werewolves howl from time to time, and such. See castle1 GameCreatures.pas unit sources. We plan to add a simple FPS game to the engine examples, to illustrate this nicer.

  You can start your customizations from full-features classes, like TWalkAttackCreatureKind and TWalkAttackCreature. Or you can take the basic TCreatureKind and TCreature, and extend them to your liking.

  This is a good moment to browse the API reference of mentioned CastleCreatures classes, if you haven't already. See
  * [TWalkAttackCreatureKind], [TWalkAttackCreature]
  * [TMissileCreatureKind], [TMissileCreature]
  * [TStillCreatureKind], [TStillCreature]
  * [TCreatureKind], [TCreature]
  * And see the class hierarchy descending from TCreatureKind and TCreature in [class hierarchy diagram]

  Everything is designed to give you a lot of properties to set (most of them are also settable by resource.xml files mentioned above) and a lot of methods to override. See not only the TCreature* classes, but also see above T3D classes in Base3D unit, for various things that you can override and use.

  (TODO: Pasdoc: frame-less layout, to make direct links sensible.
   TODO: Pasdoc: separate pascal_code_formatter, with @longCode formatter extracted, to convert pascal code to HTML-ified or LaTeX-ified output. HTML can of course be adjusted with CSS. I want to have many code snippets in this tutorial (see e.g. Symfony2 docs for inspiration.)

6.3. (After creatures and items section, section "More stuff in your 3D world?")

  Our creature and items classes in CastleCreatures and CastleItems units are not magic, they do not get any special treatment from the scene manager. Instead, they just extend the base 3D classes in Base3D unit. There are ready classes to represent 3D things, that can move, can collide with other 3D stuff and such. If you find that our creatures/items design is not enough for you, or maybe you want to have in your 3D world something that doesn't really fit the creature/item definition, you can always derive new classes from the Base3D classes. Like T3DAlive, T3DOrient, T3DTransform. Methods Move, MoveAllowed, Height, LineOfSight allow you to add any kind of movement/intelligence to any 3D object.

---
Sidenote: Which way is up?
There are various conventions for which vector is "up" in 3D world and, consequently, which vector corresponds to the "direction" the creature/player is facing.

Quick guide:
- If you want to follow "+Y is up" convention (easier, i.e. you don't really need to do anything):
  - When exporting from Blender (levels, creatures etc.), let it rotate the model, i.e. change +Z to +Y. This is actually the default for X3D exporter since some time.
  - Make sure your Viewpoint indicates +Y as up vector. This is actually the default VRML/X3D value.
  - Leave T3DOrient.DefaultOrientation at default otUpYDirectionMinusZ.
- If you want to follow "+Z is up" convention:
  - When exporting from Blender (levels, creatures etc.), always select to *not* rotate the model, i.e. keep Blender's coordinate system.
  - Make sure you use view3dscene (or other VRML/X3D editor) to generate a Viewpoint in your level that makes gravity working in Z axis.
  - Set T3DOrient.DefaultOrientation := otUpZDirectionX.

Detailed discussion about what the issue: There are two common conventions:

1. Most 3D modeling software, like Blender, prefers the up direction to be +Z, and direction to be -Y. This is usually sensible when you think about a flat level, with XY representing the map view, and additional Z adding the height.

2. On the other hand, VRML/X3D and default OpenGL camera prefers the up to be +Y, and direction to be -Z. This makes sense if you think about the screen as being the XY plane, so then if you look straight (in the right-hand coordinate system) you look in -Z direction.

You can also easily imagine other conventions, as you can really pick any 3D vector as "up", and pick anything orthogonal to it as "direction".

Our engine supports various such conventions, we do not force you to follow any particular one. To make things work smoothly, you want to keep the same conventions throughout your process &mdash; be wary of this when creating T3DOrient instances in the engine, when exporting 3D models from Blender, when setting viewpoint (with gravity) in whatever way etc.

Note that Blender (and other 3D modeling software?) by default rotates models when exporting to X3D, to turn +Z into +Y. On one hand, this means that some things will "just work" (you use +Z convention inside Blender, and you get +Y convention inside VRML/X3D). On the other hand, this may create a little confusion if you manually probe some positions in Blender model and type them in X3D code (or ObjectPascal code using our engine): since Blender rotated the models, we necessarily "see" a different coordinate system than what you see in Blender.

For this reason, you may decide to disable this "rotation on export" feature, and instead decide to work with VRML/X3D files where +Z is "up".

VRML/X3D is flexible in this regard: although the default is to have up in +Y, the specification says that up is +Y transformed by the Viewpoint node transformation, and we honour it. In short, this means that gravity is configurable in VRML/X3D file. You can setup your camera in view3dscene, use "Navigation -> Walk and Fly settings -> Change Up Vector", input any vector you want (like "0 0 1"), then use "Console -> Print Current Camera..." option, and copy-paste the generated code from the console to your VRML/X3D file. This will set a Viewpoint with desired up vector, which will be correctly used by our engine (and other good VRML/X3D browsers actually) for gravity.

The notion of direction/up is used by our engine in two places:

1. Gravity pulls things (player, items, creatures...) down in the -up vector. We automatically detect this based on the gravity vector of the Viewpoint inside your TCastleSceneManager.MainScene (you usually want to set this to your level 3D model). This means that we follow VRML/X3D specification, and gravity vector is derived from the 3D model of your level. You can use e.g. view3dscene to generate Viewpoint node with a desired gravity vector. You can read this vector by looking at TCastleSceneManager.GravityUp, TCastleSceneManager.Camera.GravityUp, and World.GravityUp (from any T3D code), these are always equal.

2. Oriented 3D things, like creatures, player, and items (and anything else derived from T3DOrient class) are always oriented such that their local direction/up is matching the vectors defined by T3DOrient.Orientation property. Although the publicly visible properties like TCreature.Up are automatically set to be *usually* equal to the World.GravityUp (in case of flying creatures, it may actually be different sometimes). But you still have to set the T3DOrient.Orientation yourself, to make the local creature model correctly match these vectors. You want to set it such that typical up of your creatures changes into World.GravityUp (that is, creature's up remains untransformed).

Usually, you want to just set T3DOrient.DefaultOrientation, and then it will be used for all your models.
---

------------------------------------------------------------------------------
7. More manual way of adding new items

((Maybe remove this chapter / rewrite this?

In new engine version, we have comfortable classes to store item information (TInventoryItem) and visible item on level (TItemOnLevel) and creature (TCreature). However, for advanced usage, it's possible that the traditional concepts of "items that can be picked", "creatures" will not suit you particular game. So the chapter is still somewhat relevant: it's important that our 3D system is designed around flexible T3D class, that you can group (T3DList) and transform (T3DTransform). You can freely design your own descendants of T3DXxx classes, and have all the flexibility you want in creating... well, anything you want in your 3D world.

So, this chapter is probably still relevant, but it should be simplified and rewritten.
))

For the sake of our engine, an item is just a 3D object. So basically, you can just add any T3D descendant (like TCastleScene or TCastlePrecalculatedAnimation) to a scene manager, exactly like we added a level scene in previous section.

However, you usually have a lot of item instances showing the same item. For example, you may place hundreds of potions on a level, and you probably want to add/delete potions on your level quickly. At the same time, you want to load (read from disk, and optimize for OpenGL rendering) only a single potion item. Each potion visible on the level just renders the same 3D model, possibly moved/rotated in a different way.

This means that want to think about two concepts separately: a <b>type</b> of item (like potion, sword, etc.) and an <b>instance</b> of this item in visible 3D world (like "potion lying beside the front door", "other potion hidden behind a secret corridor", "yet another potion not visible yet but in player's backpack", "a sword lying somewhere" and such). Don't confuse the terms <b>type</b> and <b>instance</b> here with ObjectPascal concepts. In our program, we will want to have a class (and it's instance) representing a potion, and a class (and many instances) representing each place where potion exists.

Our engine allows you to do this in a flexible way. We have many 3D objects that keep only references to other 3D objects. In particular, T3DTransfrom keeps a reference to other 3D object(s), and transforms (translates (moves), rotates, scales) them.

So you can create an instance of TCastleScene where you load an item, like potion. Then you create as many as you like instances of T3DTransform, where you add your potion as a children. Additionally, at T3DTransform, you can setup the transformation (like translation) of your item.

[[
var
  PotionType: TCastleScene;
  PotionInstance1, PotionInstance2: T3DTransform;

{ ... somewhere in begin...end block ... }
  PotionType := TCastleScene.Create(Application);
  PotionType.Load('my_scene.x3d');
  PotionType.ProcessEvents := true; // if the item model has interactive/animated parts by VRML/X3D events

  PotionInstance1 := T3DTransform.Create(Application);
  PotionInstance1.Translation := Vector3Single(1, 2, 3);
  PotionInstance1.Add(PotionType);
  SceneManager.Items.Add(PotionInstance1);

  PotionInstance2 := T3DTransform.Create(Application);
  PotionInstance2.Translation := Vector3Single(4, 5, 6);
  PotionInstance2.Add(PotionType);
  SceneManager.Items.Add(PotionInstance2);
]]

For more advanced uses, you may want to create your own class for TPotionType (descending from TCastleScene, and adding additional information, for example is this a "life potion", "mana potion", "cure potion" etc. --- we assume these potions have different 3D models, but also share some common parameters and so they want to be treated under a common class TPotionType). Also, you may want to create your own class for TPotionInstance (descending from T3DTransform, and adding additional information like "how much percent of this potion is used up (drink)"). No surprises here, you can do all this by following standard ObjectPascal syntax and conventions, example:

[[
type
  TPotionEffect = (peLife, peMana, peCurePoison);

  { A potion properties and 3D model. }
  TPotionType = class(TCastleScene)
    Effect: TPotionEffect;
    CreaturesMayPickItUp: boolean;
    FlameResistant: boolean;
  end;

  { A potion instance. This always refers to exactly one item inside
    of class TPotionType (you can use "(Items[0] as TPotionType)" to get it,
    you can introduce a method here to get it comfortably).
    When it is visible on a level (that is, added to SceneManager items
    graph), the Translation determines it's position on a level. }
  TPotionInstance = class(T3DTransform)
    PercentUsed: Integer;
  end;

var
  LifePotionType,
  ManaPotionType: TPotionType;
  LifePotionInstance1,
  LifePotionInstance2,
  ManaPotionInstance1: TPotionInstance;

{ ... somewhere in begin...end block ... }
  LifePotionType := TPotionType.Create(Application);
  LifePotionType.Load('life_potion.x3d');
  LifePotionType.Effect := peLife;

  ManaPotionType := TPotionType.Create(Application);
  ManaPotionType.Load('mana_potion.x3d');
  LifePotionType.Effect := peMana;

  LifePotionInstance1 := TPotionInstance.Create(Application);
  LifePotionInstance1.Translation := Vector3Single(1, 2, 3);
  LifePotionInstance1.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 50;
  SceneManager.Items.Add(LifePotionInstance1);

  LifePotionInstance2 := TPotionInstance.Create(Application);
  LifePotionInstance2.Translation := Vector3Single(4, 5, 6);
  LifePotionInstance2.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 12;
  SceneManager.Items.Add(LifePotionInstance2);

  ManaPotionInstance1 := TPotionInstance.Create(Application);
  ManaPotionInstance1.Translation := Vector3Single(4, 5, 6);
  ManaPotionInstance1.Add(ManaPotionType);
  SceneManager.Items.Add(ManaPotionInstance1);
]]

------------------------------------------------------------------------------
8. Display player life and weapon

You often want to display something 2D on player screen. Let's draw a simple meter showing your life points.

TODO: demo of simple TUIControl creation

To show a weapon, or other stuff glued to the player, just add 3D things to TPlayer list. They will be automatically oriented to follow the player position and orientation.
TODO: describe also the Overlay attribute here, for now not available.

------------------------------------------------------------------------------
9. Adding some sounds

As with many other operations, you can add and control sounds to your game either by Pascal code, or by editing your data files. This gives flexibility both to a programmer and the content designer. It's your choice which approach you use &mdash; usually it's better to keep as much as possible in data files, and use code only when necessary for non-trivial situations.

--- Loading and playing sound inside VRML/X3D

First, get a sample sound file and place it within your game data. You can use this sample.wav file.

To add a looping sound to your VRML/X3D file, just open xxx.x3dv and paste there this:

[[
Sound {
  source AudioClip { url "sample.wav" loop TRUE }
}
]]

Remember that URL "sample.wav" is specified relative to the location of your xxx.x3dv file. In the simplest case, just place both xxx.x3dv and sample.wav in the same directory, and you're fine.

--- Loading and playing sound inside ObjectPascal code

To play a sound from a code, add this code:

[[
var
  Buffer: TSoundBuffer;
...
Buffer := SoundEngine.LoadBuffer('sample.wav');
SoundEngine.PlaySound(Buffer, ...); // see PlaySound reference for parameters
]]

You can free the buffer once the sound has stopped. It's not important for simple programs, as we will take care to always free it before closing OpenAL context.

--- Sounds repository

Larger games may find it comfortable to define a repository of sounds in an XML file, conventionally named data/sounds/index.xml. See TXmlSoundEngine docs and castle1 game data for example. Assuming your <tt>data/sounds/index.xml</tt> looks like this:

[[
<?xml version="1.0"?>
<sounds>
  <sound name="sample" file_name="sample.wav" />
  <!-- Actually, you can omit the file_name, it's the same
    as name with .wav extension.
    Also, you can add a lot of interesting attributes here, like
    default_importance, gain, min_gain, max_gain --- see TODO. -->
</sounds>
]]

Then you can initialize it inside your game code like this:

[[
SoundEngine.SoundsXmlFileName := ProgramDataPath + 'data' +
  PathDelim + 'sounds' + PathDelim + 'index.xml';
]]

This allows to play sounds like this from ObjectPascal code:

[[
var
  SoundType: TSoundType;
...
SoundType := SoundEngine.SoundFromName('sample');
SoundEngine.Sound3D(SoundType, Vector3Single(1, 2, 3), false { looping });
SoundEngine.Sound(SoundType, false { looping }); // non-3D sound
]]

The SoundEngine.Sound3D and SoundEngine.Sound are a little simpler to use than SoundEngine.PlaySound, they have fewer parameters. That is because the default sound properties (it's individual gain, importance (priority), actual filename and other stuff) is already recorded in the data/sounds/index.xml file. That's one advantage of using the sounds repository: all your sounds properties are centrally stored in the data/sounds/index.xml file.

You can also refer to your sound names from VRML/X3D AudioClip node, using the "sounds-repository" protocol:

[[
Sound {
  source AudioClip { url "sounds-repository:sample" loop TRUE }
}
]]

--- More

For more advanced uses, you can use the return value of PlaySound or Sound or Sound3D: it's either nil (if no OpenAL resources available to play this sound, and it's priority doesn't allow overriding other sounds) or it's a TSound instance. If you have TSound instance, you can use it's TSound.OnRelease event to be notified when source stops playing. You can also use other TSound methods, e.g. update TSound.Position, TSound.Gain and such. You can stop playing the sound by TSound.Release.

------------------------------------------------------------------------------
10. Adding an on-screen menu

Our TCastleWindow or TCastleControl have a list of 2D controls visible of the screen. By default, the only thing present there is a scene manager (since scene manager acts as a 2D viewport through which you see the 3D world; that's right --- the 3D stuff is "within" the 2D stuff). This way the scene manager (it's viewport) is visible on the window, which in turn means that all the 3D stuff we will add next is visible too.

You can add your own 2D controls using the Window.Controls.Add call. There are many predefined GUI controls available in our engine, look for TUIControl descendants, for example in CastleControls unit. You can also derive your own controls with ease.

For a simple on-screen menu, where all the menu items are displayed vertically on the screen, use the TCastleOnScreenMenu control. For Lazarus: drop TCastleOnScreenMenu on the form. For TCastleWindow: just create TCastleOnScreenMenu instance. Fill it's Items property (each line is a menu entry), and assign a handler for the OnClick event (to react when user chose menu item, by clicking or pressing enter key). Inside OnClick event, the CurrentItem property of your TCastleOnScreenMenu instance tells you which item was clicked. You still have to add a code to TForm.OnCreate to add this to controls list, like

  Browser.Controls.Insert(0, OnScreenMenu1);

You may also want to change the position, like

  OnScreenMenu1.Position := Vector2Integer(100, 100);
  { you may also want to set PositionRelativeMenu* (through object inspector or code) }

There is an example of this in model_3d_with_2d_controls example in engine sources, look for OnScreenMenu1 references in code.

------------------------------------------------------------------------------
11. Background under on-screen menu

In addition to previous point, you may want to change the menu TCastleOnScreenMenu.FullSize to true. Otherwise, menu receives input only when mouse hovers over it. When FullSize, the menu obscures completely controls under it for key processing (although they are still visible as a background).

- So if you want your menu to be displayed and used orthogonally to the "live" 3D world underneath, leave FullSize = false.
- For initial game menu with items like "New Game", you probably want to disable the camera input for this scene. This allows you to display interactive 3D scene in the background, but block user from interacting with it (after all, the user should only interact with your menu on the initial screen). To do this simply set FullSize = true.

An alternative method to achieve (part) of 2nd choice is to set background level camera's Input := []. This also blocks user from moving in the scene (although it doesn't make input passed to menu regardless of mouse position).

If you want to place a static 2D image under menu, you can use TCastleImageControl underneath, instead of 3D scene.

------------------------------------------------------------------------------
12. Making screenshots

Making a screenshot is very easy:

[[
var
  Image: TRGBImage;
begin
  Image := Control.SaveScreen;
  try
    SaveImage(Image, 'screenshot_name.png');
  finally FreeAndNil(Image) end;
end;
]]

TRGBImage, and it's ancestor TCastleImage and many other similar classes, is defined in the unit Images. This provides various image loading, saving and processing utilities to our engine. By having our own image handling unit, we can store images in the format best suitable for 3D graphics libraries, like OpenGL (for example, our class TS3TCImage to handle S3TC compressed images is tightly integrated there; we also handle there 3D textures).

Still, we use the excellent FPC FpImage library to load/save some image formats underneath. So we do not implement everything from stratch here, we *are* using FpImage loading/saving features.

------------------------------------------------------------------------------
13. Recoding movies
(Not really useful for an interactive game, but useful for various 3D viewers)

If you have a predefined animation in VRML/X3D (meaning: it plays without any user interaction), and want to record with constant number of frames per second, you can do this:

[[
in a loop:
begin
  SceneManager.MainScene.IncreaseTime(FrameTime);
  SceneManager.Camera.Idle(FrameTime, true, DummyBooleanInitializedToTrue);

  { capture and save screen as before, like: }
  Image := Control.SaveScreen;
  try
    { add your image to the movie sequence.
      Various options possible, view3dscene for now just saves a sequence
      of images to temporary location and later processes them by ffmpeg
      to produce a full movie. }
    SaveImage(Image, Format('screenshot_name_%4d.png', [FrameNumber]));
  finally FreeAndNil(Image) end;
end;
]]

IOW, you manually force the current time of the scene/camera to increase as much as you want before each screenshot. This makes it work 100% reliably, without any worries how fast you can process captured images.

The time of the scene and of the camera is actually independent. You can remove the "MainScene.IncreaseTime" call, if you know that your scene stays static (and want to force it to look like static), and want to animate only camera. Or the other way around, if your camera is static (or you want to force it to be static) but you have an animation in VRML/X3D, you can remove the "Camera.Idle" line.

FrameTime is in seconds, as both TCastleSceneCore.IncreseTime and TCamera.Idle take it's time argument in seconds. But don't worry, this is a float, so actually it honors fractions of seconds as well. So something like 1/25 to get 25 frames per second is Ok.

------------------------------------------------------------------------------
14. Logging

Easy: Use CastleLog, call InitializeLog, and you have your log on stderr. A lot of engine components will immediately use it. To use it yourself, do

[[
if Log then
  WritelnLog('Category', 'My Log Message');
]]

('Category' is useful to easily spot your messages later. There are no hard rules about it, i.e. you're free to just invent your own category names here, like 'Creatures' or 'Rendering'.)

------------------------------------------------------------------------------
15. User preferences

Easy: Use CastleConfig. Various engine components automatically register that they can load/save user preferences. So

[[
{ make sure you have created all stuff that registers user preferences first }
SoundEngine; // if you want to save sound config
RecentMenu := TCastleRecentFiles.Create(nil); // if you use "recent files" menu

{ make sure application name is correct if you want by setting OnGetApplicationName, like this : }

function MyGetApplicationName: string;
begin
  Result := 'glplotter';
end;

...
  OnGetApplicationName := @MyGetApplicationName;

{ load config from file }
Config.Load;

... { do your program }

{ save config to file }
Config.Save;
]]
