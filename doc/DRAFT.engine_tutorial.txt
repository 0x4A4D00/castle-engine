TODO: This is a work in progress. I want to finish this for engine 2.6.0 release. This is supposed to be a full tutorial how to make an FPS game, from the basics.

The tutorial handles both alternatives for creating OpenGL context: as Lazarus component (on Lazarus form), or as our TGLWindow instance. Appropriate parts of the tutorial will be in 2-column view to visualize this.

------------------------------------------------------------------------------
0. Introduction

This tutorial shows how to make a simple 3D first-person game using our <i>Kambi VRML game engine</i>. We'll explain the basics of our engine, show you some simple programs and mention the most important classes.

Throughout this tutorial you will see a links to our <a>engine reference</a>, and you will eventually want to follow them to read detailed reference of stuff that interests you. Note that you can also just read the units source code --- the reference is automatically generated from the comments in the units interface, so if you're brave enough, you can just dive straight into the source.

1. Download and install the engine, try the demos

If you haven't done it yet, download the engine source code with examples from ....

Run Lazarus, and open packages in the castle_game_engine/packages/ subdirectory. Open and compile all three packages (kambi_base.lpk, kambi_components.lpk, kambi_glwindow.lpk), to test that things compile OK. Then install the package <i>kambi_components</i>. (Do not install kambi_glwindow --- you don't want to have this installed in Lazarus. You can install kambi_base explicitly, but there's no need to: installing kambi_components will also install kambi_base automatically.)

Once packages are successfully installed, Lazarus restarts, and you should see "Kambi" tab of components at the top (screenshot). Sorry, we don't have icons for our components yet, so it looks a little boring. Mouse over the icons to see component names.

Let's quickly open and run some demos, to make sure that everything works. I suggest running ... (some LCL demo) and ... (some glwindow demo).

Make sure you have installed the necessary libraries first, or some of the demos will not work. The required libraries (.so under Unix, .dll under Windows) are mentioned in the <a href="http://vrmlengine.sourceforge.net/apidoc/html/introduction.html#SectionLibraries">Requirements -&gt; Libraries</a> section of our reference introduction. Under Windows, you will usually want to grab http://vrmlengine.sourceforge.net/miscella/win32_dlls.zip and place them somewhere on your $PATH, or just place them in every directory with .exe files that you compile with our engine.

Now we'll start creating our own game from scratch.

2. Creating OpenGL context --- a window (TGLUIWindow) or a Lazarus component (TKamOpenGLControl)

First of all, you need to initialize a rectangular area on the screen that will be able to display 3D content. This is called OpenGL context. There are two ways of doing this:

- You can use our own GLWindow unit, that defines window class TGLUIWindow. This gives you the most OpenGL capabilities (our TGLUIWindow allows to request some funny stuff from OpenGL, not possible otherwise) and is usually best for 3D games.

You can develop such programs using Lazarus, or any other text editor. The only real requirement is having a FreePascal installed.

In this tutorial, we'll follow this way. We'll still be using Lazarus to compile our program, simply because it's the easiest and most popular method. But we will not use Lazarus form designer. As far as Lazarus is concerned, we're creating a "Custom Application" project.

-> Create new project using Lazarus "New Project" menu item. Choose "Custom Application".

Place this source code in your program file (lpr).

[[
var
  Window: TGLUIWindow;
begin
  Window := TGLUIWindow.Create(Application);
  Window.OpenAndRun;
end.
]]

Press "Run" and behold, a window! (without any contents drawn, so you will probably see the underlying screen contents underneath).

- An alternative is to use our TKamOpenGLControl inside normal Lazarus form. Just pick TKamOpenGLControl from the component palette (tab "Kambi") and drop it on a regular Lazarus form. This allows for seamless integration with the normal application design using Lazarus, as you have a normal Lazarus form where you can place normal buttons and such. The downside is that our TKamOpenGLControl inherits from Lazarus TOpenGLComponent, and it has some limitations (not all OpenGL features can be requested, sometimes mouse look may stutter a little because of Lazarus event loop processing).

To develop such programs you use Lazarus, period.

This tutorial suggests using the 1st method, GLWindow, not TKamOpenGLControl. But it's really your choice, for TKamOpenGLControl you only start differently: instead of creating a TGLUIWindow instance, you add TKamOpenGLControl to a form. Everything else goes *almost* the same, as TKamOpenGLControl is designed specifically to resemble TGLUIWindow, so they both share similar methods and properties (like "Controls", where we add our engine 2D and 3D stuff).

In case of using Lazarus forms, you will usually want to place the initialization code inside your form's methods. In the simplest case, just place it inside the form's OnCreate event.

-> Create new project using Lazarus "New Project" menu item. Choose "Application". Drop TKamOpenGLControl on your form and resize it to fit the window. Press "Run" and behold :) Then follow the rest of the tutorial, with minimal adjustments.

3. Creating 3D world --- scene manager

Scene manager is a single TKamSceneManager class instance that knows literally everything about your 3D world. It is essential to create it, and add all your 3D stuff to it.

In the simple scenario, by default TKamSceneManager also acts as a viewport filling the whole window. So the whole OpenGL context is drawn to show your 3D world. In more complex scenarios you can have many smaller viewports inside your window, but we'll not dive there in this tutorial (see <a href="http://vrmlengine.sourceforge.net/vrml_engine_doc/output/xsl/html/section.custom_viewports.html">Custom viewports notes</a>, and <tt>multiple_viewports</tt> example in engine sources, if you're interested in this).

Change your code to initialize scene manager:

[[
var
  Window: TGLUIWindow;
  SceneManager: TKamSceneManager;
begin
  SceneManager := TKamSceneManager.Create(Application);

  Window := TGLUIWindow.Create(Application);
  Window.Controls.Add(SceneManager);
  Window.InitAndRun;
end.
]]

As you see, we give Application (this is defined in our GLWindow unit) as the owner (first constructor parameter) of both SceneManager and Window. This way we don't have to care about freeing them later. When the Application is freed (which is done automatically by GLWindow finalization), the SceneManager and Window will be freed too. You can pass "nil" instead of "Application" if you really want to avoid this automatic memory management, and free things yourself. This whole "owner" mechanism is actually a normal behavior of ObjectPascal components.

The important new line is the Window.Controls.Add call. This way the scene manager (it's viewport) is visible on the window, which in turn means that all the 3D stuff we will add next is visible too.

4. Adding your game level

We will load a game level from a 3D file. If you use a VRML/X3D file, this game level doesn't have to be static --- it can already include animated stuff, 3D sounds, scripts, and such.

- If you just want to try a ready level, download this 3D file (link to *standalone* vrml file, in a single x3d file, with no textures etc.). You can open it first with view3dscene to see how it looks like.

Or copy more interesting level model from castle_game_engine/examples/vrml/models/: copy bridge_final.x3dv, bridge.wrl, and textures/ subdirectory to your project.

- If you want, you can of course make your own new level. You can generally use any 3D modeler and export to any 3D format we can handle. Our other tutorial "how to make new level for CASTLE-2-NAME-HERE" (right now: DRAFT.modeling_tutorial.txt) describes from the basics how to use open-source Blender to create a level and export it to VRML/X3D. Highly advised reading! :)

To load a level, change your code to this:

[[
var
  Window: TGLUIWindow;
  SceneManager: TKamSceneManager;
  Scene: TVRMLGLScene;
begin
  Scene := TVRMLGLScene.Create(Application);
  Scene.Load('my_scene.x3d');
  Scene.Spatial := [ssRendering, ssDynamicCollisions];
  Scene.ProcessEvents := true;

  SceneManager := TKamSceneManager.Create(Application);
  SceneManager.Items.Add(Scene);
  SceneManager.MainScene := Scene;

  Window := TGLUIWindow.Create(Application);
  Window.Controls.Add(SceneManager);
  Window.InitAndRun;
end.
]]

At the beginning we create a new instance of TVRMLGLScene, and load it's contents from a file. Scene.Spatial determines what spatial structures (octrees for now) are created, the value [ssRendering, ssDynamicCollisions] is the most flexible one (it allows to speed up the rendering by frustum culling, detect collisions between player and level, and it adapts to a dynamic level that may have some animated parts). Scene.ProcessEvents activates animating VRML/X3D models (you can remove it if you know your level is, and always will be, static).

The level is added to the scene manager. The level is also set as the "MainScene" of scene manager, this means that some central settings (like initial camera position, initial headlight status and such) can be obtained from this scene.

5. Adding some items

For the sake of our engine, an item is just a 3D object. So basically, you can just add any T3D descendant (like TVRMLGLScene or TVRMLGLAnimation) to a scene manager, exactly like we added a level scene in previous section.

However, you usually have a lot of item instances showing the same item. For example, you may place hundreds of potions on a level, and you probably want to add/delete potions on your level quickly. At the same time, you want to load (read from disk, and optimize for OpenGL rendering) only a single potion item. Each potion visible on the level just renders the same 3D model, possibly moved/rotated in a different way.

This means that want to think about two concepts separately: a <b>type</b> of item (like potion, sword, etc.) and an <b>instance</b> of this item in visible 3D world (like "potion lying beside the front door", "other potion hidden behind a secret corridor", "yet another potion not visible yet but in player's backpack", "a sword lying somewhere" and such). Don't confuse the terms <b>type</b> and <b>instance</b> here with ObjectPascal concepts. In our program, we will want to have a class (and it's instance) representing a potion, and a class (and many instances) representing each place where potion exists.

Our engine allows you to do this in a flexible way. We have many 3D objects that keep only references to other 3D objects. In particular, T3DTranslated keeps a reference to other 3D object(s), and translates (moves) it.

So you can create an instance of TVRMLGLScene where you load an item, like potion. Then you create as many as you like instances of T3DTranslated, where you add your potion as a children. Additionally, at T3DTranslated, you can setup the translation of your item.

[[
var
  PotionType: TVRMLGLScene;
  PotionInstance1, PotionInstance2: T3DTranslated;

{ ... somewhere in begin...end block ... }
  PotionType := TVRMLGLScene.Create(Application);
  PotionType.Load('my_scene.x3d');
  PotionType.ProcessEvents := true; // if the item model has interactive/animated parts by VRML/X3D events

  PotionInstance1 := T3DTranslated.Create(Application);
  PotionInstance1.Translation := Vector3Single(1, 2, 3);
  PotionInstance1.Add(PotionType);
  SceneManager.Items.Add(PotionInstance1);

  PotionInstance2 := T3DTranslated.Create(Application);
  PotionInstance2.Translation := Vector3Single(4, 5, 6);
  PotionInstance2.Add(PotionType);
  SceneManager.Items.Add(PotionInstance2);
]]

For more advanced uses, you may want to create your own class for TPotionType (descending from TVRMLGLScene, and adding additional information, for example is this a "life potion", "mana potion", "cure potion" etc. --- we assume these potions have different 3D models, but also share some common parameters and so they want to be treated under a common class TPotionType). Also, you may want to create your own class for TPotionInstance (descending from T3DTranslated, and adding additional information like "how much percent of this potion is used up (drink)"). No surprises here, you can do all this by following standard ObjectPascal syntax and conventions, example:

[[
type
  TPotionEffect = (peLife, peMana, peCurePoison);

  { A potion properties and 3D model. }
  TPotionType = class(TVRMLGLScene)
    Effect: TPotionEffect;
    CreaturesMayPickItUp: boolean;
    FlameResistant: boolean;
  end;

  { A potion instance. This always refers to exactly one item inside
    of class TPotionType (you can use "(Items[0] as TPotionType)" to get it,
    you can introduce a method here to get it comfortably).
    When it is visible on a level (that is, added to SceneManager items
    graph), the Translation determines it's position on a level. }
  TPotionInstance = class(T3DTranslated)
    PercentUsed: Integer;
  end;

var
  LifePotionType,
  ManaPotionType: TPotionType;
  LifePotionInstance1,
  LifePotionInstance2,
  ManaPotionInstance1: TPotionInstance;

{ ... somewhere in begin...end block ... }
  LifePotionType := TPotionType.Create(Application);
  LifePotionType.Load('life_potion.x3d');
  LifePotionType.Effect := peLife;

  ManaPotionType := TPotionType.Create(Application);
  ManaPotionType.Load('mana_potion.x3d');
  LifePotionType.Effect := peMana;

  LifePotionInstance1 := TPotionInstance.Create(Application);
  LifePotionInstance1.Translation := Vector3Single(1, 2, 3);
  LifePotionInstance1.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 50;
  SceneManager.Items.Add(LifePotionInstance1);

  LifePotionInstance2 := TPotionInstance.Create(Application);
  LifePotionInstance2.Translation := Vector3Single(4, 5, 6);
  LifePotionInstance2.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 12;
  SceneManager.Items.Add(LifePotionInstance2);

  ManaPotionInstance1 := TPotionInstance.Create(Application);
  ManaPotionInstance1.Translation := Vector3Single(4, 5, 6);
  ManaPotionInstance1.Add(ManaPotionType);
  SceneManager.Items.Add(ManaPotionInstance1);
]]

TODO: engine 2.6.0 will contain a comfortable T3DTransformed, which also allows to rotate, scale etc.. For now refer to castle code how to make it.

6. Letting player pick up items
XXX (follow the castle code, where we just check player's bounding box with items bounding box. make special utilities for this.)

7. Display player life and weapon

You often want to display something 2D on player screen. Let's draw a simple meter showing your life points.

XXX

Showing a weapon is a little more tricky, as it's a 3D thing, but it doesn't actually interact with the world, it's glued to the player view. So we don't actuallly want to add it the scene manager. Instead, we want to load it and render directly. OK, actually it's not that tricky, as you already know how to load a 3D stuff, and you already know how to add something custom-drawn to the window:

XXX

8. Adding some creatures
XXX (this is just like items, except creature kinds need AI to move; engine 2.6 will include ready classes with such AI, for now refer to castle code.)

9. Adding some sounds

As with many other operations, you can add and control sounds to your game either by Pascal code, or by editing your data files. This gives flexibility both to a programmer and the content designer. It's your choice which approach you use &mdash; usually it's better to keep as much as possible in data files, and use code only when necessary for non-trivial situations.

First, get a sample sound file and place it within your game data. You can use this sample.wav file.

To add a looping sound to your VRML/X3D file, just open xxx.x3dv and paste there this:

[[
Sound {
  source AudioClip { url "sample.wav" loop TRUE }
}
]]

Remember that URL "sample.wav" is specified relative to the location of your xxx.x3dv file. In the simplest case, just place both xxx.x3dv and sample.wav in the same directory, and you're fine.

To play a sound from a code, add this code:

[[
Buffer := SoundEngine.LoadBuffer('sample.wav');
SoundEngine.PlaySound(Buffer, ...); // see PlaySound reference for parameters
]]

You can free the buffer once the sound has stopped. It's not important for simple programs, as we will take care to always free it before closing OpenAL context.

For more advanced uses, you can use the return value of PlaySound: it's either nil (if no OpenAL resources available to play this sound, and it's priority doesn't allow overriding other sounds) or it's a TALSound instance. If you have TALSound instance, you can use it's TALSound.OnUsingEnd event to be notified when source stops playing. You can also use other TALSound methods, e.g. update TALSound.Position, TALSound.Gain and such. You can stop playing the sound by TALSound.DoUsingEnd.

10. Adding an on-screen menu

For a simple on-screen menu, where all the menu items are displayed vertically on the screen, use the TGLMenu class. For Lazarus: drop TGLMenu on the form. For TGLUIWindow: just create TGLMenu instance. Fill it's Items property (each line is a menu entry), and assign a handler for the OnClick event (to react when user chose menu item, by clicking or pressing enter key). Inside OnClick event, the CurrentItem property of your TGLMenu instance tells you which item was clicked. You still have to add a code to TForm.OnCreate to add this to controls list, like

  Browser.Controls.Insert(0, GLMenu1);

You may also want to change the position, like

  GLMenu1.Position := Vector2Integer(100, 100);
  { you may also want to set PositionRelativeMenu* (through object inspector or code) }

There is an example of this in vrml_with_2d_controls example in engine sources, look for GLMenu1 references in code.

11. Background under on-screen menu

In addition to previous point, you may want to change the menu FullSize to true. Otherwise, menu receives input only when mouse hovers over it. When FullSize, the menu obscures completely controls under it for key processing (although they are still visible as a background).

- So if you want your menu to be displayed and used orthogonally to the "live" 3D world underneath, leave FullSize = false.
- For initial game menu with items like "New Game", you probably want to disable the camera input for this scene. This allows you to display interactive 3D scene in the background, but block user from interacting with it (after all, the user should only interact with your menu on the initial screen). To do this simply set FullSize = true.

An alternative method to achieve (part) of 2nd choice is to set background level camera's IgnoreAllInputs to true. This also blocks user from moving in the scene (although it doesn't make input passed to menu regardless of mouse position).

If you want to place a static 2D image under menu, you can use TKamGLImage underneath, instead of 3D scene.
