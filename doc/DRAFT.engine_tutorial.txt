TODO: This is a work in progress. I want to finish this for next engine release (3.1.0 or maybe 4.0.0). This is supposed to be a full tutorial how to make a FPS game, from the basics (with enough info to make it obvious how to create other types of games, 3D or not).

The tutorial handles both alternatives for creating OpenGL context: as Lazarus component (on Lazarus form), or as our TCastleWindow instance. Appropriate parts of the tutorial will be in 2-column view to visualize this.

------------------------------------------------------------------------------
TODO: add somewhere here a nice diagram of engine classes, see DRAFT.engine_classes_diagram.txt.

Add at the beginning of each page: you're welcome to contribute to this tutorial (or any other part of the engine documentation, for that matter): go to <a href="http://sourceforge.net/p/castle-engine/wiki/Home/">our wiki</a> and write there about what you think is useful :) If you want to modify the contents of this tutorial, you're welcome to just start by copy-pasting the relevant text from here to wiki, and the improving it. We will merge the contents of wiki back to our "static" documentation, or (if wiki will prove successfull) we will just start linking to our wiki instead of static docs.

At the bottom: Preparing this tutorial, and the engine itself, took a lot of time. If you feel like it, please consider <adonating</a>, so that Michalis can spend more time on developing the engine :)
------------------------------------------------------------------------------
0. Introduction

This tutorial shows how to make a simple 3D first-person game using our <i>Castle Game Engine</i>. We'll explain the basics of our engine, show you some simple programs and mention the most important classes.

Throughout this tutorial you will see a links to our <a>engine reference</a>, and you will eventually want to follow them to read detailed reference of stuff that interests you. Note that you can also just read the units source code --- the reference is automatically generated from the comments in the units interface, so if you're brave enough, you can just dive straight into the source.

------------------------------------------------------------------------------
1. Download and install the engine, try the demos

If you haven't done it yet, download the engine source code with examples from ....

The example program that shows most of the features presented in this tutorial is examples/fps_game/ . I suggest looking at it's source code for a complete implementation that uses all the code snippets shown in this tutorial.

Run Lazarus, and open packages in the castle_game_engine/packages/ subdirectory. Open and compile all three packages (castle_base.lpk, castle_components.lpk, castle_window.lpk), to test that things compile OK. Then install the package <i>castle_components</i>. (Do not install castle_window --- you don't want to have this installed in Lazarus. You can install castle_base explicitly, but there's no need to: installing castle_components will also install castle_base automatically.)

Once packages are successfully installed, Lazarus restarts, and you should see "Castle" tab of components at the top (screenshot). Sorry, we don't have icons for our components yet, so it looks a little boring. Mouse over the icons to see component names.

Let's quickly open and run some demos, to make sure that everything works. I suggest running ... (some LCL demo) and ... (some CastleWindow demo).

Make sure you have installed the necessary libraries first, or some of the demos will not work. The required libraries (.so under Unix, .dll under Windows) are mentioned in the <a href="http://castle-engine.sourceforge.net/apidoc/html/introduction.html#SectionLibraries">Requirements -&gt; Libraries</a> section of our reference introduction. Under Windows, you will usually want to grab http://castle-engine.sourceforge.net/miscella/win32_dlls.zip and place them somewhere on your $PATH, or just place them in every directory with .exe files that you compile with our engine.

Now we'll start creating our own game from scratch.

------------------------------------------------------------------------------
2. Creating OpenGL context --- a window (TCastleWindow) or a Lazarus component (TCastleControl)

First of all, you need to initialize a rectangular area on the screen that will be able to display 3D content. This is called OpenGL context. There are two ways of doing this:

- You can use our own CastleWindow unit, that defines window class TCastleWindow. This gives you the most OpenGL capabilities (our TCastleWindow allows to request some funny stuff from OpenGL, not possible otherwise) and is usually best for 3D games.

You can develop such programs using Lazarus, or any other text editor. The only real requirement is having a FreePascal installed.

The left column of this tutorial will follow this way. We'll still be using Lazarus to compile our program, simply because it's the easiest and most popular method. But we will not use Lazarus form designer. As far as Lazarus is concerned, we're creating a "Custom Application" project.

-> Create new project using Lazarus "New Project" menu item. Choose "Custom Application".

Place this source code in your program file (lpr).

[[
var
  Window: TCastleWindow;
begin
  Window := TCastleWindow.Create(Application);
  Window.OpenAndRun;
end.
]]

Press "Run" and behold, a window! (without any contents drawn, so you will probably see the underlying screen contents underneath).

As you see, we give Application (this is defined in our CastleWindow unit) as the owner (first constructor parameter) of Window. This way we don't have to care about freeing it later. When the Application is freed (which is done automatically by CastleWindow unit finalization), the Window will be freed too. You can pass "nil" instead of "Application" if you really want to avoid this automatic memory management, and free things yourself. This whole "owner" mechanism is actually a normal behavior of ObjectPascal components.

- Alternative is to use our TCastleControl inside normal Lazarus form. Just pick TCastleControl from the component palette (tab "Castle") and drop it on a regular Lazarus form. This allows for seamless integration with the normal application design using Lazarus, as you have a normal Lazarus form where you can place normal buttons and such. The downside is that our TCastleControl inherits from Lazarus TOpenGLComponent, and it has some limitations (not all OpenGL features can be requested, sometimes mouse look may stutter a little because of Lazarus event loop processing).

To develop such programs you use Lazarus, period.

This tutorial doesn't suggest any particular method (TCastleWindow or TCastleControl). Both approaches make sense, really, and it's your choice. You should choose Lazarus method (TCastleControl) if you want to integrate game context with normal GUI (Lazarus forms, controls) or if you're just more comfortable with dropping components of a Lazarus form. If you want best OpenGL features, or if you're just more comfortable working outside of Lazarus (like with custom editor and only calling FPC through a script) then probably you want to choose TCastleWindow method. The difference is only how you start: create a TCastleWindow instance by code, or drop TCastleControl on a Lazarus form. Everything else goes *almost* the same, as the TCastleControl and TCastleWindow are designed specifically to resemble each other, so they both share similar methods and properties (like "Controls", where we add our engine 2D and 3D stuff).

In case of using Lazarus forms, you will usually want to place the initialization code inside your form's methods. In the simplest case, just place it inside the TCastleControl.OnGLContextInit event (you could also move non-OpenGL parts into TForm.OnCrease, that happens earlier).

-> Create new project using Lazarus "New Project" menu item. Choose "Application". Drop TCastleControl on your form and resize it to fit the window. Press "Run" and behold :)

Note about key handling (applies only to TCastleControl): Like every proper Lazarus control, our TCastleControl receives the keys only when it has <i>focus</i>. The control <i>does not</i> capture all the keys pressed over the form (this would be bad, as other controls, maybe even other TCastleControl on the same form, may want to handle them). To make sure that controlling the camera by keys (arrow keys, and/or AWSD and other keys, more about keys later) works, make sure that your control has a focus.

In the simplest case, just call

[[
Control.SetFocus;
]]

whenever you want.

There's no visual indicator when TCastleControl has focus (as there's no standard way to show it, that would be pleasing for various game applications).

How you deal with focus really depends on your application:
- In the simplest cases, the problem simply doesn't exist, as TCastleControl is the only thing on your form able to receive focus --- so it always has focus. You may limit yourself to use only unfocusable things, like TSpeedButton, on the Lazarus form --- to keep it simple.
- If you want to use other focusable controls, it's really up to you how to present it to user. In princible, you don't have to do anything, focus works, and it can be switched into/out of TCastleControl by the Tab key or clicking with mouse on other controls.
  - You may want to create a special key shortcut to quickly shift focus to your control (calling Control.SetFocus).
  - You may want to draw some visual indication, like a border around TCastleControl, when it's focused. Actually, our TCastleControl may contain inside our own controls (TUIControl class), so you may want the draw TUIControl that is focused (see examples/3d_rendering_processing/multiple_viewports.lpr for simple example that shows which viewport is active, having 4 viewports within a single OpenGL context).
  - Finally, if you really want, you can also use standard Lazarus features like TForm.KeyPreview and TForm.OnKeyDown / OnKeyUp to capture some keys at form level and pass them directly to chosen control.

------------------------------------------------------------------------------
3. Creating 3D world --- scene manager

Actually, this step of the tutorial is already done for you: scene manager is already created and ready for use, in SceneManager property of the TCastleControl or TCastleWindow instance. But let's stop for a second to understand what scene manager <b>is</b>, as it's quite central idea to how you work with the engine.

Scene manager is a single TCastleSceneManager class instance that knows literally everything about your 3D world. It is essential to have it, and add all your 3D stuff to it.

In the simple scenario, by default TCastleSceneManager also acts as a viewport filling the whole window. So the whole OpenGL context is drawn to show your 3D world. In more complex scenarios you can have many smaller viewports inside your window using TCastleViewport controls (we'll not discuss it in this tutorial, see <a href="http://castle-engine.sourceforge.net/vrml_engine_doc/output/xsl/html/section.custom_viewports.html">custom viewports notes</a>, and <tt>multiple_viewports</tt> example in engine sources). You can also turn off scene manager from being a viewport (DefaultViewport := false), and then scene manager is really <b>only</b> something that keeps track of 3D world, and nothing more.

As I said, you actually already have SceneManager property of your window/control, so the work is done for you. If more advanced scenarios, you may want to create and manager scene managed yourself, see <a link to vrml_engine_doc about</a>.

------------------------------------------------------------------------------
4. Load a 3D model (simple approach to loading a game level or such)

We will now load a 3D model from file. This is basic way to load a game level, although you will learn a more advanced way later.

If you use a VRML/X3D file, this game level doesn't have to be static --- it can already include animated stuff, 3D sounds, scripts, and such.

- If you just want to try a ready level, download this 3D file (link to *standalone* vrml file, in a single x3d file, with no textures etc.). You can open it first with view3dscene to see how it looks like.

Or copy more interesting level model from castle_game_engine/examples/vrml/models/: copy bridge_final.x3dv, bridge.wrl, and textures/ subdirectory to your project.

- If you want, you can of course make your own new level. You can generally use any 3D modeler and export to any 3D format we can handle. Our other tutorial "how to make new level for CASTLE-2-NAME-HERE" (right now: DRAFT.modeling_tutorial.txt) describes from the basics how to use open-source Blender to create a level and export it to VRML/X3D. Highly advised reading! :)

To load a level, change your code to this:

[[
var
  Window: TCastleWindow;
  Scene: TCastleScene;
begin
  Scene := TCastleScene.Create(Application);
  Scene.Load('my_scene.x3d');
  Scene.Spatial := [ssRendering, ssDynamicCollisions];
  Scene.ProcessEvents := true;

  Window := TCastleWindow.Create(Application);
  Window.SceneManager.Items.Add(Scene);
  Window.SceneManager.MainScene := Scene;

  Window.OpenAndRun;
end.
]]

At the beginning we create a new instance of TCastleScene, and load it's contents from a file. Scene.Spatial determines what spatial structures (octrees for now) are created, the value [ssRendering, ssDynamicCollisions] is the most flexible one (it allows to speed up the rendering by frustum culling, detect collisions between player and level, and it adapts to a dynamic level that may have some animated parts). Scene.ProcessEvents activates animating VRML/X3D models (you can remove it if you know your level is, and always will be, static).

The level is added to the scene manager. The level is also set as the "MainScene" of scene manager, this means that some central settings (like initial camera position, initial headlight status and such) can be obtained from this scene.

------------------------------------------------------------------------------
5. Load a game level

Instead of loading level like above, there is a slightly more comfortable and feature-rich way to load a level for a game: call the TGameSceneManager.LoadLevel method. Under the hood, TGameSceneManager.LoadLevel does eberything mentioned above --- the new 3D model is loaded, and added to the SceneManager.Items, and set as SceneManager.MainScene. But it also does some additional work, like detecting a "placeholders" in your 3D model, which should be replaced with creatures (from CastleCreatures unit) and items (from CastleItems unit).

It is also integrated with CastleLevels definition of what a "level" is: namely, it's a level.xml file referencing a 3D model and describing some additional level properties.t

The TGameSceneManager class allows you to define levels by using simple XML files. For each level, you create a file named "level.xml", with contents like this:

[[
<?xml version="1.0"?>
<level
  name="pits"
  type="Level"
  scene="pits.x3dv"
  title="The Pits of Azeroth"
  placeholders="blender"
/>
]]

- "name" is a unique internal name for the level, it will come in handy soon.
- "type" identifies the ObjectPascal class handling the level logic --- type "Level" is always available, for advanced games you can also create and use your own level logic types.
- "scene" is a filename of the 3D model containing the level.
- "title" is just used for some logging and messages. Depending on your game, you may also find this title useful for other purposes, e.g. show the user a list of levels available to start. But this is up to you. The engine itself doesn't really make much use of the title. There are other optional properties, like "demo" or "number" that you may use.
- "placeholders" says how to detect placeholders (for creatures and other things) in your 3D level model. This is optional, but highly useful.

See http://svn.code.sf.net/p/castle-engine/code/trunk/castle_game_engine/doc/README_about_index_xml_files.txt for more details about the level.xml and resource.xml files (defining levels and other stuff).

Traditionally, I place each level in a subdirectory of data/levels/, along with it's associated 3D models. So I have a structure like this:

[[
data/
  levels/
    pits/
      level.xml
      pits.x3dv
    swamp/
      level.xml
      swamp.x3dv
    mountains/
      level.xml
      mountains.x3dv
    ...
]]

Although this convention proved comfortable, it's not forced at all. The 3D models files may live in other directories than level.xml files, as "scene" field may contain a relative filename (in future, it should be possible to use there any absolute or relative URL; for now, only filenames are allowed). And level.xml files may be scattered throughout your directory as you wish. And what is "data directory" is configurable (by Levels.LoadFromFiles optional parameter, by default we use ProgramDataPath). It's only important that the XML files have names "level.xml".

You can now start a game by scanning all levels information from level.xml files, and then loading your desired level by referring to it's "name" field:

[[
  Levels.LoadFromFiles;
  SceneManager.LoadLevel('base');
  // the 2nd line is a shortcut for
  / SceneManager.LoadLevel(Levels.FindName('base'));
]]

The LoadLevel will clear all SceneManager.Items (except Player, more about this in a second). Then it will load new 3D model with a level (adding it to SceneManager.Items and setting as SceneManager.MainScene, just as we did manually in previous chapter), and do some more interesting stuff that we'll learn later.

The important thing here is that (except the "name" of the 1st level) levels are not hardcoded in any way in your program. This makes game data nice for people preparing new content: they can just drop new subdirectory into the data/levels/, and if it will contain proper level.xml file, it will be automatically recognized. A similar scheme will be used for creatures/items in the following chapter. Your game data is immediately friendly to MODders.

------------------------------------------------------------------------------
[TODO: need a chapter number here] Create a player, display player weapon

For a good measture, it will also be handy later to have a central Player object. This is used for various things:
- It will make camera automatically tied to the Player, making it a first-person perspective game. (More camera approach, like third-person view, will be available later.)
- It's also a central enemy of all hostile creatures created using CastleCreatures unit. This will be more configurable in the future.

To load a Player do this (before or after loading a level --- doesn't matter; conceptually, it's cleaner to do this before loading new level, but things will work either way).

[[
var
  Player: TPlayer;
...
  Player := TPlayer.Create(SceneManager);
  SceneManager.Items.Add(Player);
  SceneManager.Player := Player;
]]

Player is a descendant of T3DList, which means that you can add additional 3D objects as it's children, like Player.Add(Some3DObject). These 3D objects will always be rendered relative the the player, so they will move along with the player. This is an easy way to add 3D weapon models and similar things to your display. In fact, we do it automatically for TCastlePlayer.EquippedWeapon 3D model. But you can also add/remove additional 3D objects this way.

As an additional feature, all 3D objects that are children of player will always be rendered on top of other 3D world. This means that even if you 3D weapon model is large (like a long sword pointing out from camera), it will never go "inside the wall". You can turn this feature on/off by TCastlePlayer.RenderOnTop property.

Aside from special TCastlePlayer.RenderOnTop behavior, the 3D objects that are children of player are rendered and processed as all other 3D stuff. For example, they can animate (by using TCastlePrecalculatedAnimation or by using TCastleScene with <tt>TCastleScene.ProcessEvents := true</tt>).

Note that the player 3D objects <b>do not</b> make the player collision sphere (aka camera radius) larger. If you want to make the collision sphere larger, you can do it by placing a NavigationInfo node in every level 3D file, and adjusting the 1st item of avatarSize field &mdash; it determines the camera radius.

/---
 Some box "Advanced":
There is an alternative way to place things relative to player view: use X3D ProximitySensor node. See demo_models/sensors_environmental/follow_camera_by_proximity_sensor.x3dv for a simple example how to code it in X3D. This allows you to place the 3D things that are relative to player inside a larger X3D file, together e.g. with normal level geometry (which may be an advantage or disadvantage, depending what you want). The disadvantage is that we do not implement layers in X3D now, so such geometry will overlap with 3D level geometry (unless it will always fit within camera radius).
\---

------------------------------------------------------------------------------
6. Adding creatures and items

Thanks to using TGameSceneManager and LoadLevel, you actually don't need to do much. We have a nice default handling of creatures and items suitable for 3D games in CastleCreatures and CastleItems units.

Creatures/items are XML files named resource.xml with the <resource> root node. See for now castle1 daya for examples how such file looks like, e.g. castle/data/creatures/alien/resource.xml . See http://svn.code.sf.net/p/castle-engine/code/trunk/castle_game_engine/doc/README_about_index_xml_files.txt for more details about the properties you can set in resource.xml files. See also DRAFT.modeling_tutorial.txt about modeling and exporting creature animations.

The common properties about creatures, items and levels resource.xml and level.xml files:

- "name", like mentioned before, this is a unique internal name of the level/resource (resource being creature or item). In case of resources (creatures or items), it's particularly useful, as it can be used as Blender's object name to place initial creatures/items on the level inside Blender.
- "type" refers to ObjectPascal class handling the actual behavior of this resource. We provide various simple creatures/items, you can also extend our classes to create your own types.

There really isn't much code here. Just add

[[
  Resources.LoadFromFiles;
]]

call somewhere before loading the level. This will cause all information about the creatures and items automatically loaded. Necessary creatures and items will be nicely prepared for each level if you use the <resources> section the levels level.xml files. Some resources may also be prepared always (see T3DResource.AlwaysPrepare).

The "type" of the creatures determines it's ObjectPascal class, in turn determining creature AI, how many 3D models (or states) it has, and various other properties. Hostile creatures are automatically hostile to our Player.

Items are automatically pickable by player, player backpack is automatically managed.

CastleCreatures unit (see inside src/game/ in sources) allows you to easily create creatures with artificial intelligence.

((TODO: describe player.xml somewhere later.)

6.1. For starters, you can just use the existing creature classes on CastleCreatures unit.

  To get walk-attack-state intelligence, use the TWalkAttackCreatureKind class. Such creature tracks the player (remembers last seen player 3D position, walks/flies to it, possibly through sectors/waypoints — so it can pass through narrow doors in a labyrinth or walk over a narrow bridge), attacks the player from the right distance (this can be either a melee attack, or shooting a missile — which adds a missile to the 3D world), eventually runs from the player (when he's too close and/or our health is low). For now, the player is always the main enemy, and there's no "creature vs creature" fighting, although it can be added easily in the future.

  For basic usage, there's no need to even derive new classes. All you need to do is to create a directory holding creature 3D data and resource.xml describing it (for example, see various subdirectories of castle/data/creatures/ in SVN).

  There are a lot of settings to achieve particular behavior, e.g. cowardly/brave, offensive/defensive, melee/ranged, etc.

  There is also a "missile" intelligence (TMissileCreatureKind), that causes the creature to blindly go in given direction (possibly with gravity and/or homing (close-on-target) features). On impact, missile may explode, hurting player and/or other creatures. Any kind of missile, like arrow or lighting bolt, is represented as such "missile creature", that flies independently of the shooter.

  And there is a TStillCreatureKind that just stands still (it can still show some looping animation, but there is no fancy logic behind it).

6.2. You can also derive simple descendants of CastleCreatures classes, to customize their behavior. For example, "The Castle" customizes walk-attack creature to give both ranged and melee attacks to the Spider Queen, to make werewolves howl from time to time, and such. See castle1 GameCreatures.pas unit sources. We plan to add a simple FPS game to the engine examples, to illustrate this nicer.

  You can start your customizations from full-features classes, like TWalkAttackCreatureKind and TWalkAttackCreature. Or you can take the basic TCreatureKind and TCreature, and extend them to your liking.

  This is a good moment to browse the API reference of mentioned CastleCreatures classes, if you haven't already. See
  * [TWalkAttackCreatureKind], [TWalkAttackCreature]
  * [TMissileCreatureKind], [TMissileCreature]
  * [TStillCreatureKind], [TStillCreature]
  * [TCreatureKind], [TCreature]
  * And see the class hierarchy descending from TCreatureKind and TCreature in [class hierarchy diagram]

  Everything is designed to give you a lot of properties to set (most of them are also settable by resource.xml files mentioned above) and a lot of methods to override. See not only the TCreature* classes, but also see above T3D classes in Base3D unit, for various things that you can override and use.

  (TODO: Pasdoc: frame-less layout, to make direct links sensible.
   TODO: Pasdoc: separate pascal_code_formatter, with @longCode formatter extracted, to convert pascal code to HTML-ified or LaTeX-ified output. HTML can of course be adjusted with CSS. I want to have many code snippets in this tutorial (see e.g. Symfony2 docs for inspiration.)

6.3. (After creatures and items section, section "More stuff in your 3D world?")

  Our creature and items classes in CastleCreatures and CastleItems units are not magic, they do not get any special treatment from the scene manager. Instead, they just extend the base 3D classes in Base3D unit. There are ready classes to represent 3D things, that can move, can collide with other 3D stuff and such. If you find that our creatures/items design is not enough for you, or maybe you want to have in your 3D world something that doesn't really fit the creature/item definition, you can always derive new classes from the Base3D classes. Like T3DAlive, T3DOrient, T3DTransform. Methods Move, MoveAllowed, Height, LineOfSight allow you to add any kind of movement/intelligence to any 3D object.

---
Sidenote: Which way is up?
There are various conventions for which vector is "up" in 3D world and, consequently, which vector corresponds to the "direction" the creature/player is facing.

Quick guide:
- If you want to follow "+Y is up" convention (easier, i.e. you don't really need to do anything):
  - When exporting from Blender (levels, creatures etc.), let it rotate the model, i.e. change +Z to +Y. This is actually the default for X3D exporter since some time.
  - Make sure your Viewpoint indicates +Y as up vector. This is actually the default VRML/X3D value.
  - Leave T3DOrient.DefaultOrientation at default otUpYDirectionMinusZ.
- If you want to follow "+Z is up" convention:
  - When exporting from Blender (levels, creatures etc.), always select to *not* rotate the model, i.e. keep Blender's coordinate system.
  - Make sure you use view3dscene (or other VRML/X3D editor) to generate a Viewpoint in your level that makes gravity working in Z axis.
  - Set T3DOrient.DefaultOrientation := otUpZDirectionX.

Detailed discussion about what the issue: There are two common conventions:

1. Most 3D modeling software, like Blender, prefers the up direction to be +Z, and direction to be -Y. This is usually sensible when you think about a flat level, with XY representing the map view, and additional Z adding the height.

2. On the other hand, VRML/X3D and default OpenGL camera prefers the up to be +Y, and direction to be -Z. This makes sense if you think about the screen as being the XY plane, so then if you look straight (in the right-hand coordinate system) you look in -Z direction.

You can also easily imagine other conventions, as you can really pick any 3D vector as "up", and pick anything orthogonal to it as "direction".

Our engine supports various such conventions, we do not force you to follow any particular one. To make things work smoothly, you want to keep the same conventions throughout your process &mdash; be wary of this when creating T3DOrient instances in the engine, when exporting 3D models from Blender, when setting viewpoint (with gravity) in whatever way etc.

Note that Blender (and other 3D modeling software?) by default rotates models when exporting to X3D, to turn +Z into +Y. On one hand, this means that some things will "just work" (you use +Z convention inside Blender, and you get +Y convention inside VRML/X3D). On the other hand, this may create a little confusion if you manually probe some positions in Blender model and type them in X3D code (or ObjectPascal code using our engine): since Blender rotated the models, we necessarily "see" a different coordinate system than what you see in Blender.

For this reason, you may decide to disable this "rotation on export" feature, and instead decide to work with VRML/X3D files where +Z is "up".

VRML/X3D is flexible in this regard: although the default is to have up in +Y, the specification says that up is +Y transformed by the Viewpoint node transformation, and we honour it. In short, this means that gravity is configurable in VRML/X3D file. You can setup your camera in view3dscene, use "Navigation -> Walk and Fly settings -> Change Up Vector", input any vector you want (like "0 0 1"), then use "Console -> Print Current Camera..." option, and copy-paste the generated code from the console to your VRML/X3D file. This will set a Viewpoint with desired up vector, which will be correctly used by our engine (and other good VRML/X3D browsers actually) for gravity.

The notion of direction/up is used by our engine in two places:

1. Gravity pulls things (player, items, creatures...) down in the -up vector. We automatically detect this based on the gravity vector of the Viewpoint inside your TCastleSceneManager.MainScene (you usually want to set this to your level 3D model). This means that we follow VRML/X3D specification, and gravity vector is derived from the 3D model of your level. You can use e.g. view3dscene to generate Viewpoint node with a desired gravity vector. You can read this vector by looking at TCastleSceneManager.GravityUp, TCastleSceneManager.Camera.GravityUp, and World.GravityUp (from any T3D code), these are always equal.

2. Oriented 3D things, like creatures, player, and items (and anything else derived from T3DOrient class) are always oriented such that their local direction/up is matching the vectors defined by T3DOrient.Orientation property. Although the publicly visible properties like TCreature.Up are automatically set to be *usually* equal to the World.GravityUp (in case of flying creatures, it may actually be different sometimes). But you still have to set the T3DOrient.Orientation yourself, to make the local creature model correctly match these vectors. You want to set it such that typical up of your creatures changes into World.GravityUp (that is, creature's up remains untransformed).

Usually, you want to just set T3DOrient.DefaultOrientation, and then it will be used for all your models.
---

------------------------------------------------------------------------------
7. More manual way of adding new items

((Maybe remove this chapter / rewrite this?

In new engine version, we have comfortable classes to store item information (TInventoryItem) and visible item on level (TItemOnLevel) and creature (TCreature). However, for advanced usage, it's possible that the traditional concepts of "items that can be picked", "creatures" will not suit you particular game. So the chapter is still somewhat relevant: it's important that our 3D system is designed around flexible T3D class, that you can group (T3DList) and transform (T3DTransform). You can freely design your own descendants of T3DXxx classes, and have all the flexibility you want in creating... well, anything you want in your 3D world.

So, this chapter is probably still relevant, but it should be simplified and rewritten.
))

For the sake of our engine, an item is just a 3D object. So basically, you can just add any T3D descendant (like TCastleScene or TCastlePrecalculatedAnimation) to a scene manager, exactly like we added a level scene in previous section.

However, you usually have a lot of item instances showing the same item. For example, you may place hundreds of potions on a level, and you probably want to add/delete potions on your level quickly. At the same time, you want to load (read from disk, and optimize for OpenGL rendering) only a single potion item. Each potion visible on the level just renders the same 3D model, possibly moved/rotated in a different way.

This means that want to think about two concepts separately: a <b>type</b> of item (like potion, sword, etc.) and an <b>instance</b> of this item in visible 3D world (like "potion lying beside the front door", "other potion hidden behind a secret corridor", "yet another potion not visible yet but in player's backpack", "a sword lying somewhere" and such). Don't confuse the terms <b>type</b> and <b>instance</b> here with ObjectPascal concepts. In our program, we will want to have a class (and it's instance) representing a potion, and a class (and many instances) representing each place where potion exists.

Our engine allows you to do this in a flexible way. We have many 3D objects that keep only references to other 3D objects. In particular, T3DTransfrom keeps a reference to other 3D object(s), and transforms (translates (moves), rotates, scales) them.

So you can create an instance of TCastleScene where you load an item, like potion. Then you create as many as you like instances of T3DTransform, where you add your potion as a children. Additionally, at T3DTransform, you can setup the transformation (like translation) of your item.

[[
var
  PotionType: TCastleScene;
  PotionInstance1, PotionInstance2: T3DTransform;

{ ... somewhere in begin...end block ... }
  PotionType := TCastleScene.Create(Application);
  PotionType.Load('my_scene.x3d');
  PotionType.ProcessEvents := true; // if the item model has interactive/animated parts by VRML/X3D events

  PotionInstance1 := T3DTransform.Create(Application);
  PotionInstance1.Translation := Vector3Single(1, 2, 3);
  PotionInstance1.Add(PotionType);
  SceneManager.Items.Add(PotionInstance1);

  PotionInstance2 := T3DTransform.Create(Application);
  PotionInstance2.Translation := Vector3Single(4, 5, 6);
  PotionInstance2.Add(PotionType);
  SceneManager.Items.Add(PotionInstance2);
]]

For more advanced uses, you may want to create your own class for TPotionType (descending from TCastleScene, and adding additional information, for example is this a "life potion", "mana potion", "cure potion" etc. --- we assume these potions have different 3D models, but also share some common parameters and so they want to be treated under a common class TPotionType). Also, you may want to create your own class for TPotionInstance (descending from T3DTransform, and adding additional information like "how much percent of this potion is used up (drink)"). No surprises here, you can do all this by following standard ObjectPascal syntax and conventions, example:

[[
type
  TPotionEffect = (peLife, peMana, peCurePoison);

  { A potion properties and 3D model. }
  TPotionType = class(TCastleScene)
    Effect: TPotionEffect;
    CreaturesMayPickItUp: boolean;
    FlameResistant: boolean;
  end;

  { A potion instance. This always refers to exactly one item inside
    of class TPotionType (you can use "(Items[0] as TPotionType)" to get it,
    you can introduce a method here to get it comfortably).
    When it is visible on a level (that is, added to SceneManager items
    graph), the Translation determines it's position on a level. }
  TPotionInstance = class(T3DTransform)
    PercentUsed: Integer;
  end;

var
  LifePotionType,
  ManaPotionType: TPotionType;
  LifePotionInstance1,
  LifePotionInstance2,
  ManaPotionInstance1: TPotionInstance;

{ ... somewhere in begin...end block ... }
  LifePotionType := TPotionType.Create(Application);
  LifePotionType.Load('life_potion.x3d');
  LifePotionType.Effect := peLife;

  ManaPotionType := TPotionType.Create(Application);
  ManaPotionType.Load('mana_potion.x3d');
  LifePotionType.Effect := peMana;

  LifePotionInstance1 := TPotionInstance.Create(Application);
  LifePotionInstance1.Translation := Vector3Single(1, 2, 3);
  LifePotionInstance1.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 50;
  SceneManager.Items.Add(LifePotionInstance1);

  LifePotionInstance2 := TPotionInstance.Create(Application);
  LifePotionInstance2.Translation := Vector3Single(4, 5, 6);
  LifePotionInstance2.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 12;
  SceneManager.Items.Add(LifePotionInstance2);

  ManaPotionInstance1 := TPotionInstance.Create(Application);
  ManaPotionInstance1.Translation := Vector3Single(4, 5, 6);
  ManaPotionInstance1.Add(ManaPotionType);
  SceneManager.Items.Add(ManaPotionInstance1);
]]

------------------------------------------------------------------------------
8. Display custom 2D controls: your own player HUD

You will often want to draw a 2D controls on your screen, for example to display player life or inventory (the engine does manage the player's inventory automatically for you, in TPlayer.Inventory; however, it's not displayed automatically). You can do it by defining a new TUIControl descendant, where you can draw anything you want in overridden Draw method. You can use the ready UIFont instance to draw a 2D font on the screen. A simple example:

[[
type
  TGame2DControls = class(TUIControl)
  public
    procedure Draw; override;
    function DrawStyle: TUIControlDrawStyle; override;
  end;

function TGame2DControls.DrawStyle: TUIControlDrawStyle;
begin
  Result := ds2D;
end;

procedure TGame2DControls.Draw;
var
  Player: TPlayer;
  I: Integer;
begin
  Player := Window.SceneManager.Player;

  { A simple display of current/maximum player life. }
  { Set text color to yellow }
  glColorv(Vector3Single(1, 1, 0));
  { Write text in the upper-left corner of the screen.
    For controls with DrawStyle = ds2D,
    the (0,0) is always bottom-left corner, (ContainerWidth,ContainerHeight)
    is top-right corner. As you can see, you can take font measurements
    by UIFont.RowHeight or UIFont.TextWidth to adjust initial position
    as needed. }
  SetWindowPos(0, Window.Height - UIFont.RowHeight - 5);
  UIFont.Print(Format('Player life: %f / %f', [Player.Life, Player.MaxLife]));

  { A simple way to draw player inventory.
    The image representing each item (exactly for purposes like inventory
    display) is specified in the resource.xml file of each item,
    as image="xxx" attribute of the root <resource> element.
    Based on this, the engine initializes TItemKind.Image and TItemKind.GLImage,
    that you can easily use for any purpose.
    We assume below that all item images have size 100 x 100,
    and we assume that all items will always fit within one row. }
  for I := 0 to Player.Inventory.Count - 1 do
  begin
    SetWindowPos(I * 100, 0);
    Player.Inventory[I].Kind.GLImage.Draw;
  end;

  { Simple color effects over the screen:
    when player is dead,
    when player is underwater,
    when player has fadeout from any other cause (e.g. player is hurt).

    GLBlendRectangle and GLFaceRectangle make simple color effects by blending.
    They are trivial to use (by all means, do experiment with parameters below,
    see GLBlendRectangle and GLFaceRectangle documentation and also OpenGL
    glBlendFunc parameters), and they will work even on ancient GPUs.

    To create more fancy effects, you can use our GLSL screen effects API.
    See http://castle-engine.sourceforge.net/x3d_extensions_screen_effects.php .
    They can be even set up completely in VRML/X3D file (no need for ObjectPascal
    code). Engine example examples/3d_rendering_processing/multiple_viewports.lpr
    shows how to set them up in code. }
  if Player.Dead then
    GLFadeRectangle(0, 0, ContainerWidth, ContainerHeight, Red3Single, 1.0) else
  begin
    if Player.Swimming = psUnderWater then
      GLBlendRectangle(0, 0, ContainerWidth, ContainerHeight,
        GL_ONE, GL_SRC_ALPHA, Vector4Single(0, 0, 0.1, 0.5));
    { Possibly, Player.FadeOut* will be applied on top of water effect,
      that's Ok --- they'll mix. }
    GLFadeRectangle(0, 0, ContainerWidth, ContainerHeight,
      Player.FadeOutColor, Player.FadeOutIntensity);
  end;
end;

{ When starting your game, create TGame2DControls instance
  and add it to Window.Controls }
var
  Controls2D: TGame2DControls;
...
  Controls2D := TGame2DControls.Create(nil);
  Window.Controls.Add(Controls2D);
...
  { When the same ends, you can free Controls2D.
    They will be automatically removed from Window.Controls upon destruction
    (thanks to TComponent notification mechanism). }
  FreeAndNil(Controls2D);
]]

You can use any 2D engine controls in such way. See CastleControls unit
for some standard buttons and panels. Although for a specific game you
will probably want a specialized UI, done like the example above.
In TGame2DControls.Draw you simply use OpenGL to draw your stuff,
although we give you a lot of helpers to deal with drawing images, text
and so on.
See castle1 unit GamePlay for an example implementation that shows
more impressive player's life indicator, inventory (with
more information, like quantity and name) and other things on the screen.

------------------------------------------------------------------------------
(TODO: new chapter number) Game on-screen menu

A similar approach works for displaying in-game menu too.
We provide a flexible on-screen menu as TCastleOnScreeMenu component.
Examples how to use it are in examples/lazarus/model_3d_with_2d_controls/
and a lot of examples are in castle1 code.
It descends from TUIControl, so it can be added and removed from the scene
just like every other control (by adding or removing from Window.Controls,
or by changing it's TUIControl.Exists property).

If the game is already started, in single player games,
you usually want to pause the game when the on-screen
menu is displayed. You can do this easily by SceneManager.Paused property.
Like this:

[[
...
{ global / static variables }
var
  GameMenu: TCastleOnScreeMenu;
  GameMenuClosed: boolean;
...
  { somewhere at the beginning prepare the menu }
  GameMenu := TCastleOnScreeMenu.Create(...);
  { see examples for how to initialize and implement TCastleOnScreeMenu.
    Make sure that one of the menu items, like "Back",
    sets GameMenuClosed := true. }

...
{ when you want to actually show it }
SceneManager.Paused := true;
GameMenuClosed := false;
Window.Controls.Add(GameMenu);
repeat
  Application.ProcessMessage(true, true);
until GameMenuClosed;
Window.Controls.Remove(GameMenu);
SceneManager.Paused := false;
]]

As the scene manager handles a lot of stuff automatically,
processing events and calling Idle methods of all 3D objects periodically.
Pausing it effectively pauses your whole 3D world, while stil allowing
it to be displayed as a background under the on-screen menu.
Alternatively you could also hide the 3D world entirely,
by changing SceneManager.Exists property to false &mdash;
the SceneManager with Exists=false is not only paused, it's also not visible.
You could use TCastleImageControl to show a special image underneath
an on-screen menu.

------------------------------------------------------------------------------
(TODO: new chapter number) Notifications

You can also show on-screen notifications by TCastleNotifications component. This is a TUIControl descendant, so you just create it and add to Window.Controls list, just like other TUIControl descendants mentioned in previous chapters.

You can actually just use the global Notifications instance created for you in the CastleGameNotifications unit (just add it to Window.Controls list). Some engine game features already make notifications to it, and it is also automatically set up to cooperate with CastleScript writeln() function, so you can print to it from VRML/X3D scripts. But you're not forced to it, you may as well create your own TCastleNotifications and ignore our default notifications instance in CastleGameNotifications, if you don't like them (you can still cooperate with CastleScript writeln() by handling OnScriptMessage yourself, see CastleGameNotifications sources for example).

------------------------------------------------------------------------------
9. Sound

As with many other operations, you can add and control sounds to your game either by Pascal code, or by editing your data files. This gives flexibility both to a programmer and the content designer. It's your choice which approach you use &mdash; usually it's better to keep as much as possible in data files, and use code only when necessary for non-trivial situations.

--- Loading and playing sound inside VRML/X3D

First, get a sample sound file and place it within your game data. You can use this sample.wav file.

To add a looping sound to your VRML/X3D file, just open xxx.x3dv and paste there this:

[[
Sound {
  source AudioClip { url "sample.wav" loop TRUE }
}
]]

Remember that URL "sample.wav" is specified relative to the location of your xxx.x3dv file. In the simplest case, just place both xxx.x3dv and sample.wav in the same directory, and you're fine.

--- Loading and playing sound inside ObjectPascal code

To play a sound from a code, add this code:

[[
var
  Buffer: TSoundBuffer;
...
Buffer := SoundEngine.LoadBuffer('sample.wav');
SoundEngine.PlaySound(Buffer, ...); // see PlaySound reference for parameters
]]

You can free the buffer once the sound has stopped. It's not important for simple programs, as we will take care to always free it before closing OpenAL context.

--- Sounds repository

Larger games may find it comfortable to define a repository of sounds in an XML file, conventionally named data/sounds/index.xml. See TXmlSoundEngine docs and castle1 game data for example. Assuming your <tt>data/sounds/index.xml</tt> looks like this:

[[
<?xml version="1.0"?>
<sounds>
  <sound name="sample" file_name="sample.wav" />
  <!-- Actually, you can omit the file_name, it's the same
    as name with .wav extension.
    Also, you can add a lot of interesting attributes here, like
    default_importance, gain, min_gain, max_gain --- see TODO. -->
</sounds>
]]

Then you can initialize it inside your game code like this:

[[
SoundEngine.SoundsXmlFileName := ProgramDataPath + 'data' +
  PathDelim + 'sounds' + PathDelim + 'index.xml';
]]

This allows to play sounds like this from ObjectPascal code:

[[
var
  SoundType: TSoundType;
...
SoundType := SoundEngine.SoundFromName('sample');
SoundEngine.Sound3D(SoundType, Vector3Single(1, 2, 3), false { looping });
SoundEngine.Sound(SoundType, false { looping }); // non-3D sound
]]

The SoundEngine.Sound3D and SoundEngine.Sound are a little simpler to use than SoundEngine.PlaySound, they have fewer parameters. That is because the default sound properties (it's individual gain, importance (priority), actual filename and other stuff) is already recorded in the data/sounds/index.xml file. That's one advantage of using the sounds repository: all your sounds properties are centrally stored in the data/sounds/index.xml file.

You can also refer to your sound names from VRML/X3D AudioClip node, using the "sounds-repository" protocol:

[[
Sound {
  source AudioClip { url "sounds-repository:sample" loop TRUE }
}
]]

--- Level music

There is a special comfortable way to enable looping music on a level, if you use level.xml file with TGameSceneManager.LoadLevel. Simply add <tt>music_sound="xxx"</tt> attribute to the root element of your <tt>level.xml</tt> file, where <tt>xxx</tt> refers to a sound name defined in <tt>data/sounds/index.xml</tt>.

--- More

For more advanced uses, you can use the return value of PlaySound or Sound or Sound3D: it's either nil (if no OpenAL resources available to play this sound, and it's priority doesn't allow overriding other sounds) or it's a TSound instance. If you have TSound instance, you can use it's TSound.OnRelease event to be notified when source stops playing. You can also use other TSound methods, e.g. update TSound.Position, TSound.Gain and such. You can stop playing the sound by TSound.Release.

--- Predefined sounds

Various engine components already want to use some sounds. To make it actually happen, you need to create file like <tt>data/sounds/index.xml</tt> described above, and define there sounds with a predefined names.

See "Common sounds" section in CastleSoundEngine unit sources for a current list of predefined sound names.
------------------------------------------------------------------------------
10. Adding an on-screen menu

Our TCastleWindow or TCastleControl have a list of 2D controls visible of the screen. By default, the only thing present there is a scene manager (since scene manager acts as a 2D viewport through which you see the 3D world; that's right --- the 3D stuff is "within" the 2D stuff). This way the scene manager (it's viewport) is visible on the window, which in turn means that all the 3D stuff we will add next is visible too.

You can add your own 2D controls using the Window.Controls.Add call. There are many predefined GUI controls available in our engine, look for TUIControl descendants, for example in CastleControls unit. You can also derive your own controls with ease.

For a simple on-screen menu, where all the menu items are displayed vertically on the screen, use the TCastleOnScreenMenu control. For Lazarus: drop TCastleOnScreenMenu on the form. For TCastleWindow: just create TCastleOnScreenMenu instance. Fill it's Items property (each line is a menu entry), and assign a handler for the OnClick event (to react when user chose menu item, by clicking or pressing enter key). Inside OnClick event, the CurrentItem property of your TCastleOnScreenMenu instance tells you which item was clicked. You still have to add a code to TForm.OnCreate to add this to controls list, like

  Browser.Controls.Insert(0, OnScreenMenu1);

You may also want to change the position, like

  OnScreenMenu1.Position := Vector2Integer(100, 100);
  { you may also want to set PositionRelativeMenu* (through object inspector or code) }

There is an example of this in model_3d_with_2d_controls example in engine sources, look for OnScreenMenu1 references in code.

------------------------------------------------------------------------------
11. Background under on-screen menu

In addition to previous point, you may want to change the menu TCastleOnScreenMenu.FullSize to true. Otherwise, menu receives input only when mouse hovers over it. When FullSize, the menu obscures completely controls under it for key processing (although they are still visible as a background).

- So if you want your menu to be displayed and used orthogonally to the "live" 3D world underneath, leave FullSize = false.
- For initial game menu with items like "New Game", you probably want to disable the camera input for this scene. This allows you to display interactive 3D scene in the background, but block user from interacting with it (after all, the user should only interact with your menu on the initial screen). To do this simply set FullSize = true.

An alternative method to achieve (part) of 2nd choice is to set background level camera's Input := []. This also blocks user from moving in the scene (although it doesn't make input passed to menu regardless of mouse position).

If you want to place a static 2D image under menu, you can use TCastleImageControl underneath, instead of 3D scene.

------------------------------------------------------------------------------
12. Making screenshots

Making a screenshot is very easy:

[[
var
  Image: TRGBImage;
begin
  Image := Control.SaveScreen;
  try
    SaveImage(Image, 'screenshot_name.png');
  finally FreeAndNil(Image) end;
end;
]]

TRGBImage, and it's ancestor TCastleImage and many other similar classes, is defined in the unit Images. This provides various image loading, saving and processing utilities to our engine. By having our own image handling unit, we can store images in the format best suitable for 3D graphics libraries, like OpenGL (for example, our class TS3TCImage to handle S3TC compressed images is tightly integrated there; we also handle there 3D textures).

Still, we use the excellent FPC FpImage library to load/save some image formats underneath. So we do not implement everything from stratch here, we *are* using FpImage loading/saving features.

------------------------------------------------------------------------------
13. Recoding movies
(Not really useful for an interactive game, but useful for various 3D viewers)

If you have a predefined animation in VRML/X3D (meaning: it plays without any user interaction), and want to record with constant number of frames per second, you can do this:

[[
in a loop:
begin
  SceneManager.MainScene.IncreaseTime(FrameTime);
  SceneManager.Camera.Idle(FrameTime, true, DummyBooleanInitializedToTrue);

  { capture and save screen as before, like: }
  Image := Control.SaveScreen;
  try
    { add your image to the movie sequence.
      Various options possible, view3dscene for now just saves a sequence
      of images to temporary location and later processes them by ffmpeg
      to produce a full movie. }
    SaveImage(Image, Format('screenshot_name_%4d.png', [FrameNumber]));
  finally FreeAndNil(Image) end;
end;
]]

IOW, you manually force the current time of the scene/camera to increase as much as you want before each screenshot. This makes it work 100% reliably, without any worries how fast you can process captured images.

The time of the scene and of the camera is actually independent. You can remove the "MainScene.IncreaseTime" call, if you know that your scene stays static (and want to force it to look like static), and want to animate only camera. Or the other way around, if your camera is static (or you want to force it to be static) but you have an animation in VRML/X3D, you can remove the "Camera.Idle" line.

FrameTime is in seconds, as both TCastleSceneCore.IncreseTime and TCamera.Idle take it's time argument in seconds. But don't worry, this is a float, so actually it honors fractions of seconds as well. So something like 1/25 to get 25 frames per second is Ok.

------------------------------------------------------------------------------
14. Logging

Easy: Use CastleLog, call InitializeLog, and you have your log on stderr. A lot of engine components will immediately use it. To use it yourself, do

[[
if Log then
  WritelnLog('Category', 'My Log Message');
]]

('Category' is useful to easily spot your messages later. There are no hard rules about it, i.e. you're free to just invent your own category names here, like 'Creatures' or 'Rendering'.)

------------------------------------------------------------------------------
15. User preferences

Easy: Use CastleConfig. Various engine components automatically register that they can load/save user preferences. So

[[
{ make sure you have created all stuff that registers user preferences first }
SoundEngine; // if you want to save sound config
RecentMenu := TCastleRecentFiles.Create(nil); // if you use "recent files" menu

{ make sure application name is correct if you want by setting OnGetApplicationName, like this : }

function MyGetApplicationName: string;
begin
  Result := 'glplotter';
end;

...
  OnGetApplicationName := @MyGetApplicationName;

{ load config from file }
Config.Load;

... { do your program }

{ save config to file }
Config.Save;
]]
------------------------------------------------------------------------------
(TODO: new chapter number) Key/mouse shortcuts

We have global controls in global variables: InputPlayer_Xxx and Input_Interact and more. They are gather inside CastleInputs.InputsAll global map. Thanks to this global map, you can let user to configure game controls, you can detect key conflicts and handle them however you like, etc.

There are also local inputs, like TWalkCamera/TExamineCamera.Input_Xxx properties. <b>Onlyi f you use TPlayer</b>: then TPlayer sets it's own TWalkCamera, and overrides (most of) camera inputs with global InputPlayer_Xxx, so (most of) the TWalkCamera.Input_Xxx controls should not be accessed directly, instead change only the global InputPlayer_Xxx matter. TPlayer controls set up typical AWSD keys scheme, and they are also state-sensitive: they change appropriately when player is dead or blocked (see TPlayer.Dead and TPlayer.Blocked),

Every key/mouse shortcut is a TInputShortcut. They are configurable, you can change the shortcuts whenever you want (see TInputShortcut.Assign and other methods). You can also detect conflicts in the keymap and handle them however you like (see GameControlsMenu in castle1 for example).

The state of keys on the global keymap (CastleInputs.InputsAll) is automatically saved/loaded to the config file, if you use Config.Save/Load mentioned in chapter "User preferences".

You can also create new TInputShortcut descendants, global (added to InputsAll, saved to config file and such) or local. See CastleInputs unit API docs. You can easily handle them by overriding TUIControl.Press or TCastleControl.EventPress or TCastleWindow.EventPress methods, or assigning TCastleControl.OnPress or TCastleWindow.OnPress callbacks. You will find then useful methods TInputShortcut.IsEvent(TInputPressRelease) (to detect press/release of input) and TInputShortcut.IsPressed(IUIContainer) (to detect holding (keeping pressed) of input).

------------------------------------------------------------------------------
Optimization and profiling

One you have a large game, with many large 3D models, you will probably start to wonder about the speed and memory usage.

You have your speed, as the number of <i>Frames Per Second</i>, stored in the TCastleControl.Fps or TCastleWindow.Fps object. It has fields FrameTime and RealTime that you can read. (See docs of TFramesPerSecond class in CastleTimeUtils.) We will explain the difference between FrameTime and RealTime in a second.

How to show them? However you like:
<ul>
  <li>If you use TCastleWindow, you can trivially enable FpsShowOnCaption to show FPS on your window caption.
  <li>You can show them on Lazarus label or caption. Just be sure to not update them too often --- updating normal Lazarus controls all the time may slow your OpenGL context drastically. Same warning goes about writing them to the console with Writeln --- don't call it too often, or your rendering will be slower. It's simplest to use Lazarus TTimer to update it only once per second or such. Actually, these properties actually show you an average from last second, so there's not even a reason to redraw them more often.
  <li>You can also simply display them on an OpenGL context (see the example about TGame2DControls in previous section).
</ul>

We do not have any engine-specific tool to measure memory usage or detect memory problems, as there are plenty of them available with FPC+Lazarus already. To simply see the memory usage, just use process monitor that comes with your OS. To detect memory leaks, be sure to use FPC HeapTrc.pas (compile with -gl -gh). See also Lazarus units like LeakInfo. Finally, you can use full-blown memory profilers like valgrind's massif with FPC code (see section "Profiling" lower in this tutorial).

----- How to interpret "Frames Per Second" values?

There are two FPS values available: frame time and real time. Frame time is usually the larger one. Larger is better, of course: it means that you have smoother animation.

Use "real time" to measure your overall game speed. This is the actual number of frames per second that we managed to render. Caveats:

- Make sure to turn off "limit FPS" feautre, to get maximum number available. Use view3dscene "Preferences -> Frames Per Second" menu item, or (if you're a developer) change LimitFPS global variable (if you use CastleControls unit with Lazarus) or change Application.LimitFPS (if you use CastleWindow unit). Change them to zero to disable the "limit fps" feature.

- Make sure to have an animation that constantly updates your screen. E.g. keep camera moving, or have something animated on screen. Otherwise, we will not refresh the screen (no point to redraw the same thing), and "real time" will drop to almost zero if you look at a static scene.

- Note that the monitor will actually drop some some frames above it's frequency, like 80. This *may* cause you to observe that above some limit, FPS are easier to gain by optimizations, which may lead you to a false judgement about which optimizations are more useful than others. To make a valuable judgement about what is faster/slower, always compare two versions of your program when only the relevant thing changed --- nothing else.

Use "frame time"... with caution. It's useful to compare it with "real time", with LimitFPS feature = off: it may then tell you whether the bottleneck is in rendering or outside of rendering (like collision detection and creature AI). "Frame time" measures how much frame we would get, if we ignore the time spent outside OnDraw events. Caveats:

- Modern GPUs work in parallel to the CPU. So "how much time CPU spent in OnDraw" doesn't necessarily relate to "how much time GPU spent on performing your drawing commands".

So making your CPU busy with something else (like collisions, or waiting) makes your "frame time" lower, while in fact rendering times the same time --- you're just not clogging you GPU. Which is a good thing, actually, if your game spend this time on something useful like collisions. Just don't overestimate it --- you didn't make rendering faster, but you managed to do a useful work in the meantime.

For example: if you set LimitFPS to a small value, you may observe that "frame time" grows higher. Why? Because when the CPU is idle (which is often if LimitFPS is small), then GPU has a free time to finish rendering previous frame. So the GPU does the work for free, outside of OnDraw time, when your CPU is busy with something else. OTOH when CPU works on producing new frames, then you have to wait inside OnDraw until previous frame finishes.

In other words, improvements to "frame time" must be taken with a grain of salt. We spend less time in OnDraw event: this does not necessarily mean that we really render faster.

Still, often "frame time" does reflect the speed of GPU rendering.

If you turn off LimitFPS, and compare "frame time" with "real time", you can see how much time was spent outside OnDraw. Usually, "frame time" will be close to "real time". If the gap is large, it may mean that you have a bottleneck in non-rendering code (like collision detection and creature AI).

----- Preparing your models for rendering speed

The less vertexes and faces you can have, the better. Also, the simpler models (no shadows etc.), the better. That's fairly obvious. Exactly what matters most depends on your GPU a lot --- modern GPUs can consume a huge number of vertexes very fast, as long as they are provided to them in a proper way.

In our engine, the "shape" is the unit of information we provide to GPU. It is a VRML/X3D shape. In most cases, it also corresponds to the 3D object you design in your 3D modeller, e.g. Blender 3D object in simple cases is exported to a single VRML/X3D shape (although it may be split into a couple of shapes if you use different materials/textures on it, as VRML/X3D is a little more limited (and also more GPU friendly)).

The general advice is to compromise:
- Do not make too many too trivial shapes. Do not make milions of shapes with only a few vertexes --- each shape will be provided in a separate VBO to OpenGL, which isn't very efficient.
- Also, do make too few shapes. Each shape is be provided in it's entirely to OpenGL (splitting it on the fly would cause unacceptable slowdown), and shapes may be culled using frustum culling or occlusion queries. By using only a few very large shapes, you make this culling worthless.

A rule of thumb is to keep your number of shapes in a scene between 100 and 1000. But that's really just a rule of thumb, different level designs will definitely have different considerations.

----- Optimizing collisions

We use an octree based on 3D model triangles for a precise collisions detection with a level. For other objects, we use bounding volumes like boxes and spheres. This means that the number of shapes doesn't matter much for collision speed. However, number of triangles still matters for level.

Use X3D Collision node to easily mark unneeded shapes as non-collidable or to provide a simpler "proxy" mesh to use for collisions with complicated objects. See demo_models/vrml_2/collisions_final.wrl for demo. It's really trivial in X3D, and we support in 100% --- I just wish there was a way to easily set it from 3D modellers like Blender. Hopefully we'll get better X3D exporter one day. Until them, you can hack X3D source, it's quite easy actually. And thanks to using X3D Inline node, you can keep your auto-generated X3D content separated from hand-written X3D code --- that's the reason for xxx_final.x3dv and xxx.x3d pairs of files around the demo models.

You can ajust the parameters how the octree is created. You can do it in VRML/X3D file or by ObjectPascal code, see http://castle-engine.sourceforge.net/x3d_extensions.php#section_ext_octree_properties . But in practice I usually find that the default values are optimal, for a wide range of scenes.

----- Profiling

You can use any FPC tools to profile your code, for memory and speed. There's a small document about it in engine sources, see castle_game_engine/doc/profiling_howto.txt . See also wiki http://wiki.lazarus.freepascal.org/Profiling .
