TODO: This is a work in progress. I want to finish this for engine 3.1.0 release. This is supposed to be a full tutorial how to make an FPS game, from the basics.

The tutorial handles both alternatives for creating OpenGL context: as Lazarus component (on Lazarus form), or as our TCastleWindow instance. Appropriate parts of the tutorial will be in 2-column view to visualize this.

------------------------------------------------------------------------------
0. Introduction

This tutorial shows how to make a simple 3D first-person game using our <i>Castle Game Engine</i>. We'll explain the basics of our engine, show you some simple programs and mention the most important classes.

Throughout this tutorial you will see a links to our <a>engine reference</a>, and you will eventually want to follow them to read detailed reference of stuff that interests you. Note that you can also just read the units source code --- the reference is automatically generated from the comments in the units interface, so if you're brave enough, you can just dive straight into the source.

1. Download and install the engine, try the demos

If you haven't done it yet, download the engine source code with examples from ....

Run Lazarus, and open packages in the castle_game_engine/packages/ subdirectory. Open and compile all three packages (castle_base.lpk, castle_components.lpk, castle_window.lpk), to test that things compile OK. Then install the package <i>castle_components</i>. (Do not install castle_window --- you don't want to have this installed in Lazarus. You can install castle_base explicitly, but there's no need to: installing castle_components will also install castle_base automatically.)

Once packages are successfully installed, Lazarus restarts, and you should see "Castle" tab of components at the top (screenshot). Sorry, we don't have icons for our components yet, so it looks a little boring. Mouse over the icons to see component names.

Let's quickly open and run some demos, to make sure that everything works. I suggest running ... (some LCL demo) and ... (some CastleWindow demo).

Make sure you have installed the necessary libraries first, or some of the demos will not work. The required libraries (.so under Unix, .dll under Windows) are mentioned in the <a href="http://castle-engine.sourceforge.net/apidoc/html/introduction.html#SectionLibraries">Requirements -&gt; Libraries</a> section of our reference introduction. Under Windows, you will usually want to grab http://castle-engine.sourceforge.net/miscella/win32_dlls.zip and place them somewhere on your $PATH, or just place them in every directory with .exe files that you compile with our engine.

Now we'll start creating our own game from scratch.

2. Creating OpenGL context --- a window (TCastleWindow) or a Lazarus component (TCastleControl)

First of all, you need to initialize a rectangular area on the screen that will be able to display 3D content. This is called OpenGL context. There are two ways of doing this:

- You can use our own CastleWindow unit, that defines window class TCastleWindow. This gives you the most OpenGL capabilities (our TCastleWindow allows to request some funny stuff from OpenGL, not possible otherwise) and is usually best for 3D games.

You can develop such programs using Lazarus, or any other text editor. The only real requirement is having a FreePascal installed.

The left column of this tutorial will follow this way. We'll still be using Lazarus to compile our program, simply because it's the easiest and most popular method. But we will not use Lazarus form designer. As far as Lazarus is concerned, we're creating a "Custom Application" project.

-> Create new project using Lazarus "New Project" menu item. Choose "Custom Application".

Place this source code in your program file (lpr).

[[
var
  Window: TCastleWindow;
begin
  Window := TCastleWindow.Create(Application);
  Window.OpenAndRun;
end.
]]

Press "Run" and behold, a window! (without any contents drawn, so you will probably see the underlying screen contents underneath).

As you see, we give Application (this is defined in our CastleWindow unit) as the owner (first constructor parameter) of Window. This way we don't have to care about freeing it later. When the Application is freed (which is done automatically by CastleWindow unit finalization), the Window will be freed too. You can pass "nil" instead of "Application" if you really want to avoid this automatic memory management, and free things yourself. This whole "owner" mechanism is actually a normal behavior of ObjectPascal components.

- Alternative is to use our TCastleControl inside normal Lazarus form. Just pick TCastleControl from the component palette (tab "Castle") and drop it on a regular Lazarus form. This allows for seamless integration with the normal application design using Lazarus, as you have a normal Lazarus form where you can place normal buttons and such. The downside is that our TCastleControl inherits from Lazarus TOpenGLComponent, and it has some limitations (not all OpenGL features can be requested, sometimes mouse look may stutter a little because of Lazarus event loop processing).

To develop such programs you use Lazarus, period.

This tutorial doesn't suggest any particular method (TCastleWindow or TCastleControl). Both approaches make sense, really, and it's your choice. You should choose Lazarus method (TCastleControl) if you want to integrate game context with normal GUI (Lazarus forms, controls) or if you're just more comfortable with dropping components of a Lazarus form. If you want best OpenGL features, or if you're just more comfortable working outside of Lazarus (like with custom editor and only calling FPC through a script) then probably you want to choose TCastleWindow method. The difference is only how you start: create a TCastleWindow instance by code, or drop TCastleControl on a Lazarus form. Everything else goes *almost* the same, as the TCastleControl and TCastleWindow are designed specifically to resemble each other, so they both share similar methods and properties (like "Controls", where we add our engine 2D and 3D stuff).

In case of using Lazarus forms, you will usually want to place the initialization code inside your form's methods. In the simplest case, just place it inside the form's OnCreate event.

-> Create new project using Lazarus "New Project" menu item. Choose "Application". Drop TCastleControl on your form and resize it to fit the window. Press "Run" and behold :)

3. Creating 3D world --- scene manager

Actually, this step of the tutorial is already done for you: scene manager is already created and ready for use, in SceneManager property of the TCastleControl or TCastleWindow instance. But let's stop for a second to understand what scene manager <b>is</b>, as it's quite central idea to how you work with the engine.

Scene manager is a single TCastleSceneManager class instance that knows literally everything about your 3D world. It is essential to have it, and add all your 3D stuff to it.

In the simple scenario, by default TCastleSceneManager also acts as a viewport filling the whole window. So the whole OpenGL context is drawn to show your 3D world. In more complex scenarios you can have many smaller viewports inside your window using TCastleViewport controls (we'll not discuss it in this tutorial, see <a href="http://castle-engine.sourceforge.net/vrml_engine_doc/output/xsl/html/section.custom_viewports.html">custom viewports notes</a>, and <tt>multiple_viewports</tt> example in engine sources). You can also turn off scene manager from being a viewport (DefaultViewport := false), and then scene manager is really <b>only</b> something that keeps track of 3D world, and nothing more.

As I said, you actually already have SceneManager property of your window/control, so the work is done for you. If more advanced scenarios, you may want to create and manager scene managed yourself, see <a link to vrml_engine_doc about</a>.

4. Adding your game level

We will load a game level from a 3D file. If you use a VRML/X3D file, this game level doesn't have to be static --- it can already include animated stuff, 3D sounds, scripts, and such.

- If you just want to try a ready level, download this 3D file (link to *standalone* vrml file, in a single x3d file, with no textures etc.). You can open it first with view3dscene to see how it looks like.

Or copy more interesting level model from castle_game_engine/examples/vrml/models/: copy bridge_final.x3dv, bridge.wrl, and textures/ subdirectory to your project.

- If you want, you can of course make your own new level. You can generally use any 3D modeler and export to any 3D format we can handle. Our other tutorial "how to make new level for CASTLE-2-NAME-HERE" (right now: DRAFT.modeling_tutorial.txt) describes from the basics how to use open-source Blender to create a level and export it to VRML/X3D. Highly advised reading! :)

To load a level, change your code to this:

[[
var
  Window: TCastleWindow;
  Scene: TCastleScene;
begin
  Scene := TCastleScene.Create(Application);
  Scene.Load('my_scene.x3d');
  Scene.Spatial := [ssRendering, ssDynamicCollisions];
  Scene.ProcessEvents := true;

  Window := TCastleWindow.Create(Application);
  Window.SceneManager.Items.Add(Scene);
  Window.SceneManager.MainScene := Scene;

  Window.OpenAndRun;
end.
]]

At the beginning we create a new instance of TCastleScene, and load it's contents from a file. Scene.Spatial determines what spatial structures (octrees for now) are created, the value [ssRendering, ssDynamicCollisions] is the most flexible one (it allows to speed up the rendering by frustum culling, detect collisions between player and level, and it adapts to a dynamic level that may have some animated parts). Scene.ProcessEvents activates animating VRML/X3D models (you can remove it if you know your level is, and always will be, static).

The level is added to the scene manager. The level is also set as the "MainScene" of scene manager, this means that some central settings (like initial camera position, initial headlight status and such) can be obtained from this scene.

5. Adding some items

For the sake of our engine, an item is just a 3D object. So basically, you can just add any T3D descendant (like TCastleScene or TCastlePrecalculatedAnimation) to a scene manager, exactly like we added a level scene in previous section.

However, you usually have a lot of item instances showing the same item. For example, you may place hundreds of potions on a level, and you probably want to add/delete potions on your level quickly. At the same time, you want to load (read from disk, and optimize for OpenGL rendering) only a single potion item. Each potion visible on the level just renders the same 3D model, possibly moved/rotated in a different way.

This means that want to think about two concepts separately: a <b>type</b> of item (like potion, sword, etc.) and an <b>instance</b> of this item in visible 3D world (like "potion lying beside the front door", "other potion hidden behind a secret corridor", "yet another potion not visible yet but in player's backpack", "a sword lying somewhere" and such). Don't confuse the terms <b>type</b> and <b>instance</b> here with ObjectPascal concepts. In our program, we will want to have a class (and it's instance) representing a potion, and a class (and many instances) representing each place where potion exists.

Our engine allows you to do this in a flexible way. We have many 3D objects that keep only references to other 3D objects. In particular, T3DTransfrom keeps a reference to other 3D object(s), and transforms (translates (moves), rotates, scales) them.

So you can create an instance of TCastleScene where you load an item, like potion. Then you create as many as you like instances of T3DTransform, where you add your potion as a children. Additionally, at T3DTransform, you can setup the transformation (like translation) of your item.

[[
var
  PotionType: TCastleScene;
  PotionInstance1, PotionInstance2: T3DTransform;

{ ... somewhere in begin...end block ... }
  PotionType := TCastleScene.Create(Application);
  PotionType.Load('my_scene.x3d');
  PotionType.ProcessEvents := true; // if the item model has interactive/animated parts by VRML/X3D events

  PotionInstance1 := T3DTransform.Create(Application);
  PotionInstance1.Translation := Vector3Single(1, 2, 3);
  PotionInstance1.Add(PotionType);
  SceneManager.Items.Add(PotionInstance1);

  PotionInstance2 := T3DTransform.Create(Application);
  PotionInstance2.Translation := Vector3Single(4, 5, 6);
  PotionInstance2.Add(PotionType);
  SceneManager.Items.Add(PotionInstance2);
]]

For more advanced uses, you may want to create your own class for TPotionType (descending from TCastleScene, and adding additional information, for example is this a "life potion", "mana potion", "cure potion" etc. --- we assume these potions have different 3D models, but also share some common parameters and so they want to be treated under a common class TPotionType). Also, you may want to create your own class for TPotionInstance (descending from T3DTransform, and adding additional information like "how much percent of this potion is used up (drink)"). No surprises here, you can do all this by following standard ObjectPascal syntax and conventions, example:

[[
type
  TPotionEffect = (peLife, peMana, peCurePoison);

  { A potion properties and 3D model. }
  TPotionType = class(TCastleScene)
    Effect: TPotionEffect;
    CreaturesMayPickItUp: boolean;
    FlameResistant: boolean;
  end;

  { A potion instance. This always refers to exactly one item inside
    of class TPotionType (you can use "(Items[0] as TPotionType)" to get it,
    you can introduce a method here to get it comfortably).
    When it is visible on a level (that is, added to SceneManager items
    graph), the Translation determines it's position on a level. }
  TPotionInstance = class(T3DTransform)
    PercentUsed: Integer;
  end;

var
  LifePotionType,
  ManaPotionType: TPotionType;
  LifePotionInstance1,
  LifePotionInstance2,
  ManaPotionInstance1: TPotionInstance;

{ ... somewhere in begin...end block ... }
  LifePotionType := TPotionType.Create(Application);
  LifePotionType.Load('life_potion.x3d');
  LifePotionType.Effect := peLife;

  ManaPotionType := TPotionType.Create(Application);
  ManaPotionType.Load('mana_potion.x3d');
  LifePotionType.Effect := peMana;

  LifePotionInstance1 := TPotionInstance.Create(Application);
  LifePotionInstance1.Translation := Vector3Single(1, 2, 3);
  LifePotionInstance1.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 50;
  SceneManager.Items.Add(LifePotionInstance1);

  LifePotionInstance2 := TPotionInstance.Create(Application);
  LifePotionInstance2.Translation := Vector3Single(4, 5, 6);
  LifePotionInstance2.Add(LifePotionType);
  LifePotionInstance1.PercentUsed := 12;
  SceneManager.Items.Add(LifePotionInstance2);

  ManaPotionInstance1 := TPotionInstance.Create(Application);
  ManaPotionInstance1.Translation := Vector3Single(4, 5, 6);
  ManaPotionInstance1.Add(ManaPotionType);
  SceneManager.Items.Add(ManaPotionInstance1);
]]

TODO: engine 3.1.0: We have a comfortable classes to store item information (TItem) and visible item on level (TItemOnLevel). TODO: describe here, probably replace above description. For advanced usage, it's possible that the traditional concepts of "items that can be picked", "creatures" will not suit you particular game. It's important to note that our 3D system is designed around flexible T3D class, that you can group (T3DList) and transform (T3DTransform). You can freely design your own descendants of T3DXxx classes, and have all the flexibility you want in creating... well, anything you want in your 3D world.

6. Letting player pick up items

XXX (follow the castle code, where we just check player's bounding box with items bounding box. make special utilities for this.)

(Actually, TItemOnLevel already gives this functionality automatically.)

7. Display player life and weapon

You often want to display something 2D on player screen. Let's draw a simple meter showing your life points.

TODO: demo of simple TUIControl creation

To show a weapon, or other stuff glued to the player, just add 3D things to TPlayer list. They will be automatically oriented to follow the player position and orientation.
TODO: describe also the Overal attribute here, for now not available.

8. Adding some creatures
XXX (this is just like items, except creature kinds need AI to move; engine 3.1.0 will include ready classes with such AI, for now refer to castle code.)

9. Adding some sounds

As with many other operations, you can add and control sounds to your game either by Pascal code, or by editing your data files. This gives flexibility both to a programmer and the content designer. It's your choice which approach you use &mdash; usually it's better to keep as much as possible in data files, and use code only when necessary for non-trivial situations.

First, get a sample sound file and place it within your game data. You can use this sample.wav file.

To add a looping sound to your VRML/X3D file, just open xxx.x3dv and paste there this:

[[
Sound {
  source AudioClip { url "sample.wav" loop TRUE }
}
]]

Remember that URL "sample.wav" is specified relative to the location of your xxx.x3dv file. In the simplest case, just place both xxx.x3dv and sample.wav in the same directory, and you're fine.

To play a sound from a code, add this code:

[[
Buffer := SoundEngine.LoadBuffer('sample.wav');
SoundEngine.PlaySound(Buffer, ...); // see PlaySound reference for parameters
]]

You can free the buffer once the sound has stopped. It's not important for simple programs, as we will take care to always free it before closing OpenAL context.

For more advanced uses, you can use the return value of PlaySound: it's either nil (if no OpenAL resources available to play this sound, and it's priority doesn't allow overriding other sounds) or it's a TALSound instance. If you have TALSound instance, you can use it's TALSound.OnUsingEnd event to be notified when source stops playing. You can also use other TALSound methods, e.g. update TALSound.Position, TALSound.Gain and such. You can stop playing the sound by TALSound.DoUsingEnd.

10. Adding an on-screen menu

Our TCastleWindow or TCastleControl have a list of 2D controls visible of the screen. By default, the only thing present there is a scene manager (since scene manager acts as a 2D viewport through which you see the 3D world; that's right --- the 3D stuff is "within" the 2D stuff). This way the scene manager (it's viewport) is visible on the window, which in turn means that all the 3D stuff we will add next is visible too.

You can add your own 2D controls using the Window.Controls.Add call. There are many predefined GUI controls available in our engine, look for TUIControl descendants, for example in CastleControls unit. You can also derive your own controls with ease.

For a simple on-screen menu, where all the menu items are displayed vertically on the screen, use the TCastleOnScreenMenu control. For Lazarus: drop TCastleOnScreenMenu on the form. For TCastleWindow: just create TCastleOnScreenMenu instance. Fill it's Items property (each line is a menu entry), and assign a handler for the OnClick event (to react when user chose menu item, by clicking or pressing enter key). Inside OnClick event, the CurrentItem property of your TCastleOnScreenMenu instance tells you which item was clicked. You still have to add a code to TForm.OnCreate to add this to controls list, like

  Browser.Controls.Insert(0, OnScreenMenu1);

You may also want to change the position, like

  OnScreenMenu1.Position := Vector2Integer(100, 100);
  { you may also want to set PositionRelativeMenu* (through object inspector or code) }

There is an example of this in model_3d_with_2d_controls example in engine sources, look for OnScreenMenu1 references in code.

11. Background under on-screen menu

In addition to previous point, you may want to change the menu FullSize to true. Otherwise, menu receives input only when mouse hovers over it. When FullSize, the menu obscures completely controls under it for key processing (although they are still visible as a background).

- So if you want your menu to be displayed and used orthogonally to the "live" 3D world underneath, leave FullSize = false.
- For initial game menu with items like "New Game", you probably want to disable the camera input for this scene. This allows you to display interactive 3D scene in the background, but block user from interacting with it (after all, the user should only interact with your menu on the initial screen). To do this simply set FullSize = true.

An alternative method to achieve (part) of 2nd choice is to set background level camera's IgnoreAllInputs to true. This also blocks user from moving in the scene (although it doesn't make input passed to menu regardless of mouse position).

If you want to place a static 2D image under menu, you can use TCastleImageControl underneath, instead of 3D scene.

12. Making screenshots

Making a screenshot is very easy:

[[
var
  Image: TRGBImage;
begin
  Image := Control.SaveScreen;
  try
    SaveImage(Image, 'screenshot_name.png');
  finally FreeAndNil(Image) end;
end;
]]

TRGBImage, and it's ancestor TImage and many other similar classes, is defined in the unit Images. This provides various image loading, saving and processing utilities to our engine. By having our own image handling unit, we can store images in the format best suitable for 3D graphics libraries, like OpenGL (for example, our class TS3TCImage to handle S3TC compressed images is tightly integrated there; we also handle there 3D textures).

Still, we use the excellent FPC FpImage library to load/save some image formats underneath. So we do not implement everything from stratch here, we *are* using FpImage loading/saving features.

13. Recoding movies
(Not really useful for an interactive game, but useful for various 3D viewers)

If you have a predefined animation in VRML/X3D (meaning: it plays without any user interaction), and want to record with constant number of frames per second, you can do this:

[[
in a loop:
begin
  SceneManager.MainScene.IncreaseTime(FrameTime);
  SceneManager.Camera.Idle(FrameTime, true, DummyBooleanInitializedToTrue);

  { capture and save screen as before, like: }
  Image := Control.SaveScreen;
  try
    { add your image to the movie sequence.
      Various options possible, view3dscene for now just saves a sequence
      of images to temporary location and later processes them by ffmpeg
      to produce a full movie. }
    SaveImage(Image, Format('screenshot_name_%4d.png', [FrameNumber]));
  finally FreeAndNil(Image) end;
end;
]]

IOW, you manually force the current time of the scene/camera to increase as much as you want before each screenshot. This makes it work 100% reliably, without any worries how fast you can process captured images.

The time of the scene and of the camera is actually independent. You can remove the "MainScene.IncreaseTime" call, if you know that your scene stays static (and want to force it to look like static), and want to animate only camera. Or the other way around, if your camera is static (or you want to force it to be static) but you have an animation in VRML/X3D, you can remove the "Camera.Idle" line.

FrameTime is in seconds, as both TCastleSceneCore.IncreseTime and TCamera.Idle take it's time argument in seconds. But don't worry, this is a float, so actually it honors fractions of seconds as well. So something like 1/25 to get 25 frames per second is Ok.
