TODO: the plan is to restore these properties, and even make them published, in TSceneManager.
Also, ViewportAutoResize: boolean (default true) should be published, to (dis)allow
updating this in each ContainerResize event.
Also, GLProjection and TSceneManager.Render (when it calls Scene.UpdateGeneratedTextures)
should use this.

The goal is to allow split-screen rendering and such tricks trivial,
just set ViewportAutoResize = false and set remaining Viewport* however you want.

For now, if you need this functionality, you cannot use TSceneManager (you have to do
the equivalent job of managing TVRMLGLScene and such manually), and you cannot use
GLProjection.
------------------------------------------------------------------------------
Later plans:

To make this really great, we'll have to do a little more.
We want to keep only one SceneManager (to avoid calling e.g. Idle many times),
so we cannot make assumption 1 SceneManager <=> 1 viewport.
- We need a list of viewports.
- We also need SceneManager to work, by default, as a single viewport --
  like it is now.

1. Should we make TKamViewport as TUIControl, separate from TKamSceneManager,
   that only has a link to TKamSceneManager?

   Advantage: TKamViewport
   is a natural 2D control, it has sensible and simple PositionInside,
   and placing many TKamViewport instances on Controls follows the way
   Controls work.

   Disadvantage: hmmm, TheDefaultViewport idea (link from TKamSceneManager
   to viewport for DefaultViewport = true) gets harder.

2. Or maybe make a list of viewports inside TKamSceneManager?

   type
     TKamSceneManager = class
       { Additional viewports to display 3D world.

	 This is independent from DefaultViewport.

	 When DefaultViewport = @true, this specifies additional viewports.
	 Example usage: imagine a space shooter, like Epic or Wing Commander.
	 You display in a default viewport FPS view from your space ship.
	 And additionally you have a small viewport in upper-right corner
	 that displays view from currently fired rocket.

	 When DefaultViewport = @true, this specifies viewports to use
	 @italic(instead) of default viewport. Example usage:
	 in a typical 3D modeling programs, you like to have 4 viewports
	 with 4 different cameras (front view, side view, top view,
	 and free perspective view). Or when you make a split-screen game,
	 played by 2 people on a single monitor.

	 In any case, viewports (DefaultViewport and CustomViewports) may overlap
	 with each. We first render the DefaultViewport, and then
	 CustomViewports in downto order. So the first viewport on
	 CustomViewports is considered to be the front one, this is consistent
	 with TGLUIWindow.Controls and TKamOpenGLControl.Controls treatment. }
       property CustomViewports: list of TKamViewport;
     end;

  Disadvantage: SceneManager would have to walk over it's CustomViewports
  list, checking their PositionInside, essentially duplicating what
  TGLUIWindow.Controls / TKamOpenGLControl.Controls already can do for
  their lists of TUIControls.

New idea: Make TKamSceneManager a descendant of TKamAbstractViewport.
This way we share code, and no need for dumb calls from TKamSceneManager
to TheDefaultViewport are even needed.

In any case:
- We want, for DefaultViewport = true, to have some
  TheDefaultViewport: TKamViewport instance created,
  with sizes synched (in each ContainerResize) to contained sizes,
  and with Camera synched to our Camera.

  TODO: this is not done yet. Which makes code awful,
  since the code must stay in TKamSceneManager,
  and TKamViewport duplicates it somewhat (like ApplyProjection),
  or calls it from TKamSceneManager (like RenderEverything,
  which is unclean --- it should be scene manager calling viewport,
  not the other way around, sensibly).

- Each TKamViewport takes care of passing it's events to it's Camera.

For later, something like KeyPreview for viewport would be useful
to split-screen games, to catch keys (but not mouse clicks) regardless
of mouse position (to handle keys from both players at once, assuming
not conflicting). So, actually (since TKamViewport will decide about it,
and TCamera.PositionInside is ignored), TKamViewport.KeyPreview is needed.
Maybe just make TUIControl.KeyPreview property?

TODO: use Focused = true to draw border around focused viewport
in multple_viewports.

Hm, maybe TKamCustomViewport, a common ancestor, with
common Render* methods, from which TKamSceneManager and TkamViewport derive?
This would allow making descendants of TkamViewport with specialized
rendering methods.
E.g. make in multple_viewports two viewports render with wireframe.
