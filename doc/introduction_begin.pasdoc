@title(Introduction)
@shorttitle(Introduction)

Various notes related to developing these units.

Table of contents:
@tableOfContents

@section(1 SectionAuthor Author)

This is documentation for @italic(Kambi VRML game engine),
see [http://vrmlengine.sourceforge.net/]. Developed by
Michalis Kamburelis.

All comments, bug reports, questions, patches and everything are welcome.

@section(1 SectionDocumentation About this documentation)

What you are reading right now is a documentation for my units
generated by PasDoc (see [http://pasdoc.sf.net/] and
[http://vrmlengine.sourceforge.net/sources_docs.php]).
Every unit should start with a comment documenting it's purpose,
every function (or functions' group) declared in unit's interface
should start with a comment documenting exactly what it does.
I believe everything is really good documented.
The only problem for English speakers is...

...Polish language: various parts of my Pascal sources may be still
documented in Polish. I am constantly translating those things to English,
but there's a lot of Polish text so full translation to English
isn't going to happen immediately. One thing you can do about that
is to tell me "I am interested in using/understanding
your sources and I really hate when I see a function/unit that looks
like what I want but is documented in Polish". Such "positive
criticism" should make me hasten my efforts to produce good English
documentation, so don't hesitate to email me with such requests.

@section(1 SectionCompiling Compiling)

@section(2 SectionCompilingFPC Compiling these units with FPC)

Latest stable version of FPC is always advised.
See [http://vrmlengine.sourceforge.net/sources.php#section_fpc_ver]
for more comments about FPC versions allowed.

Compile my programs with @code(compile.sh) script
prepared in directory of each program.
In summary, this script just calls fpc with proper command-line options.

If you want to use my units in your own programs then you
would probably like some way to compile only my units.
Here it is:

@orderedList(
  @item(
    If you use Lazarus, the most comfortable way to use my units
    in your programs is probably by using Lazarus kambi_units package,
    see @code(units/packages/README) in sources.)

  @item(
    If you don't use Lazarus, you should compile my units using
    @code(units/Makefile) file. GNU make is required
    (under Linux this is the default `make',
    under Win32 you can get this e.g. with FPC or Cygwin,
    under FreeBSD this is called `gmake').)

  @item(
    If you need more control over compilation process then
    you can also directly use kambi.cfg file. This is my configuration
    file for FPC. It's used by @code(units/Makefile) and by all @code(compile.sh)
    scripts of all programs. All my programs and units must be compiled with
    FPC using exactly this configuration.)
)

@section(2 SectionCompilingDelphi Compiling these units with Delphi)

Some part of these units can be compiled with Delphi 7 for Windows
(all versions, even Delphi 7 Personal).
This concerns most of the units in @code(base/) subdirectory,
all units in @code(images/) and @code(fonts/).

Maybe some other units could be compiled with Delphi, but this
would be only an accident. In particular, OpenGLh unit is only
for FPC so nothing in @code(opengl/) or @code(3dmodels.gl/)
will compile with Delphi.

Some parts possibly could be compiled with Kylix (Delphi for Linux),
but this would also be only "by accident" --- I'm not planning
to support Kylix. Let's be serious and use FPC/Lazarus.

Required Delphi compiler configuration:
@unorderedList(
  @itemSpacing Compact
  @item Complete boolean eval: off,
  @item Extended syntax: on,
  @item Typed @ operator: off,
  @item Huge strings: on,
  @item IO checking: on.
)
This is rather standard Delphi configuration, so it should not be any
problem. Other configuration settings do not matter, i.e. my code should
compile and work properly with any values of other configuration settings.

As usual you can turn on Range checking, Overflow checking and Assertions
for debugging purposes.

@section(1 SectionRequirements Requirements)

@section(2 SectionLibraries Libraries)

@link(Images) unit requires libpng (libpng.so under UNIXes,
libpng12.dll under Windows) installed if you want to load/save
PNG images. Otherwise you will get ELibPngNotAvailable exception
when trying to load/save files in PNG format.
Note that libpng requires also zlib installed.

KambiZlib unit (required by KambiZStream unit and used by
VRMLNodes) requires zlib installed.

Some additional libraries are required for sound playing: OggVorbis stuff
requires @code(@noAutoLink(vorbisfile)) library, OpenAL stuff naturally requires
OpenAL library. But all sound units are implemented in such way that
even if the user doesn't have OpenAL/@noAutoLink(vorbisfile) installed,
programs using these units can still run fine (e.g. units will not raise
any exception at unit initialization just because some library cannot
be loaded; instead, appropriate boolean variable will be set to @false,
and higher-level code can always check this).

For Windows, you can get some of the required DLLs easily
from my site, [http://vrmlengine.sourceforge.net/miscella/win32_dlls.zip].
Inside this archive there are also pointers where the "upstream" versions
of these DLLs can be found on WWW.

On Mac OS X there are some additional requirements, since Mac OS X
port is done much like any other Unix right now. So some units require
some typical Unix libraries, like X11, GTK, GTKGlExt etc. See
[http://vrmlengine.sourceforge.net/macosx_requirements.php]
for details.

@section(2 SectionOsArchCompat OS / architectures compatibility)

My units don't really depend on any specific UNIX flawour
(like Linux, FreeBSD, Darwin/Mac OS X).
This means that you should be able to compile
them under all UNIXes supported by FPC >= 2.0.x.
Windows is also OK.

As for processors: I tested only on i386 architectures,
although some work was done to make it easily portable to other processors.
Try, and maybe it will work. And remember to report any
successes or failures.

@section(1 SectionUnitsMap Units map)

Here's a short map of important units documented here.
Units are divided into a couple of groups.
Group's name (like "@code(base)") is also the name of
subdirectory where unit's source code is placed.
The "@italic(Uses:)" notes below say which
units are allowed to be used by units in specific group.

@definitionList(
  @itemLabel @code(base)
  @item(
    These units provide some basic functions and classes,
    in many cases OS-specific.
    Most important are KambiUtils, KambiClassUtils units which are
    large units that contain many small and useful things.

    There are also some templates
    (see dynarray.inc, dim2array.inc, dim3array.inc, objectslist.inc,
    and their duplicated versions in templates/ subdirectory).

    There are also units for parsing and evaluating mathematical expressions
    (MathExprLexer, MathExprParser, MathExpr), unit ParsingPars
    for command-line parsing, VectorMath unit with a lot of primitive
    geometry types and functions. And some more.

    @italic(Uses:) Nothing. These units do not depend on units
    from other groups.)

  @itemLabel @code(audio)
  @item(
    These are my audio units. OpenAL header translation (@link(OpenAL)),
    OpenAL helper routines (ALUtils), simple WAV file reader (SoundWAV).

    @italic(Uses:) @code(base).)

  @itemLabel @code(images)
  @item(
    This is my @link(Images) unit to load images to 2d pixel arrays.
    Also some things to handle PasJPEG.
    Also my binding to libpng library (KambiPng)
    and some helpers (KambiPngUtils).

    @italic(Uses:) @code(base).)

  @itemLabel @code(fonts)
  @item(
    Units TTFontsTypes and BmpFontsTypes and many units named
    TTF_* and BFNT_* that depend on TTFontsTypes or BmpFontsTypes.
    Units TTF_* and BFNT_* are automatically generated using font2pascal
    program. Also some helpers for Windows fonts and for translating them
    to Pascal sources (like those TTF_* and BFNT_* units).

    @italic(Uses:) @code(base).)

  @itemLabel @code(3dgraph)
  @item(
    Units dealing with basic 3d graphics.
    @italic(Not) dependent on OpenGL and @italic(not) doing anything
    closely related to "processing 3d models".
    These units make some base for units in @code(opengl) and @code(3dmodels)
    groups. BackgroundBase, MatrixNavigation, SpaceFillingCurves etc.

    Note: VectorMath unit is considered by me as something more general and
    useful --- so it's in @code(base) group, not here.

    @italic(Uses:) @code(base), @code(images).)

  @itemLabel @code(opengl)
  @item(
    Basic units that use OpenGL. OpenGL header (OpenGLh unit),
    GLWindow unit (something like "my glut (with many many enhancements)"),
    OpenGL fonts --- bitmap (OpenGLBmpFonts) and outline (OpenGLTTFonts),
    various OpenGL helpers (KambiGLUtils, TimeMessages, ProgresGL,
    GLWinMessages, GLWinInputs).

    @italic(Uses:) @code(base), @code(images), @code(3dgraph), @code(fonts).)

  @itemLabel @code(3dmodels)
  @item(
    Units to handle and process 3D models.
    VRML file reading, writing and processing (VRMLLexer, VRMLFields,
    VRMLNodes), building and using octree based on VRML model (VRMLOctree),
    ray-tracer based on VRML model (VRMLRayTracer),
    other 3d model formats reading (Object3dGEO, Object3ds, Object3dOBJ)
    and converting to VRML (Object3dAsVRML).

    These units do @italic(not) depend on OpenGL.

    @italic(Uses:) @code(base), @code(images), @code(3dgraph).)

  @itemLabel @code(3dmodels.gl)
  @item(
    Units handling 3D models and do something OpenGL-specific.
    Basically this means that they use units in both @code(opengl)
    and @code(3dmodels) groups.

    First of all, that's VRMLFlatSceneGL unit that provides
    the most final and complete class for dealing with VRML models and
    displaying them in OpenGL.

    @italic(Uses:) @code(base), @code(images), @code(3dgraph), @code(fonts),
      @code(opengl), @code(3dmodels).)
)

@section(1 SectionImplementation Implementation notes (i.e. how does it work ?))